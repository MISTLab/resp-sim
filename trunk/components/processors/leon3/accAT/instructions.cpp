/***************************************************************************\
 *
 *   
 *            ___        ___           ___           ___
 *           /  /\      /  /\         /  /\         /  /\
 *          /  /:/     /  /::\       /  /::\       /  /::\
 *         /  /:/     /  /:/\:\     /  /:/\:\     /  /:/\:\
 *        /  /:/     /  /:/~/:/    /  /:/~/::\   /  /:/~/:/
 *       /  /::\    /__/:/ /:/___ /__/:/ /:/\:\ /__/:/ /:/
 *      /__/:/\:\   \  \:\/:::::/ \  \:\/:/__\/ \  \:\/:/
 *      \__\/  \:\   \  \::/~~~~   \  \::/       \  \::/
 *           \  \:\   \  \:\        \  \:\        \  \:\
 *            \  \ \   \  \:\        \  \:\        \  \:\
 *             \__\/    \__\/         \__\/         \__\/
 *   
 *
 *
 *   
 *   This file is part of TRAP.
 *   
 *   TRAP is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU Lesser General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *   
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU Lesser General Public License for more details.
 *   
 *   You should have received a copy of the GNU Lesser General Public License
 *   along with this program; if not, write to the
 *   Free Software Foundation, Inc.,
 *   51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *   or see <http://www.gnu.org/licenses/>.
 *   
 *
 *
 *   (c) Luca Fossati, fossati@elet.polimi.it
 *
\***************************************************************************/



#include <instructionBase.hpp>
#include <map>
#include <vector>
#include <string>
#include <customExceptions.hpp>
#include <trap_utils.hpp>
#include <registers.hpp>
#include <alias.hpp>
#include <externalPorts.hpp>
#include <externalPins.hpp>
#include <instructions.hpp>
#include <sstream>
#include <systemc.h>

using namespace leon3_accat_trap;
bool leon3_accat_trap::Instruction::IncrementRegWindow() throw(){
    {
        unsigned int newCwp;

        #define PSR PSR_decode
        #define WIM WIM_decode
        #define TBR TBR_decode
        #define Y Y_decode
        #define PC PC_decode
        #define NPC NPC_decode
        #define GLOBAL GLOBAL_decode
        #define WINREGS WINREGS_decode
        #define ASR ASR_decode
        #define FP FP_decode
        #define LR LR_decode
        #define SP SP_decode
        #define PCR PCR_decode
        #define REGS REGS_decode


        newCwp = ((unsigned int)(PSR[key_CWP] + 1)) % NUM_REG_WIN;
        if(((0x01 << (newCwp)) & WIM) != 0){
            return false;
        }
        PSR = (PSR & 0xFFFFFFE0) | newCwp;
        #ifndef ACC_MODEL
        //Functional model: we simply immediately update the alias
        for(int i = 8; i < 32; i++){
            REGS[i].updateAlias(WINREGS[(newCwp*16 + i - 8) & 0x7f]);
        }
        #else
        //Cycle accurate model: we have to update the alias using the pipeline register
        //We update the aliases for this stage and for all the preceding ones (we are in the
        //decode stage and we need to update fetch, and decode)
        for(int i = 8; i < 32; i++){
            REGS_fetch[i].updateAlias(WINREGS_pipe[(newCwp*16 + i - 8) & 0x7f]);
            REGS_decode[i].updateAlias(WINREGS_pipe[(newCwp*16 + i - 8) & 0x7f]);
        }
        #endif
        return true;
        #undef PSR
        #undef WIM
        #undef TBR
        #undef Y
        #undef PC
        #undef NPC
        #undef GLOBAL
        #undef WINREGS
        #undef ASR
        #undef FP
        #undef LR
        #undef SP
        #undef PCR
        #undef REGS
    }
}

bool leon3_accat_trap::Instruction::DecrementRegWindow() throw(){
    {
        unsigned int newCwp;

        #define PSR PSR_decode
        #define WIM WIM_decode
        #define TBR TBR_decode
        #define Y Y_decode
        #define PC PC_decode
        #define NPC NPC_decode
        #define GLOBAL GLOBAL_decode
        #define WINREGS WINREGS_decode
        #define ASR ASR_decode
        #define FP FP_decode
        #define LR LR_decode
        #define SP SP_decode
        #define PCR PCR_decode
        #define REGS REGS_decode


        newCwp = ((unsigned int)(PSR[key_CWP] - 1)) % NUM_REG_WIN;
        if(((0x01 << (newCwp)) & WIM) != 0){
            return false;
        }
        PSR = (PSR & 0xFFFFFFE0) | newCwp;
        #ifndef ACC_MODEL
        //Functional model: we simply immediately update the alias
        for(int i = 8; i < 32; i++){
            REGS[i].updateAlias(WINREGS[(newCwp*16 + i - 8) & 0x7f]);
        }
        #else
        //Cycle accurate model: we have to update the alias using the pipeline register
        //We update the aliases for this stage and for all the preceding ones (we are in the
        //decode stage and we need to update fetch, and decode)
        for(int i = 8; i < 32; i++){
            REGS_fetch[i].updateAlias(WINREGS_pipe[(newCwp*16 + i - 8) & 0x7f]);
            REGS_decode[i].updateAlias(WINREGS_pipe[(newCwp*16 + i - 8) & 0x7f]);
        }
        #endif
        return true;
        #undef PSR
        #undef WIM
        #undef TBR
        #undef Y
        #undef PC
        #undef NPC
        #undef GLOBAL
        #undef WINREGS
        #undef ASR
        #undef FP
        #undef LR
        #undef SP
        #undef PCR
        #undef REGS
    }
}

int leon3_accat_trap::Instruction::SignExtend( unsigned int bitSeq, unsigned int \
    bitSeq_length ) const throw(){

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute


    if((bitSeq & (1 << (bitSeq_length - 1))) != 0)
    bitSeq |= (((unsigned int)0xFFFFFFFF) << bitSeq_length);
    return bitSeq;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
}

void leon3_accat_trap::Instruction::RaiseException( unsigned int pcounter, unsigned \
    int npcounter, unsigned int exceptionId, unsigned int customTrapOffset ){

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception


    if(PSR[key_ET] == 0){
        if(exceptionId < IRQ_LEV_15){
            // I print a core dump and then I signal an error: an exception happened while
            // exceptions were disabled in the processor core
            THROW_EXCEPTION("Exception " << exceptionId << " happened while the PSR[ET] = 0; \
                PC = " << std::hex << std::showbase << PC << std::endl << "Instruction " << getMnemonic());
        }
    }
    else{
        unsigned int curPSR = PSR;
        curPSR = (curPSR & 0xffffffbf) | (PSR[key_S] << 6);
        curPSR = (curPSR & 0xffffff7f) | 0x00000080;
        curPSR &= 0xffffffdf;
        unsigned int newCwp = ((unsigned int)(PSR[key_CWP] - 1)) % NUM_REG_WIN;
        #ifndef ACC_MODEL
        //Functional model: we simply immediately update the alias
        for(int i = 8; i < 32; i++){
            REGS[i].updateAlias(WINREGS[(newCwp*16 + i - 8) & 0x7f]);
        }
        #else
        //Cycle accurate model: we have to update the alias using the pipeline register
        //We update the aliases for this stage and for all the preceding ones (we are in the
        //execute stage and we need to update fetch, decode, and register read and execute)
        for(int i = 8; i < 32; i++){
            REGS_fetch[i].updateAlias(WINREGS_pipe[(newCwp*16 + i - 8) & 0x7f]);
            REGS_decode[i].updateAlias(WINREGS_pipe[(newCwp*16 + i - 8) & 0x7f]);
            REGS_regs[i].updateAlias(WINREGS_pipe[(newCwp*16 + i - 8) & 0x7f]);
            REGS_execute[i].updateAlias(WINREGS_pipe[(newCwp*16 + i - 8) & 0x7f]);
            REGS_memory[i].updateAlias(WINREGS_pipe[(newCwp*16 + i - 8) & 0x7f]);
            REGS_exception[i].updateAlias(WINREGS_pipe[(newCwp*16 + i - 8) & 0x7f]);
        }
        #endif

        curPSR = (curPSR & 0xffffffe0) + newCwp;
        PSR = curPSR;
        #ifdef ACC_MODEL
        PSR_execute = curPSR;
        #endif
        REGS[17] = pcounter;
        REGS[18] = npcounter;
        switch(exceptionId){
            case RESET:{
            }break;
            case DATA_STORE_ERROR:{
                TBR[key_TT] = 0x2b;
            }break;
            case INSTR_ACCESS_MMU_MISS:{
                TBR[key_TT] = 0x3c;
            }break;
            case INSTR_ACCESS_ERROR:{
                TBR[key_TT] = 0x21;
            }break;
            case R_REGISTER_ACCESS_ERROR:{
                TBR[key_TT] = 0x20;
            }break;
            case INSTR_ACCESS_EXC:{
                TBR[key_TT] = 0x01;
            }break;
            case PRIVILEDGE_INSTR:{
                TBR[key_TT] = 0x03;
            }break;
            case ILLEGAL_INSTR:{
                TBR[key_TT] = 0x02;
            }break;
            case FP_DISABLED:{
                TBR[key_TT] = 0x04;
            }break;
            case CP_DISABLED:{
                TBR[key_TT] = 0x24;
            }break;
            case UNIMPL_FLUSH:{
                TBR[key_TT] = 0x25;
            }break;
            case WATCHPOINT_DETECTED:{
                TBR[key_TT] = 0x0b;
            }break;
            case WINDOW_OVERFLOW:{
                TBR[key_TT] = 0x05;
            }break;
            case WINDOW_UNDERFLOW:{
                TBR[key_TT] = 0x06;
            }break;
            case MEM_ADDR_NOT_ALIGNED:{
                TBR[key_TT] = 0x07;
            }break;
            case FP_EXCEPTION:{
                TBR[key_TT] = 0x08;
            }break;
            case CP_EXCEPTION:{
                TBR[key_TT] = 0x28;
            }break;
            case DATA_ACCESS_ERROR:{
                TBR[key_TT] = 0x29;
            }break;
            case DATA_ACCESS_MMU_MISS:{
                TBR[key_TT] = 0x2c;
            }break;
            case DATA_ACCESS_EXC:{
                TBR[key_TT] = 0x09;
            }break;
            case TAG_OVERFLOW:{
                TBR[key_TT] = 0x0a;
            }break;
            case DIV_ZERO:{
                TBR[key_TT] = 0x2a;
            }break;
            case TRAP_INSTRUCTION:{
                TBR[key_TT] = 0x80 + customTrapOffset;
            }break;
            case IRQ_LEV_15:{
                TBR[key_TT] = 0x1f;
            }break;
            case IRQ_LEV_14:{
                TBR[key_TT] = 0x1e;
            }break;
            case IRQ_LEV_13:{
                TBR[key_TT] = 0x1d;
            }break;
            case IRQ_LEV_12:{
                TBR[key_TT] = 0x1c;
            }break;
            case IRQ_LEV_11:{
                TBR[key_TT] = 0x1b;
            }break;
            case IRQ_LEV_10:{
                TBR[key_TT] = 0x1a;
            }break;
            case IRQ_LEV_9:{
                TBR[key_TT] = 0x19;
            }break;
            case IRQ_LEV_8:{
                TBR[key_TT] = 0x18;
            }break;
            case IRQ_LEV_7:{
                TBR[key_TT] = 0x17;
            }break;
            case IRQ_LEV_6:{
                TBR[key_TT] = 0x16;
            }break;
            case IRQ_LEV_5:{
                TBR[key_TT] = 0x15;
            }break;
            case IRQ_LEV_4:{
                TBR[key_TT] = 0x14;
            }break;
            case IRQ_LEV_3:{
                TBR[key_TT] = 0x13;
            }break;
            case IRQ_LEV_2:{
                TBR[key_TT] = 0x12;
            }break;
            case IRQ_LEV_1:{
                TBR[key_TT] = 0x11;
            }break;
            case IMPL_DEP_EXC:{
                TBR[key_TT] = 0x60 + customTrapOffset;
            }break;
            default:{
            }break;
        }
        if(exceptionId == RESET){
            // I have to jump to address 0 and restart execution
            PC = 0;
            NPC = 4;
        }
        else{
            // I have to jump to the address contained in the TBR register
            PC = TBR;
            NPC = TBR + 4;
        }
        if(exceptionId > TRAP_INSTRUCTION && exceptionId < IMPL_DEP_EXC){
            // finally I acknowledge the interrupt on the external pin port
            irqAck.send_pin_req(IMPL_DEP_EXC - exceptionId, 0);
        }
        flush();
        annull();
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
}

bool leon3_accat_trap::Instruction::checkIncrementWin() const throw(){

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode


    unsigned int newCwp = ((unsigned int)(PSR[key_CWP] + 1)) % NUM_REG_WIN;
    if(((0x01 << (newCwp)) & WIM) != 0){
        return false;
    }
    else{
        return true;
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
}

bool leon3_accat_trap::Instruction::checkDecrementWin() const throw(){

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode


    unsigned int newCwp = ((unsigned int)(PSR[key_CWP] - 1)) % NUM_REG_WIN;
    if(((0x01 << (newCwp)) & WIM) != 0){
        return false;
    }
    else{
        return true;
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
}

leon3_accat_trap::Instruction::Instruction( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : PSR_pipe(PSR_pipe), WIM_pipe(WIM_pipe), TBR_pipe(TBR_pipe), \
    Y_pipe(Y_pipe), PC_pipe(PC_pipe), NPC_pipe(NPC_pipe), GLOBAL_pipe(GLOBAL_pipe), WINREGS_pipe(WINREGS_pipe), \
    ASR_pipe(ASR_pipe), PSR_fetch(PSR_fetch), WIM_fetch(WIM_fetch), TBR_fetch(TBR_fetch), \
    Y_fetch(Y_fetch), PC_fetch(PC_fetch), NPC_fetch(NPC_fetch), GLOBAL_fetch(GLOBAL_fetch), \
    WINREGS_fetch(WINREGS_fetch), ASR_fetch(ASR_fetch), FP_fetch(FP_fetch), LR_fetch(LR_fetch), \
    SP_fetch(SP_fetch), PCR_fetch(PCR_fetch), REGS_fetch(REGS_fetch), PSR_decode(PSR_decode), \
    WIM_decode(WIM_decode), TBR_decode(TBR_decode), Y_decode(Y_decode), PC_decode(PC_decode), \
    NPC_decode(NPC_decode), GLOBAL_decode(GLOBAL_decode), WINREGS_decode(WINREGS_decode), \
    ASR_decode(ASR_decode), FP_decode(FP_decode), LR_decode(LR_decode), SP_decode(SP_decode), \
    PCR_decode(PCR_decode), REGS_decode(REGS_decode), PSR_regs(PSR_regs), WIM_regs(WIM_regs), \
    TBR_regs(TBR_regs), Y_regs(Y_regs), PC_regs(PC_regs), NPC_regs(NPC_regs), GLOBAL_regs(GLOBAL_regs), \
    WINREGS_regs(WINREGS_regs), ASR_regs(ASR_regs), FP_regs(FP_regs), LR_regs(LR_regs), \
    SP_regs(SP_regs), PCR_regs(PCR_regs), REGS_regs(REGS_regs), PSR_execute(PSR_execute), \
    WIM_execute(WIM_execute), TBR_execute(TBR_execute), Y_execute(Y_execute), PC_execute(PC_execute), \
    NPC_execute(NPC_execute), GLOBAL_execute(GLOBAL_execute), WINREGS_execute(WINREGS_execute), \
    ASR_execute(ASR_execute), FP_execute(FP_execute), LR_execute(LR_execute), SP_execute(SP_execute), \
    PCR_execute(PCR_execute), REGS_execute(REGS_execute), PSR_memory(PSR_memory), WIM_memory(WIM_memory), \
    TBR_memory(TBR_memory), Y_memory(Y_memory), PC_memory(PC_memory), NPC_memory(NPC_memory), \
    GLOBAL_memory(GLOBAL_memory), WINREGS_memory(WINREGS_memory), ASR_memory(ASR_memory), \
    FP_memory(FP_memory), LR_memory(LR_memory), SP_memory(SP_memory), PCR_memory(PCR_memory), \
    REGS_memory(REGS_memory), PSR_exception(PSR_exception), WIM_exception(WIM_exception), \
    TBR_exception(TBR_exception), Y_exception(Y_exception), PC_exception(PC_exception), \
    NPC_exception(NPC_exception), GLOBAL_exception(GLOBAL_exception), WINREGS_exception(WINREGS_exception), \
    ASR_exception(ASR_exception), FP_exception(FP_exception), LR_exception(LR_exception), \
    SP_exception(SP_exception), PCR_exception(PCR_exception), REGS_exception(REGS_exception), \
    PSR_wb(PSR_wb), WIM_wb(WIM_wb), TBR_wb(TBR_wb), Y_wb(Y_wb), PC_wb(PC_wb), NPC_wb(NPC_wb), \
    GLOBAL_wb(GLOBAL_wb), WINREGS_wb(WINREGS_wb), ASR_wb(ASR_wb), FP_wb(FP_wb), LR_wb(LR_wb), \
    SP_wb(SP_wb), PCR_wb(PCR_wb), REGS_wb(REGS_wb), instrMem(instrMem), dataMem(dataMem), \
    irqAck(irqAck), NUM_REG_WIN(8), PIPELINED_MULT(false){
    this->stageCycles = 0;
    this->flushPipeline = false;
    this->fetchPC = 0;
    this->toDestroy = false;
    this->inPipeline = false;
}

leon3_accat_trap::Instruction::~Instruction(){

}
unsigned int leon3_accat_trap::InvalidInstr::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    return 0;
}

unsigned int leon3_accat_trap::InvalidInstr::behavior_decode( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    return 0;
}

unsigned int leon3_accat_trap::InvalidInstr::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    return 0;
}

unsigned int leon3_accat_trap::InvalidInstr::behavior_execute( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    THROW_EXCEPTION("Unknown Instruction at PC: " << std::hex << std::showbase << this->fetchPC);
    return 0;
}

unsigned int leon3_accat_trap::InvalidInstr::behavior_memory( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    return 0;
}

unsigned int leon3_accat_trap::InvalidInstr::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    return 0;
}

unsigned int leon3_accat_trap::InvalidInstr::behavior_wb( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    return 0;
}

Instruction * leon3_accat_trap::InvalidInstr::replicate() const throw(){
    return new InvalidInstr(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, \
        GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, \
        NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, \
        PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

void leon3_accat_trap::InvalidInstr::setParams( const unsigned int & bitString ) throw(){

}

std::string leon3_accat_trap::InvalidInstr::getInstructionName() const throw(){
    return "InvalidInstruction";
}

std::string leon3_accat_trap::InvalidInstr::getMnemonic() const throw(){
    return "invalid";
}

unsigned int leon3_accat_trap::InvalidInstr::getId() const throw(){
    return 144;
}

std::string leon3_accat_trap::InvalidInstr::printBusyRegs(){
    return "";
}

bool leon3_accat_trap::InvalidInstr::checkHazard_fetch(){
    return true;
}

void leon3_accat_trap::InvalidInstr::lockRegs_fetch(){

}

bool leon3_accat_trap::InvalidInstr::checkHazard_decode(){
    return true;
}

void leon3_accat_trap::InvalidInstr::lockRegs_decode(){

}

bool leon3_accat_trap::InvalidInstr::checkHazard_regs(){
    return true;
}

void leon3_accat_trap::InvalidInstr::lockRegs_regs(){

}

bool leon3_accat_trap::InvalidInstr::checkHazard_execute(){
    return true;
}

void leon3_accat_trap::InvalidInstr::lockRegs_execute(){

}

bool leon3_accat_trap::InvalidInstr::checkHazard_memory(){
    return true;
}

void leon3_accat_trap::InvalidInstr::lockRegs_memory(){

}

bool leon3_accat_trap::InvalidInstr::checkHazard_exception(){
    return true;
}

void leon3_accat_trap::InvalidInstr::lockRegs_exception(){

}

bool leon3_accat_trap::InvalidInstr::checkHazard_wb(){
    return true;
}

void leon3_accat_trap::InvalidInstr::lockRegs_wb(){

}

void leon3_accat_trap::InvalidInstr::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::InvalidInstr::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::InvalidInstr::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::InvalidInstr::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::InvalidInstr::getUnlock_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){

}

void leon3_accat_trap::InvalidInstr::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

leon3_accat_trap::InvalidInstr::InvalidInstr( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){

}

leon3_accat_trap::InvalidInstr::~InvalidInstr(){

}
unsigned int leon3_accat_trap::NOPInstruction::behavior_fetch( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
}

unsigned int leon3_accat_trap::NOPInstruction::behavior_decode( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    return 0;
}

unsigned int leon3_accat_trap::NOPInstruction::behavior_regs( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    return 0;
}

unsigned int leon3_accat_trap::NOPInstruction::behavior_execute( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    return 0;
}

unsigned int leon3_accat_trap::NOPInstruction::behavior_memory( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    return 0;
}

unsigned int leon3_accat_trap::NOPInstruction::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    return 0;
}

unsigned int leon3_accat_trap::NOPInstruction::behavior_wb( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    return 0;
}

Instruction * leon3_accat_trap::NOPInstruction::replicate() const throw(){
    return new NOPInstruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, \
        GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, \
        NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, \
        PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

void leon3_accat_trap::NOPInstruction::setParams( const unsigned int & bitString \
    ) throw(){

}

std::string leon3_accat_trap::NOPInstruction::getInstructionName() const throw(){
    return "NOPInstruction";
}

std::string leon3_accat_trap::NOPInstruction::getMnemonic() const throw(){
    return "nop";
}

unsigned int leon3_accat_trap::NOPInstruction::getId() const throw(){
    return (unsigned int)-1;
}

std::string leon3_accat_trap::NOPInstruction::printBusyRegs(){
    return "";
}

bool leon3_accat_trap::NOPInstruction::checkHazard_fetch(){
    return true;
}

void leon3_accat_trap::NOPInstruction::lockRegs_fetch(){

}

bool leon3_accat_trap::NOPInstruction::checkHazard_decode(){
    return true;
}

void leon3_accat_trap::NOPInstruction::lockRegs_decode(){

}

bool leon3_accat_trap::NOPInstruction::checkHazard_regs(){
    return true;
}

void leon3_accat_trap::NOPInstruction::lockRegs_regs(){

}

bool leon3_accat_trap::NOPInstruction::checkHazard_execute(){
    return true;
}

void leon3_accat_trap::NOPInstruction::lockRegs_execute(){

}

bool leon3_accat_trap::NOPInstruction::checkHazard_memory(){
    return true;
}

void leon3_accat_trap::NOPInstruction::lockRegs_memory(){

}

bool leon3_accat_trap::NOPInstruction::checkHazard_exception(){
    return true;
}

void leon3_accat_trap::NOPInstruction::lockRegs_exception(){

}

bool leon3_accat_trap::NOPInstruction::checkHazard_wb(){
    return true;
}

void leon3_accat_trap::NOPInstruction::lockRegs_wb(){

}

void leon3_accat_trap::NOPInstruction::getUnlock_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){

}

void leon3_accat_trap::NOPInstruction::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::NOPInstruction::getUnlock_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){

}

void leon3_accat_trap::NOPInstruction::getUnlock_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){

}

void leon3_accat_trap::NOPInstruction::getUnlock_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){

}

void leon3_accat_trap::NOPInstruction::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

leon3_accat_trap::NOPInstruction::NOPInstruction( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){

}

leon3_accat_trap::NOPInstruction::~NOPInstruction(){

}
unsigned int leon3_accat_trap::READasr::behavior_fetch( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::READasr::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::READasr::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs


    asr_temp = ASR[asr];

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::READasr::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::READasr::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::READasr::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::READasr::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb


    rd = asr_temp;
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    return this->stageCycles;
}

std::string leon3_accat_trap::READasr::printBusyRegs(){
    std::string retVal = "";
    return retVal;
}

bool leon3_accat_trap::READasr::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::READasr::lockRegs_fetch(){

}

bool leon3_accat_trap::READasr::checkHazard_decode(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::READasr::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::READasr::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::READasr::lockRegs_regs(){

}

bool leon3_accat_trap::READasr::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::READasr::lockRegs_execute(){

}

bool leon3_accat_trap::READasr::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::READasr::lockRegs_memory(){

}

bool leon3_accat_trap::READasr::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::READasr::lockRegs_exception(){

}

bool leon3_accat_trap::READasr::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::READasr::lockRegs_wb(){

}

void leon3_accat_trap::READasr::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::READasr::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::READasr::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::READasr::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::READasr::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::READasr::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::READasr::replicate() const throw(){
    return new READasr(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::READasr::getInstructionName() const throw(){
    return "READasr";
}

unsigned int leon3_accat_trap::READasr::getId() const throw(){
    return 126;
}

void leon3_accat_trap::READasr::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->asr = (bitString & 0x7c000) >> 14;
}

std::string leon3_accat_trap::READasr::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "rd asr ";
    oss << this->asr;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::READasr::READasr( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
}

leon3_accat_trap::READasr::~READasr(){

}
unsigned int leon3_accat_trap::WRITEY_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEY_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEY_reg::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    result = rs1 ^ rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEY_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    Y = result;
    unlockQueue[0].push_back(&Y_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEY_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEY_reg::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEY_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb

    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::WRITEY_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::WRITEY_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEY_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::WRITEY_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::WRITEY_reg::lockRegs_decode(){
    this->Y_pipe.lock();
}

bool leon3_accat_trap::WRITEY_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEY_reg::lockRegs_regs(){

}

bool leon3_accat_trap::WRITEY_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEY_reg::lockRegs_execute(){

}

bool leon3_accat_trap::WRITEY_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEY_reg::lockRegs_memory(){

}

bool leon3_accat_trap::WRITEY_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEY_reg::lockRegs_exception(){

}

bool leon3_accat_trap::WRITEY_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEY_reg::lockRegs_wb(){

}

void leon3_accat_trap::WRITEY_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
}

void leon3_accat_trap::WRITEY_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
}

void leon3_accat_trap::WRITEY_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
}

void leon3_accat_trap::WRITEY_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
}

void leon3_accat_trap::WRITEY_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
}

void leon3_accat_trap::WRITEY_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
}

Instruction * leon3_accat_trap::WRITEY_reg::replicate() const throw(){
    return new WRITEY_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::WRITEY_reg::getInstructionName() const throw(){
    return "WRITEY_reg";
}

unsigned int leon3_accat_trap::WRITEY_reg::getId() const throw(){
    return 130;
}

void leon3_accat_trap::WRITEY_reg::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
}

std::string leon3_accat_trap::WRITEY_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "wr r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << " y";
    return oss.str();
}

leon3_accat_trap::WRITEY_reg::WRITEY_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::WRITEY_reg::~WRITEY_reg(){

}
unsigned int leon3_accat_trap::XNOR_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XNOR_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XNOR_reg::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    rs1_op = rs1;
    rs2_op = rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XNOR_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    result = rs1_op ^ ~rs2_op;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XNOR_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XNOR_reg::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XNOR_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::XNOR_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::XNOR_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XNOR_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::XNOR_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::XNOR_reg::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::XNOR_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XNOR_reg::lockRegs_regs(){

}

bool leon3_accat_trap::XNOR_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XNOR_reg::lockRegs_execute(){

}

bool leon3_accat_trap::XNOR_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XNOR_reg::lockRegs_memory(){

}

bool leon3_accat_trap::XNOR_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XNOR_reg::lockRegs_exception(){

}

bool leon3_accat_trap::XNOR_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XNOR_reg::lockRegs_wb(){

}

void leon3_accat_trap::XNOR_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::XNOR_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::XNOR_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::XNOR_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::XNOR_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::XNOR_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::XNOR_reg::replicate() const throw(){
    return new XNOR_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::XNOR_reg::getInstructionName() const throw(){
    return "XNOR_reg";
}

unsigned int leon3_accat_trap::XNOR_reg::getId() const throw(){
    return 58;
}

void leon3_accat_trap::XNOR_reg::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
}

std::string leon3_accat_trap::XNOR_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "xnor r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::XNOR_reg::XNOR_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::XNOR_reg::~XNOR_reg(){

}
unsigned int leon3_accat_trap::ANDNcc_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ANDNcc_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ANDNcc_reg::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    rs1_op = rs1;
    rs2_op = rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ANDNcc_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    result = rs1_op & ~rs2_op;


    PSR[key_ICC_n] = ((result & 0x80000000) >> 31);
    PSR[key_ICC_z] = (result == 0);
    PSR[key_ICC_v] = 0;
    PSR[key_ICC_c] = 0;
    unlockQueue[0].push_back(&PSR_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ANDNcc_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ANDNcc_reg::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ANDNcc_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::ANDNcc_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::ANDNcc_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ANDNcc_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::ANDNcc_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::ANDNcc_reg::lockRegs_decode(){
    this->rd_decode.lock();
    this->PSR_pipe.lock();
}

bool leon3_accat_trap::ANDNcc_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ANDNcc_reg::lockRegs_regs(){

}

bool leon3_accat_trap::ANDNcc_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ANDNcc_reg::lockRegs_execute(){

}

bool leon3_accat_trap::ANDNcc_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ANDNcc_reg::lockRegs_memory(){

}

bool leon3_accat_trap::ANDNcc_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ANDNcc_reg::lockRegs_exception(){

}

bool leon3_accat_trap::ANDNcc_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ANDNcc_reg::lockRegs_wb(){

}

void leon3_accat_trap::ANDNcc_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::ANDNcc_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::ANDNcc_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::ANDNcc_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::ANDNcc_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::ANDNcc_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::ANDNcc_reg::replicate() const throw(){
    return new ANDNcc_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::ANDNcc_reg::getInstructionName() const throw(){
    return "ANDNcc_reg";
}

unsigned int leon3_accat_trap::ANDNcc_reg::getId() const throw(){
    return 44;
}

void leon3_accat_trap::ANDNcc_reg::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
}

std::string leon3_accat_trap::ANDNcc_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "andncc r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::ANDNcc_reg::ANDNcc_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::ANDNcc_reg::~ANDNcc_reg(){

}
unsigned int leon3_accat_trap::LDSB_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch
    #define rd rd_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSB_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSB_imm::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs
    #define rd rd_regs


    address = rs1 + SignExtend(simm13, 13);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSB_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSB_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_memory
    #define WIM WIM_memory
    #define TBR TBR_memory
    #define Y Y_memory
    #define PC PC_memory
    #define NPC NPC_memory
    #define GLOBAL GLOBAL_memory
    #define WINREGS WINREGS_memory
    #define ASR ASR_memory
    #define FP FP_memory
    #define LR LR_memory
    #define SP SP_memory
    #define PCR PCR_memory
    #define REGS REGS_memory
    #define rs1 rs1_memory
    #define rd rd_memory


    readValue = SignExtend(dataMem.read_byte(address), 8);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSB_imm::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSB_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rs1 rs1_wb
    #define rd rd_wb


    rd = readValue;
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

std::string leon3_accat_trap::LDSB_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    return retVal;
}

bool leon3_accat_trap::LDSB_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSB_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::LDSB_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::LDSB_imm::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::LDSB_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSB_imm::lockRegs_regs(){

}

bool leon3_accat_trap::LDSB_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSB_imm::lockRegs_execute(){

}

bool leon3_accat_trap::LDSB_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSB_imm::lockRegs_memory(){

}

bool leon3_accat_trap::LDSB_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSB_imm::lockRegs_exception(){

}

bool leon3_accat_trap::LDSB_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSB_imm::lockRegs_wb(){

}

void leon3_accat_trap::LDSB_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::LDSB_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::LDSB_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::LDSB_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::LDSB_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::LDSB_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::LDSB_imm::replicate() const throw(){
    return new LDSB_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::LDSB_imm::getInstructionName() const throw(){
    return "LDSB_imm";
}

unsigned int leon3_accat_trap::LDSB_imm::getId() const throw(){
    return 0;
}

void leon3_accat_trap::LDSB_imm::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::LDSB_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "ldsb r";
    oss << this->rs1_bit;
    oss << "+";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::LDSB_imm::LDSB_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
}

leon3_accat_trap::LDSB_imm::~LDSB_imm(){

}
unsigned int leon3_accat_trap::WRITEpsr_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEpsr_imm::behavior_decode( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rs1 rs1_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEpsr_imm::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs


    // Note how we filter writes to EF and EC fields since we do not
    // have neither a co-processor nor the FPU
    result = ((rs1 ^ SignExtend(simm13, 13)) & 0x00FFCFFF) | 0xF3000000;
    supervisorException = (PSR[key_S] == 0);
    illegalCWP = (result & 0x0000001f) >= NUM_REG_WIN;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEpsr_imm::behavior_execute( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rs1 rs1_execute


    if(!(supervisorException || illegalCWP)){
        PSR = result;
    }
    unlockQueue[0].push_back(&PSR_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEpsr_imm::behavior_memory( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEpsr_imm::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rs1 rs1_exception


    if(supervisorException){
        RaiseException(pcounter, npcounter, PRIVILEDGE_INSTR);
    }
    if(illegalCWP){
        RaiseException(pcounter, npcounter, ILLEGAL_INSTR);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEpsr_imm::behavior_wb( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rs1 rs1_wb

    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::WRITEpsr_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    return retVal;
}

bool leon3_accat_trap::WRITEpsr_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEpsr_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::WRITEpsr_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::WRITEpsr_imm::lockRegs_decode(){
    this->PSR_pipe.lock();
}

bool leon3_accat_trap::WRITEpsr_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEpsr_imm::lockRegs_regs(){

}

bool leon3_accat_trap::WRITEpsr_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEpsr_imm::lockRegs_execute(){

}

bool leon3_accat_trap::WRITEpsr_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEpsr_imm::lockRegs_memory(){

}

bool leon3_accat_trap::WRITEpsr_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEpsr_imm::lockRegs_exception(){

}

bool leon3_accat_trap::WRITEpsr_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEpsr_imm::lockRegs_wb(){

}

void leon3_accat_trap::WRITEpsr_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
}

void leon3_accat_trap::WRITEpsr_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
}

void leon3_accat_trap::WRITEpsr_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
}

void leon3_accat_trap::WRITEpsr_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
}

void leon3_accat_trap::WRITEpsr_imm::getUnlock_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
}

void leon3_accat_trap::WRITEpsr_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
}

Instruction * leon3_accat_trap::WRITEpsr_imm::replicate() const throw(){
    return new WRITEpsr_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, \
        GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, \
        NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, \
        PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::WRITEpsr_imm::getInstructionName() const throw(){
    return "WRITEpsr_imm";
}

unsigned int leon3_accat_trap::WRITEpsr_imm::getId() const throw(){
    return 135;
}

void leon3_accat_trap::WRITEpsr_imm::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rd = (bitString & 0x3e000000) >> 25;
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::WRITEpsr_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "wr r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << " psr";
    return oss.str();
}

leon3_accat_trap::WRITEpsr_imm::WRITEpsr_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::WRITEpsr_imm::~WRITEpsr_imm(){

}
unsigned int leon3_accat_trap::READy::behavior_fetch( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::READy::behavior_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::READy::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs


    y_temp = Y;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::READy::behavior_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::READy::behavior_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::READy::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::READy::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb


    rd = y_temp;
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    return this->stageCycles;
}

std::string leon3_accat_trap::READy::printBusyRegs(){
    std::string retVal = "";
    if(this->Y_decode.isLocked()){
        retVal += "Y - ";
    }
    return retVal;
}

bool leon3_accat_trap::READy::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::READy::lockRegs_fetch(){

}

bool leon3_accat_trap::READy::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->Y_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::READy::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::READy::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::READy::lockRegs_regs(){

}

bool leon3_accat_trap::READy::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::READy::lockRegs_execute(){

}

bool leon3_accat_trap::READy::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::READy::lockRegs_memory(){

}

bool leon3_accat_trap::READy::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::READy::lockRegs_exception(){

}

bool leon3_accat_trap::READy::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::READy::lockRegs_wb(){

}

void leon3_accat_trap::READy::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::READy::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::READy::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::READy::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::READy::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::READy::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::READy::replicate() const throw(){
    return new READy(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::READy::getInstructionName() const throw(){
    return "READy";
}

unsigned int leon3_accat_trap::READy::getId() const throw(){
    return 125;
}

void leon3_accat_trap::READy::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
}

std::string leon3_accat_trap::READy::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "rd ";
    oss << "y";
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::READy::READy( PipelineRegister & PSR_pipe, PipelineRegister & WIM_pipe, \
    PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister & PC_pipe, \
    PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister * WINREGS_pipe, \
    PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, Reg32_2 & \
    TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, RegisterBankClass \
    & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias & FP_fetch, Alias \
    & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, Reg32_0 & PSR_decode, \
    Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, Reg32_3 & PC_decode, \
    Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 * WINREGS_decode, \
    Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias & SP_decode, Alias \
    & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 & WIM_regs, Reg32_2 \
    & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, RegisterBankClass \
    & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias & FP_regs, Alias \
    & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, Reg32_0 & PSR_execute, \
    Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, Reg32_3 & PC_execute, \
    Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, Reg32_3 * WINREGS_execute, \
    Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, Alias & SP_execute, \
    Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, Reg32_1 & WIM_memory, \
    Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, Reg32_3 & NPC_memory, \
    RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, Reg32_3 * ASR_memory, \
    Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias & PCR_memory, Alias \
    * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, Reg32_2 & TBR_exception, \
    Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & NPC_exception, RegisterBankClass \
    & GLOBAL_exception, Reg32_3 * WINREGS_exception, Reg32_3 * ASR_exception, Alias & \
    FP_exception, Alias & LR_exception, Alias & SP_exception, Alias & PCR_exception, \
    Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, Reg32_2 & TBR_wb, Reg32_3 \
    & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass & GLOBAL_wb, Reg32_3 \
    * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, Alias & SP_wb, Alias \
    & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & dataMem, PinTLM_out_32 \
    & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, \
    GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, \
    NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, \
    PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
    GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
    REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
    WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
    WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
    ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
    WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
    ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
    WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
    WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
    REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
    ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
}

leon3_accat_trap::READy::~READy(){

}
unsigned int leon3_accat_trap::XNORcc_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XNORcc_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XNORcc_reg::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    rs1_op = rs1;
    rs2_op = rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XNORcc_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    result = rs1_op ^ ~rs2_op;


    PSR[key_ICC_n] = ((result & 0x80000000) >> 31);
    PSR[key_ICC_z] = (result == 0);
    PSR[key_ICC_v] = 0;
    PSR[key_ICC_c] = 0;
    unlockQueue[0].push_back(&PSR_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XNORcc_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XNORcc_reg::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XNORcc_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::XNORcc_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::XNORcc_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XNORcc_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::XNORcc_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::XNORcc_reg::lockRegs_decode(){
    this->rd_decode.lock();
    this->PSR_pipe.lock();
}

bool leon3_accat_trap::XNORcc_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XNORcc_reg::lockRegs_regs(){

}

bool leon3_accat_trap::XNORcc_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XNORcc_reg::lockRegs_execute(){

}

bool leon3_accat_trap::XNORcc_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XNORcc_reg::lockRegs_memory(){

}

bool leon3_accat_trap::XNORcc_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XNORcc_reg::lockRegs_exception(){

}

bool leon3_accat_trap::XNORcc_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XNORcc_reg::lockRegs_wb(){

}

void leon3_accat_trap::XNORcc_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::XNORcc_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::XNORcc_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::XNORcc_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::XNORcc_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::XNORcc_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::XNORcc_reg::replicate() const throw(){
    return new XNORcc_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::XNORcc_reg::getInstructionName() const throw(){
    return "XNORcc_reg";
}

unsigned int leon3_accat_trap::XNORcc_reg::getId() const throw(){
    return 60;
}

void leon3_accat_trap::XNORcc_reg::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
}

std::string leon3_accat_trap::XNORcc_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "xnorcc r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::XNORcc_reg::XNORcc_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::XNORcc_reg::~XNORcc_reg(){

}
unsigned int leon3_accat_trap::READpsr::behavior_fetch( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::READpsr::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rd rd_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::READpsr::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs


    #ifdef ACC_MODEL
    psr_temp = PSR_execute;
    #else
    psr_temp = PSR;
    #endif
    supervisor = (psr_temp & 0x00000080) != 0;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::READpsr::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::READpsr::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::READpsr::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rd rd_exception


    if(!supervisor){
        RaiseException(pcounter, npcounter, PRIVILEDGE_INSTR);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::READpsr::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb


    rd = psr_temp;
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    return this->stageCycles;
}

std::string leon3_accat_trap::READpsr::printBusyRegs(){
    std::string retVal = "";
    return retVal;
}

bool leon3_accat_trap::READpsr::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::READpsr::lockRegs_fetch(){

}

bool leon3_accat_trap::READpsr::checkHazard_decode(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::READpsr::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::READpsr::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::READpsr::lockRegs_regs(){

}

bool leon3_accat_trap::READpsr::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::READpsr::lockRegs_execute(){

}

bool leon3_accat_trap::READpsr::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::READpsr::lockRegs_memory(){

}

bool leon3_accat_trap::READpsr::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::READpsr::lockRegs_exception(){

}

bool leon3_accat_trap::READpsr::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::READpsr::lockRegs_wb(){

}

void leon3_accat_trap::READpsr::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::READpsr::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::READpsr::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::READpsr::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::READpsr::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::READpsr::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::READpsr::replicate() const throw(){
    return new READpsr(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::READpsr::getInstructionName() const throw(){
    return "READpsr";
}

unsigned int leon3_accat_trap::READpsr::getId() const throw(){
    return 127;
}

void leon3_accat_trap::READpsr::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->asr = (bitString & 0x7c000) >> 14;
}

std::string leon3_accat_trap::READpsr::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "rd ";
    oss << "psr r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::READpsr::READpsr( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
}

leon3_accat_trap::READpsr::~READpsr(){

}
unsigned int leon3_accat_trap::ANDN_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ANDN_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ANDN_imm::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs


    rs1_op = rs1;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ANDN_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute


    result = rs1_op & ~(SignExtend(simm13, 13));

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ANDN_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ANDN_imm::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ANDN_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::ANDN_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    return retVal;
}

bool leon3_accat_trap::ANDN_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ANDN_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::ANDN_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::ANDN_imm::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::ANDN_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ANDN_imm::lockRegs_regs(){

}

bool leon3_accat_trap::ANDN_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ANDN_imm::lockRegs_execute(){

}

bool leon3_accat_trap::ANDN_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ANDN_imm::lockRegs_memory(){

}

bool leon3_accat_trap::ANDN_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ANDN_imm::lockRegs_exception(){

}

bool leon3_accat_trap::ANDN_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ANDN_imm::lockRegs_wb(){

}

void leon3_accat_trap::ANDN_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::ANDN_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::ANDN_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::ANDN_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::ANDN_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::ANDN_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::ANDN_imm::replicate() const throw(){
    return new ANDN_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::ANDN_imm::getInstructionName() const throw(){
    return "ANDN_imm";
}

unsigned int leon3_accat_trap::ANDN_imm::getId() const throw(){
    return 41;
}

void leon3_accat_trap::ANDN_imm::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::ANDN_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "andn r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::ANDN_imm::ANDN_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::ANDN_imm::~ANDN_imm(){

}
unsigned int leon3_accat_trap::ANDcc_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ANDcc_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ANDcc_reg::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    rs1_op = rs1;
    rs2_op = rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ANDcc_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    result = rs1_op & rs2_op;


    PSR[key_ICC_n] = ((result & 0x80000000) >> 31);
    PSR[key_ICC_z] = (result == 0);
    PSR[key_ICC_v] = 0;
    PSR[key_ICC_c] = 0;
    unlockQueue[0].push_back(&PSR_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ANDcc_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ANDcc_reg::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ANDcc_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::ANDcc_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::ANDcc_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ANDcc_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::ANDcc_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::ANDcc_reg::lockRegs_decode(){
    this->rd_decode.lock();
    this->PSR_pipe.lock();
}

bool leon3_accat_trap::ANDcc_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ANDcc_reg::lockRegs_regs(){

}

bool leon3_accat_trap::ANDcc_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ANDcc_reg::lockRegs_execute(){

}

bool leon3_accat_trap::ANDcc_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ANDcc_reg::lockRegs_memory(){

}

bool leon3_accat_trap::ANDcc_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ANDcc_reg::lockRegs_exception(){

}

bool leon3_accat_trap::ANDcc_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ANDcc_reg::lockRegs_wb(){

}

void leon3_accat_trap::ANDcc_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::ANDcc_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::ANDcc_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::ANDcc_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::ANDcc_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::ANDcc_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::ANDcc_reg::replicate() const throw(){
    return new ANDcc_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::ANDcc_reg::getInstructionName() const throw(){
    return "ANDcc_reg";
}

unsigned int leon3_accat_trap::ANDcc_reg::getId() const throw(){
    return 40;
}

void leon3_accat_trap::ANDcc_reg::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
}

std::string leon3_accat_trap::ANDcc_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "andcc r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::ANDcc_reg::ANDcc_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::ANDcc_reg::~ANDcc_reg(){

}
unsigned int leon3_accat_trap::TSUBcc_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TSUBcc_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TSUBcc_imm::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs


    rs1_op = rs1;
    rs2_op = SignExtend(simm13, 13);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TSUBcc_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute


    result = rs1_op - rs2_op;
    temp_V = ((unsigned int)((rs1_op & (~rs2_op) & (~result)) | ((~rs1_op) & rs2_op & \
        result))) >> 31;
    if(!temp_V && (((rs1_op | rs2_op) & 0x00000003) != 0)){
        temp_V = 1;
    }


    PSR[key_ICC_n] = ((result & 0x80000000) >> 31);
    PSR[key_ICC_z] = (result == 0);
    PSR[key_ICC_v] = temp_V;
    PSR[key_ICC_c] = ((unsigned int)(((~rs1_op) & rs2_op) | (((~rs1_op) | rs2_op) & result))) \
        >> 31;
    unlockQueue[0].push_back(&PSR_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TSUBcc_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TSUBcc_imm::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TSUBcc_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::TSUBcc_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    return retVal;
}

bool leon3_accat_trap::TSUBcc_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TSUBcc_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::TSUBcc_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::TSUBcc_imm::lockRegs_decode(){
    this->rd_decode.lock();
    this->PSR_pipe.lock();
}

bool leon3_accat_trap::TSUBcc_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TSUBcc_imm::lockRegs_regs(){

}

bool leon3_accat_trap::TSUBcc_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TSUBcc_imm::lockRegs_execute(){

}

bool leon3_accat_trap::TSUBcc_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TSUBcc_imm::lockRegs_memory(){

}

bool leon3_accat_trap::TSUBcc_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TSUBcc_imm::lockRegs_exception(){

}

bool leon3_accat_trap::TSUBcc_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TSUBcc_imm::lockRegs_wb(){

}

void leon3_accat_trap::TSUBcc_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::TSUBcc_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::TSUBcc_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::TSUBcc_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::TSUBcc_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::TSUBcc_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::TSUBcc_imm::replicate() const throw(){
    return new TSUBcc_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::TSUBcc_imm::getInstructionName() const throw(){
    return "TSUBcc_imm";
}

unsigned int leon3_accat_trap::TSUBcc_imm::getId() const throw(){
    return 87;
}

void leon3_accat_trap::TSUBcc_imm::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::TSUBcc_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "tsubcc r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::TSUBcc_imm::TSUBcc_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::TSUBcc_imm::~TSUBcc_imm(){

}
unsigned int leon3_accat_trap::LDSBA_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch
    #define rd rd_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSBA_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rs1 rs1_decode
    #define rs2 rs2_decode
    #define rd rd_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSBA_reg::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs
    #define rd rd_regs


    address = rs1 + rs2;
    supervisor = PSR[key_S];

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSBA_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute
    #define rd rd_execute


    #ifdef ACC_MODEL
    if(!supervisor){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSBA_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_memory
    #define WIM WIM_memory
    #define TBR TBR_memory
    #define Y Y_memory
    #define PC PC_memory
    #define NPC NPC_memory
    #define GLOBAL GLOBAL_memory
    #define WINREGS WINREGS_memory
    #define ASR ASR_memory
    #define FP FP_memory
    #define LR LR_memory
    #define SP SP_memory
    #define PCR PCR_memory
    #define REGS REGS_memory
    #define rs1 rs1_memory
    #define rs2 rs2_memory
    #define rd rd_memory


    #ifdef ACC_MODEL
    if(!supervisor){
        flush();
    }
    else{
        #endif
        readValue = SignExtend(dataMem.read_byte(address), 8);
        #ifdef ACC_MODEL
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSBA_reg::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rs1 rs1_exception
    #define rs2 rs2_exception
    #define rd rd_exception


    if(!supervisor){
        RaiseException(pcounter, npcounter, PRIVILEDGE_INSTR);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSBA_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb
    #define rd rd_wb


    rd = readValue;
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

std::string leon3_accat_trap::LDSBA_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::LDSBA_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSBA_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::LDSBA_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::LDSBA_reg::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::LDSBA_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSBA_reg::lockRegs_regs(){

}

bool leon3_accat_trap::LDSBA_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSBA_reg::lockRegs_execute(){

}

bool leon3_accat_trap::LDSBA_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSBA_reg::lockRegs_memory(){

}

bool leon3_accat_trap::LDSBA_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSBA_reg::lockRegs_exception(){

}

bool leon3_accat_trap::LDSBA_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSBA_reg::lockRegs_wb(){

}

void leon3_accat_trap::LDSBA_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::LDSBA_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::LDSBA_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::LDSBA_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::LDSBA_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::LDSBA_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::LDSBA_reg::replicate() const throw(){
    return new LDSBA_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::LDSBA_reg::getInstructionName() const throw(){
    return "LDSBA_reg";
}

unsigned int leon3_accat_trap::LDSBA_reg::getId() const throw(){
    return 12;
}

void leon3_accat_trap::LDSBA_reg::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->asi = (bitString & 0x1fe0) >> 5;
}

std::string leon3_accat_trap::LDSBA_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "ldba r";
    oss << this->rs1_bit;
    oss << "+r";
    oss << this->rs2_bit;
    oss << " ";
    oss << this->asi;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::LDSBA_reg::LDSBA_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
}

leon3_accat_trap::LDSBA_reg::~LDSBA_reg(){

}
unsigned int leon3_accat_trap::LDUH_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch
    #define rd rd_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDUH_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rs1 rs1_decode
    #define rd rd_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDUH_imm::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs
    #define rd rd_regs


    address = rs1 + SignExtend(simm13, 13);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDUH_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rs1 rs1_execute
    #define rd rd_execute


    notAligned = (address & 0x00000001) != 0;
    #ifdef ACC_MODEL
    if(notAligned){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDUH_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_memory
    #define WIM WIM_memory
    #define TBR TBR_memory
    #define Y Y_memory
    #define PC PC_memory
    #define NPC NPC_memory
    #define GLOBAL GLOBAL_memory
    #define WINREGS WINREGS_memory
    #define ASR ASR_memory
    #define FP FP_memory
    #define LR LR_memory
    #define SP SP_memory
    #define PCR PCR_memory
    #define REGS REGS_memory
    #define rs1 rs1_memory
    #define rd rd_memory


    readValue = dataMem.read_half(address);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDUH_imm::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rs1 rs1_exception
    #define rd rd_exception


    if(notAligned){
        RaiseException(pcounter, npcounter, MEM_ADDR_NOT_ALIGNED);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDUH_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rs1 rs1_wb
    #define rd rd_wb


    rd = readValue;
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

std::string leon3_accat_trap::LDUH_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    return retVal;
}

bool leon3_accat_trap::LDUH_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDUH_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::LDUH_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::LDUH_imm::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::LDUH_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDUH_imm::lockRegs_regs(){

}

bool leon3_accat_trap::LDUH_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDUH_imm::lockRegs_execute(){

}

bool leon3_accat_trap::LDUH_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDUH_imm::lockRegs_memory(){

}

bool leon3_accat_trap::LDUH_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDUH_imm::lockRegs_exception(){

}

bool leon3_accat_trap::LDUH_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDUH_imm::lockRegs_wb(){

}

void leon3_accat_trap::LDUH_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::LDUH_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::LDUH_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::LDUH_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::LDUH_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::LDUH_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::LDUH_imm::replicate() const throw(){
    return new LDUH_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::LDUH_imm::getInstructionName() const throw(){
    return "LDUH_imm";
}

unsigned int leon3_accat_trap::LDUH_imm::getId() const throw(){
    return 6;
}

void leon3_accat_trap::LDUH_imm::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::LDUH_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "lduh r";
    oss << this->rs1_bit;
    oss << "+";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::LDUH_imm::LDUH_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
}

leon3_accat_trap::LDUH_imm::~LDUH_imm(){

}
unsigned int leon3_accat_trap::STA_reg::behavior_fetch( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch
    #define rd rd_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STA_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rs1 rs1_decode
    #define rs2 rs2_decode
    #define rd rd_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STA_reg::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs
    #define rd rd_regs


    address = rs1 + rs2;
    toWrite = rd;
    supervisor = PSR[key_S];

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STA_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute
    #define rd rd_execute


    notAligned = (address & 0x00000003) != 0;
    #ifdef ACC_MODEL
    if(!supervisor || notAligned){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STA_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_memory
    #define WIM WIM_memory
    #define TBR TBR_memory
    #define Y Y_memory
    #define PC PC_memory
    #define NPC NPC_memory
    #define GLOBAL GLOBAL_memory
    #define WINREGS WINREGS_memory
    #define ASR ASR_memory
    #define FP FP_memory
    #define LR LR_memory
    #define SP SP_memory
    #define PCR PCR_memory
    #define REGS REGS_memory
    #define rs1 rs1_memory
    #define rs2 rs2_memory
    #define rd rd_memory


    if(supervisor || !notAligned){
        dataMem.write_word(address, toWrite);
    }
    else{
        flush();
    }
    stall(1);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STA_reg::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rs1 rs1_exception
    #define rs2 rs2_exception
    #define rd rd_exception


    if(!supervisor){
        RaiseException(pcounter, npcounter, PRIVILEDGE_INSTR);
    }
    if(notAligned){
        RaiseException(pcounter, npcounter, MEM_ADDR_NOT_ALIGNED);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STA_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

std::string leon3_accat_trap::STA_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    if(this->rd_decode.isLocked()){
        retVal += "rd - ";
    }
    return retVal;
}

bool leon3_accat_trap::STA_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STA_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::STA_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    regLocked = this->rd_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::STA_reg::lockRegs_decode(){

}

bool leon3_accat_trap::STA_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STA_reg::lockRegs_regs(){

}

bool leon3_accat_trap::STA_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STA_reg::lockRegs_execute(){

}

bool leon3_accat_trap::STA_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STA_reg::lockRegs_memory(){

}

bool leon3_accat_trap::STA_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STA_reg::lockRegs_exception(){

}

bool leon3_accat_trap::STA_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STA_reg::lockRegs_wb(){

}

void leon3_accat_trap::STA_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STA_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STA_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STA_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STA_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STA_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

Instruction * leon3_accat_trap::STA_reg::replicate() const throw(){
    return new STA_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::STA_reg::getInstructionName() const throw(){
    return "STA_reg";
}

unsigned int leon3_accat_trap::STA_reg::getId() const throw(){
    return 28;
}

void leon3_accat_trap::STA_reg::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->asi = (bitString & 0x1fe0) >> 5;
}

std::string leon3_accat_trap::STA_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "sta r";
    oss << this->rd_bit;
    oss << " r";
    oss << this->rs1_bit;
    oss << "+r";
    oss << this->rs2_bit;
    oss << " ";
    oss << this->asi;
    return oss.str();
}

leon3_accat_trap::STA_reg::STA_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
}

leon3_accat_trap::STA_reg::~STA_reg(){

}
unsigned int leon3_accat_trap::ORN_reg::behavior_fetch( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ORN_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ORN_reg::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    rs1_op = rs1;
    rs2_op = rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ORN_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    result = rs1_op | ~rs2_op;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ORN_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ORN_reg::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ORN_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::ORN_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::ORN_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ORN_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::ORN_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::ORN_reg::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::ORN_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ORN_reg::lockRegs_regs(){

}

bool leon3_accat_trap::ORN_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ORN_reg::lockRegs_execute(){

}

bool leon3_accat_trap::ORN_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ORN_reg::lockRegs_memory(){

}

bool leon3_accat_trap::ORN_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ORN_reg::lockRegs_exception(){

}

bool leon3_accat_trap::ORN_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ORN_reg::lockRegs_wb(){

}

void leon3_accat_trap::ORN_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::ORN_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::ORN_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::ORN_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::ORN_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::ORN_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::ORN_reg::replicate() const throw(){
    return new ORN_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::ORN_reg::getInstructionName() const throw(){
    return "ORN_reg";
}

unsigned int leon3_accat_trap::ORN_reg::getId() const throw(){
    return 50;
}

void leon3_accat_trap::ORN_reg::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
}

std::string leon3_accat_trap::ORN_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "orn r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::ORN_reg::ORN_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::ORN_reg::~ORN_reg(){

}
unsigned int leon3_accat_trap::LDSHA_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch
    #define rd rd_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSHA_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rs1 rs1_decode
    #define rs2 rs2_decode
    #define rd rd_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSHA_reg::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs
    #define rd rd_regs


    address = rs1 + rs2;
    supervisor = PSR[key_S];

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSHA_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute
    #define rd rd_execute


    notAligned = (address & 0x00000001) != 0;
    #ifdef ACC_MODEL
    if(notAligned || !supervisor){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSHA_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_memory
    #define WIM WIM_memory
    #define TBR TBR_memory
    #define Y Y_memory
    #define PC PC_memory
    #define NPC NPC_memory
    #define GLOBAL GLOBAL_memory
    #define WINREGS WINREGS_memory
    #define ASR ASR_memory
    #define FP FP_memory
    #define LR LR_memory
    #define SP SP_memory
    #define PCR PCR_memory
    #define REGS REGS_memory
    #define rs1 rs1_memory
    #define rs2 rs2_memory
    #define rd rd_memory


    #ifdef ACC_MODEL
    if(notAligned || !supervisor){
        flush();
    }
    else{
        #endif
        readValue = SignExtend(dataMem.read_half(address), 16);
        #ifdef ACC_MODEL
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSHA_reg::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rs1 rs1_exception
    #define rs2 rs2_exception
    #define rd rd_exception


    if(!supervisor){
        RaiseException(pcounter, npcounter, PRIVILEDGE_INSTR);
    }
    if(notAligned){
        RaiseException(pcounter, npcounter, MEM_ADDR_NOT_ALIGNED);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSHA_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb
    #define rd rd_wb


    rd = readValue;
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

std::string leon3_accat_trap::LDSHA_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::LDSHA_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSHA_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::LDSHA_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::LDSHA_reg::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::LDSHA_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSHA_reg::lockRegs_regs(){

}

bool leon3_accat_trap::LDSHA_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSHA_reg::lockRegs_execute(){

}

bool leon3_accat_trap::LDSHA_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSHA_reg::lockRegs_memory(){

}

bool leon3_accat_trap::LDSHA_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSHA_reg::lockRegs_exception(){

}

bool leon3_accat_trap::LDSHA_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSHA_reg::lockRegs_wb(){

}

void leon3_accat_trap::LDSHA_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::LDSHA_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::LDSHA_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::LDSHA_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::LDSHA_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::LDSHA_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::LDSHA_reg::replicate() const throw(){
    return new LDSHA_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::LDSHA_reg::getInstructionName() const throw(){
    return "LDSHA_reg";
}

unsigned int leon3_accat_trap::LDSHA_reg::getId() const throw(){
    return 13;
}

void leon3_accat_trap::LDSHA_reg::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->asi = (bitString & 0x1fe0) >> 5;
}

std::string leon3_accat_trap::LDSHA_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "ldsha r";
    oss << this->rs1_bit;
    oss << "+r";
    oss << this->rs2_bit;
    oss << " ";
    oss << this->asi;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::LDSHA_reg::LDSHA_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
}

leon3_accat_trap::LDSHA_reg::~LDSHA_reg(){

}
unsigned int leon3_accat_trap::STBA_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch
    #define rd rd_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STBA_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rs1 rs1_decode
    #define rs2 rs2_decode
    #define rd rd_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STBA_reg::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs
    #define rd rd_regs


    address = rs1 + rs2;
    toWrite = (unsigned char)(rd & 0x000000FF);
    supervisor = PSR[key_S];

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STBA_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute
    #define rd rd_execute


    #ifdef ACC_MODEL
    if(!supervisor){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STBA_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_memory
    #define WIM WIM_memory
    #define TBR TBR_memory
    #define Y Y_memory
    #define PC PC_memory
    #define NPC NPC_memory
    #define GLOBAL GLOBAL_memory
    #define WINREGS WINREGS_memory
    #define ASR ASR_memory
    #define FP FP_memory
    #define LR LR_memory
    #define SP SP_memory
    #define PCR PCR_memory
    #define REGS REGS_memory
    #define rs1 rs1_memory
    #define rs2 rs2_memory
    #define rd rd_memory


    if(supervisor){
        dataMem.write_byte(address, toWrite);
    }
    else{
        flush();
    }
    stall(1);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STBA_reg::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rs1 rs1_exception
    #define rs2 rs2_exception
    #define rd rd_exception


    if(!supervisor){
        RaiseException(pcounter, npcounter, PRIVILEDGE_INSTR);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STBA_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

std::string leon3_accat_trap::STBA_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    if(this->rd_decode.isLocked()){
        retVal += "rd - ";
    }
    return retVal;
}

bool leon3_accat_trap::STBA_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STBA_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::STBA_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    regLocked = this->rd_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::STBA_reg::lockRegs_decode(){

}

bool leon3_accat_trap::STBA_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STBA_reg::lockRegs_regs(){

}

bool leon3_accat_trap::STBA_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STBA_reg::lockRegs_execute(){

}

bool leon3_accat_trap::STBA_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STBA_reg::lockRegs_memory(){

}

bool leon3_accat_trap::STBA_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STBA_reg::lockRegs_exception(){

}

bool leon3_accat_trap::STBA_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STBA_reg::lockRegs_wb(){

}

void leon3_accat_trap::STBA_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STBA_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STBA_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STBA_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STBA_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STBA_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

Instruction * leon3_accat_trap::STBA_reg::replicate() const throw(){
    return new STBA_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::STBA_reg::getInstructionName() const throw(){
    return "STBA_reg";
}

unsigned int leon3_accat_trap::STBA_reg::getId() const throw(){
    return 26;
}

void leon3_accat_trap::STBA_reg::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->asi = (bitString & 0x1fe0) >> 5;
}

std::string leon3_accat_trap::STBA_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "stba r";
    oss << this->rd_bit;
    oss << " r";
    oss << this->rs1_bit;
    oss << "+r";
    oss << this->rs2_bit;
    oss << " ";
    oss << this->asi;
    return oss.str();
}

leon3_accat_trap::STBA_reg::STBA_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
}

leon3_accat_trap::STBA_reg::~STBA_reg(){

}
unsigned int leon3_accat_trap::ST_imm::behavior_fetch( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch
    #define rd rd_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ST_imm::behavior_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rs1 rs1_decode
    #define rd rd_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ST_imm::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs
    #define rd rd_regs


    address = rs1 + SignExtend(simm13, 13);
    toWrite = rd;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ST_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rs1 rs1_execute
    #define rd rd_execute


    notAligned = (address & 0x00000003) != 0;
    #ifdef ACC_MODEL
    if(notAligned){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ST_imm::behavior_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_memory
    #define WIM WIM_memory
    #define TBR TBR_memory
    #define Y Y_memory
    #define PC PC_memory
    #define NPC NPC_memory
    #define GLOBAL GLOBAL_memory
    #define WINREGS WINREGS_memory
    #define ASR ASR_memory
    #define FP FP_memory
    #define LR LR_memory
    #define SP SP_memory
    #define PCR PCR_memory
    #define REGS REGS_memory
    #define rs1 rs1_memory
    #define rd rd_memory


    if(!notAligned){
        dataMem.write_word(address, toWrite);
    }
    else{
        flush();
    }
    stall(1);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ST_imm::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rs1 rs1_exception
    #define rd rd_exception


    if(notAligned){
        RaiseException(pcounter, npcounter, MEM_ADDR_NOT_ALIGNED);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ST_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

std::string leon3_accat_trap::ST_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rd_decode.isLocked()){
        retVal += "rd - ";
    }
    return retVal;
}

bool leon3_accat_trap::ST_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ST_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::ST_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rd_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::ST_imm::lockRegs_decode(){

}

bool leon3_accat_trap::ST_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ST_imm::lockRegs_regs(){

}

bool leon3_accat_trap::ST_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ST_imm::lockRegs_execute(){

}

bool leon3_accat_trap::ST_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ST_imm::lockRegs_memory(){

}

bool leon3_accat_trap::ST_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ST_imm::lockRegs_exception(){

}

bool leon3_accat_trap::ST_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ST_imm::lockRegs_wb(){

}

void leon3_accat_trap::ST_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::ST_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::ST_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::ST_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::ST_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::ST_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

Instruction * leon3_accat_trap::ST_imm::replicate() const throw(){
    return new ST_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::ST_imm::getInstructionName() const throw(){
    return "ST_imm";
}

unsigned int leon3_accat_trap::ST_imm::getId() const throw(){
    return 22;
}

void leon3_accat_trap::ST_imm::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::ST_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "st r";
    oss << this->rd_bit;
    oss << " r";
    oss << this->rs1_bit;
    oss << "+";
    oss << this->simm13;
    return oss.str();
}

leon3_accat_trap::ST_imm::ST_imm( PipelineRegister & PSR_pipe, PipelineRegister & \
    WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
}

leon3_accat_trap::ST_imm::~ST_imm(){

}
unsigned int leon3_accat_trap::READtbr::behavior_fetch( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::READtbr::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rd rd_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::READtbr::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs


    tbr_temp = TBR;
    supervisor = PSR[key_S];

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::READtbr::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::READtbr::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::READtbr::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rd rd_exception


    if(!supervisor){
        RaiseException(pcounter, npcounter, PRIVILEDGE_INSTR);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::READtbr::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb


    rd = tbr_temp;
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    return this->stageCycles;
}

std::string leon3_accat_trap::READtbr::printBusyRegs(){
    std::string retVal = "";
    return retVal;
}

bool leon3_accat_trap::READtbr::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::READtbr::lockRegs_fetch(){

}

bool leon3_accat_trap::READtbr::checkHazard_decode(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::READtbr::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::READtbr::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::READtbr::lockRegs_regs(){

}

bool leon3_accat_trap::READtbr::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::READtbr::lockRegs_execute(){

}

bool leon3_accat_trap::READtbr::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::READtbr::lockRegs_memory(){

}

bool leon3_accat_trap::READtbr::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::READtbr::lockRegs_exception(){

}

bool leon3_accat_trap::READtbr::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::READtbr::lockRegs_wb(){

}

void leon3_accat_trap::READtbr::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::READtbr::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::READtbr::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::READtbr::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::READtbr::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::READtbr::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::READtbr::replicate() const throw(){
    return new READtbr(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::READtbr::getInstructionName() const throw(){
    return "READtbr";
}

unsigned int leon3_accat_trap::READtbr::getId() const throw(){
    return 129;
}

void leon3_accat_trap::READtbr::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->asr = (bitString & 0x7c000) >> 14;
}

std::string leon3_accat_trap::READtbr::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "rd ";
    oss << "tbr r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::READtbr::READtbr( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
}

leon3_accat_trap::READtbr::~READtbr(){

}
unsigned int leon3_accat_trap::UDIVcc_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UDIVcc_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rd rd_decode
    #define rs1 rs1_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UDIVcc_imm::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs


    rs1_op = rs1;
    rs2_op = SignExtend(simm13, 13);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UDIVcc_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute


    exception = rs2_op == 0;
    if(!exception){
        #ifndef ACC_MODEL
        unsigned long long res64 = ((unsigned long long)((((unsigned long long)Y) << 32) \
            | (unsigned long long)rs1_op))/(unsigned long long)rs2_op;
        #else
        unsigned long long res64 = ((unsigned long long)((((unsigned long long)Y_execute) \
            << 32) | (unsigned long long)rs1_op))/(unsigned long long)rs2_op;
        #endif
        temp_V = (res64 & 0xFFFFFFFF00000000LL) != 0;
        if(temp_V){
            result = 0xFFFFFFFF;
        }
        else{
            result = (unsigned int)(res64 & 0x00000000FFFFFFFFLL);
        }
    }
    stall(35);


    if(!exception){
        PSR[key_ICC_n] = ((result & 0x80000000) >> 31);
        PSR[key_ICC_z] = (result == 0);
        PSR[key_ICC_v] = temp_V;
        PSR[key_ICC_c] = 0;
    }
    unlockQueue[0].push_back(&PSR_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UDIVcc_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UDIVcc_imm::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rd rd_exception
    #define rs1 rs1_exception


    if(exception){
        RaiseException(pcounter, npcounter, DIV_ZERO);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UDIVcc_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[33].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::UDIVcc_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->Y_decode.isLocked()){
        retVal += "Y - ";
    }
    if(this->PSR_decode.isLocked()){
        retVal += "PSR - ";
    }
    return retVal;
}

bool leon3_accat_trap::UDIVcc_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UDIVcc_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::UDIVcc_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->Y_execute.isLocked() || regLocked;
    regLocked = this->PSR_execute.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::UDIVcc_imm::lockRegs_decode(){
    this->rd_decode.lock();
    this->PSR_pipe.lock();
}

bool leon3_accat_trap::UDIVcc_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UDIVcc_imm::lockRegs_regs(){

}

bool leon3_accat_trap::UDIVcc_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UDIVcc_imm::lockRegs_execute(){

}

bool leon3_accat_trap::UDIVcc_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UDIVcc_imm::lockRegs_memory(){

}

bool leon3_accat_trap::UDIVcc_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UDIVcc_imm::lockRegs_exception(){

}

bool leon3_accat_trap::UDIVcc_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UDIVcc_imm::lockRegs_wb(){

}

void leon3_accat_trap::UDIVcc_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::UDIVcc_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::UDIVcc_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::UDIVcc_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::UDIVcc_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::UDIVcc_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::UDIVcc_imm::replicate() const throw(){
    return new UDIVcc_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::UDIVcc_imm::getInstructionName() const throw(){
    return "UDIVcc_imm";
}

unsigned int leon3_accat_trap::UDIVcc_imm::getId() const throw(){
    return 109;
}

void leon3_accat_trap::UDIVcc_imm::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::UDIVcc_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "udivcc";
    oss << " r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::UDIVcc_imm::UDIVcc_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::UDIVcc_imm::~UDIVcc_imm(){

}
unsigned int leon3_accat_trap::SWAPA_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch
    #define rd rd_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SWAPA_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rs1 rs1_decode
    #define rs2 rs2_decode
    #define rd rd_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SWAPA_reg::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs
    #define rd rd_regs


    address = rs1 + rs2;
    toWrite = rd;
    supervisor = PSR[key_S];

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SWAPA_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute
    #define rd rd_execute


    notAligned = (address & 0x00000003) != 0;
    #ifdef ACC_MODEL
    if(!supervisor || notAligned){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SWAPA_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_memory
    #define WIM WIM_memory
    #define TBR TBR_memory
    #define Y Y_memory
    #define PC PC_memory
    #define NPC NPC_memory
    #define GLOBAL GLOBAL_memory
    #define WINREGS WINREGS_memory
    #define ASR ASR_memory
    #define FP FP_memory
    #define LR LR_memory
    #define SP SP_memory
    #define PCR PCR_memory
    #define REGS REGS_memory
    #define rs1 rs1_memory
    #define rs2 rs2_memory
    #define rd rd_memory


    if(!supervisor || notAligned){
        flush();
    }
    else{
        readValue = dataMem.read_word(address);
        dataMem.write_word(address, toWrite);
    }
    stall(2);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SWAPA_reg::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rs1 rs1_exception
    #define rs2 rs2_exception
    #define rd rd_exception


    if(!supervisor){
        RaiseException(pcounter, npcounter, PRIVILEDGE_INSTR);
    }
    if(notAligned){
        RaiseException(pcounter, npcounter, MEM_ADDR_NOT_ALIGNED);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SWAPA_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb
    #define rd rd_wb


    rd = readValue;
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

std::string leon3_accat_trap::SWAPA_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    if(this->rd_decode.isLocked()){
        retVal += "rd - ";
    }
    return retVal;
}

bool leon3_accat_trap::SWAPA_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SWAPA_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::SWAPA_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    regLocked = this->rd_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::SWAPA_reg::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::SWAPA_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SWAPA_reg::lockRegs_regs(){

}

bool leon3_accat_trap::SWAPA_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SWAPA_reg::lockRegs_execute(){

}

bool leon3_accat_trap::SWAPA_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SWAPA_reg::lockRegs_memory(){

}

bool leon3_accat_trap::SWAPA_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SWAPA_reg::lockRegs_exception(){

}

bool leon3_accat_trap::SWAPA_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SWAPA_reg::lockRegs_wb(){

}

void leon3_accat_trap::SWAPA_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::SWAPA_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::SWAPA_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::SWAPA_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::SWAPA_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::SWAPA_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::SWAPA_reg::replicate() const throw(){
    return new SWAPA_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::SWAPA_reg::getInstructionName() const throw(){
    return "SWAPA_reg";
}

unsigned int leon3_accat_trap::SWAPA_reg::getId() const throw(){
    return 35;
}

void leon3_accat_trap::SWAPA_reg::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->asi = (bitString & 0x1fe0) >> 5;
}

std::string leon3_accat_trap::SWAPA_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "swapa r";
    oss << this->rs1_bit;
    oss << "+r";
    oss << this->rs2_bit;
    oss << " ";
    oss << this->asi;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::SWAPA_reg::SWAPA_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
}

leon3_accat_trap::SWAPA_reg::~SWAPA_reg(){

}
unsigned int leon3_accat_trap::ADDXcc_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADDXcc_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADDXcc_imm::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs


    rs1_op = rs1;
    rs2_op = SignExtend(simm13, 13);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADDXcc_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute


    #ifndef ACC_MODEL
    result = rs1_op + rs2_op + PSR[key_ICC_c];
    #else
    //I read the register of the execute stage since this
    //is the one containing the bypass value
    result = rs1_op + rs2_op + PSR_execute[key_ICC_c];
    #endif


    PSR[key_ICC_n] = ((result & 0x80000000) >> 31);
    PSR[key_ICC_z] = (result == 0);
    PSR[key_ICC_v] = ((unsigned int)((rs1_op & rs2_op & (~result)) | ((~rs1_op) & (~rs2_op) \
        & result))) >> 31;
    PSR[key_ICC_c] = ((unsigned int)((rs1_op & rs2_op) | ((rs1_op | rs2_op) & (~result)))) \
        >> 31;
    unlockQueue[0].push_back(&PSR_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADDXcc_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADDXcc_imm::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADDXcc_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::ADDXcc_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->PSR_decode.isLocked()){
        retVal += "PSR - ";
    }
    return retVal;
}

bool leon3_accat_trap::ADDXcc_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADDXcc_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::ADDXcc_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->PSR_execute.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::ADDXcc_imm::lockRegs_decode(){
    this->rd_decode.lock();
    this->PSR_pipe.lock();
}

bool leon3_accat_trap::ADDXcc_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADDXcc_imm::lockRegs_regs(){

}

bool leon3_accat_trap::ADDXcc_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADDXcc_imm::lockRegs_execute(){

}

bool leon3_accat_trap::ADDXcc_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADDXcc_imm::lockRegs_memory(){

}

bool leon3_accat_trap::ADDXcc_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADDXcc_imm::lockRegs_exception(){

}

bool leon3_accat_trap::ADDXcc_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADDXcc_imm::lockRegs_wb(){

}

void leon3_accat_trap::ADDXcc_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::ADDXcc_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::ADDXcc_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::ADDXcc_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::ADDXcc_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::ADDXcc_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::ADDXcc_imm::replicate() const throw(){
    return new ADDXcc_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::ADDXcc_imm::getInstructionName() const throw(){
    return "ADDXcc_imm";
}

unsigned int leon3_accat_trap::ADDXcc_imm::getId() const throw(){
    return 73;
}

void leon3_accat_trap::ADDXcc_imm::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::ADDXcc_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "addxcc r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::ADDXcc_imm::ADDXcc_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::ADDXcc_imm::~ADDXcc_imm(){

}
unsigned int leon3_accat_trap::STB_imm::behavior_fetch( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch
    #define rd rd_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STB_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STB_imm::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs
    #define rd rd_regs


    address = rs1 + SignExtend(simm13, 13);
    toWrite = (unsigned char)(rd & 0x000000FF);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STB_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STB_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_memory
    #define WIM WIM_memory
    #define TBR TBR_memory
    #define Y Y_memory
    #define PC PC_memory
    #define NPC NPC_memory
    #define GLOBAL GLOBAL_memory
    #define WINREGS WINREGS_memory
    #define ASR ASR_memory
    #define FP FP_memory
    #define LR LR_memory
    #define SP SP_memory
    #define PCR PCR_memory
    #define REGS REGS_memory
    #define rs1 rs1_memory
    #define rd rd_memory


    dataMem.write_byte(address, toWrite);
    stall(1);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STB_imm::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STB_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

std::string leon3_accat_trap::STB_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rd_decode.isLocked()){
        retVal += "rd - ";
    }
    return retVal;
}

bool leon3_accat_trap::STB_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STB_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::STB_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rd_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::STB_imm::lockRegs_decode(){

}

bool leon3_accat_trap::STB_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STB_imm::lockRegs_regs(){

}

bool leon3_accat_trap::STB_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STB_imm::lockRegs_execute(){

}

bool leon3_accat_trap::STB_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STB_imm::lockRegs_memory(){

}

bool leon3_accat_trap::STB_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STB_imm::lockRegs_exception(){

}

bool leon3_accat_trap::STB_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STB_imm::lockRegs_wb(){

}

void leon3_accat_trap::STB_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STB_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STB_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STB_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STB_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STB_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

Instruction * leon3_accat_trap::STB_imm::replicate() const throw(){
    return new STB_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::STB_imm::getInstructionName() const throw(){
    return "STB_imm";
}

unsigned int leon3_accat_trap::STB_imm::getId() const throw(){
    return 18;
}

void leon3_accat_trap::STB_imm::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::STB_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "stb r";
    oss << this->rd_bit;
    oss << " r";
    oss << this->rs1_bit;
    oss << "+";
    oss << this->simm13;
    return oss.str();
}

leon3_accat_trap::STB_imm::STB_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
}

leon3_accat_trap::STB_imm::~STB_imm(){

}
unsigned int leon3_accat_trap::SUBXcc_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUBXcc_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUBXcc_imm::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs


    rs1_op = rs1;
    rs2_op = SignExtend(simm13, 13);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUBXcc_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute


    #ifndef ACC_MODEL
    result = rs1_op - rs2_op - PSR[key_ICC_c];
    #else
    result = rs1_op - rs2_op - PSR_execute[key_ICC_c];
    #endif


    PSR[key_ICC_n] = ((result & 0x80000000) >> 31);
    PSR[key_ICC_z] = (result == 0);
    PSR[key_ICC_v] = ((unsigned int)((rs1_op & (~rs2_op) & (~result)) | ((~rs1_op) & \
        rs2_op & result))) >> 31;
    PSR[key_ICC_c] = ((unsigned int)(((~rs1_op) & rs2_op) | (((~rs1_op) | rs2_op) & result))) \
        >> 31;
    unlockQueue[0].push_back(&PSR_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUBXcc_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUBXcc_imm::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUBXcc_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::SUBXcc_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->PSR_decode.isLocked()){
        retVal += "PSR - ";
    }
    return retVal;
}

bool leon3_accat_trap::SUBXcc_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUBXcc_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::SUBXcc_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->PSR_execute.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::SUBXcc_imm::lockRegs_decode(){
    this->rd_decode.lock();
    this->PSR_pipe.lock();
}

bool leon3_accat_trap::SUBXcc_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUBXcc_imm::lockRegs_regs(){

}

bool leon3_accat_trap::SUBXcc_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUBXcc_imm::lockRegs_execute(){

}

bool leon3_accat_trap::SUBXcc_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUBXcc_imm::lockRegs_memory(){

}

bool leon3_accat_trap::SUBXcc_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUBXcc_imm::lockRegs_exception(){

}

bool leon3_accat_trap::SUBXcc_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUBXcc_imm::lockRegs_wb(){

}

void leon3_accat_trap::SUBXcc_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::SUBXcc_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::SUBXcc_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::SUBXcc_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::SUBXcc_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::SUBXcc_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::SUBXcc_imm::replicate() const throw(){
    return new SUBXcc_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::SUBXcc_imm::getInstructionName() const throw(){
    return "SUBXcc_imm";
}

unsigned int leon3_accat_trap::SUBXcc_imm::getId() const throw(){
    return 85;
}

void leon3_accat_trap::SUBXcc_imm::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::SUBXcc_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "subxcc r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::SUBXcc_imm::SUBXcc_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::SUBXcc_imm::~SUBXcc_imm(){

}
unsigned int leon3_accat_trap::STH_reg::behavior_fetch( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch
    #define rd rd_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STH_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rs1 rs1_decode
    #define rs2 rs2_decode
    #define rd rd_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STH_reg::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs
    #define rd rd_regs


    address = rs1 + rs2;
    toWrite = (unsigned short int)(rd & 0x0000FFFF);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STH_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute
    #define rd rd_execute


    notAligned = (address & 0x00000001) != 0;
    #ifdef ACC_MODEL
    if(notAligned){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STH_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_memory
    #define WIM WIM_memory
    #define TBR TBR_memory
    #define Y Y_memory
    #define PC PC_memory
    #define NPC NPC_memory
    #define GLOBAL GLOBAL_memory
    #define WINREGS WINREGS_memory
    #define ASR ASR_memory
    #define FP FP_memory
    #define LR LR_memory
    #define SP SP_memory
    #define PCR PCR_memory
    #define REGS REGS_memory
    #define rs1 rs1_memory
    #define rs2 rs2_memory
    #define rd rd_memory


    if(!notAligned){
        dataMem.write_half(address, toWrite);
    }
    else{
        flush();
    }
    stall(1);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STH_reg::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rs1 rs1_exception
    #define rs2 rs2_exception
    #define rd rd_exception


    if(notAligned){
        RaiseException(pcounter, npcounter, MEM_ADDR_NOT_ALIGNED);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STH_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

std::string leon3_accat_trap::STH_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    if(this->rd_decode.isLocked()){
        retVal += "rd - ";
    }
    return retVal;
}

bool leon3_accat_trap::STH_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STH_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::STH_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    regLocked = this->rd_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::STH_reg::lockRegs_decode(){

}

bool leon3_accat_trap::STH_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STH_reg::lockRegs_regs(){

}

bool leon3_accat_trap::STH_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STH_reg::lockRegs_execute(){

}

bool leon3_accat_trap::STH_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STH_reg::lockRegs_memory(){

}

bool leon3_accat_trap::STH_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STH_reg::lockRegs_exception(){

}

bool leon3_accat_trap::STH_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STH_reg::lockRegs_wb(){

}

void leon3_accat_trap::STH_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STH_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STH_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STH_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STH_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STH_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

Instruction * leon3_accat_trap::STH_reg::replicate() const throw(){
    return new STH_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::STH_reg::getInstructionName() const throw(){
    return "STH_reg";
}

unsigned int leon3_accat_trap::STH_reg::getId() const throw(){
    return 21;
}

void leon3_accat_trap::STH_reg::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->asi = (bitString & 0x1fe0) >> 5;
}

std::string leon3_accat_trap::STH_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "sth r";
    oss << this->rd_bit;
    oss << " r";
    oss << this->rs1_bit;
    oss << "+r";
    oss << this->rs2_bit;
    return oss.str();
}

leon3_accat_trap::STH_reg::STH_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
}

leon3_accat_trap::STH_reg::~STH_reg(){

}
unsigned int leon3_accat_trap::SRL_imm::behavior_fetch( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SRL_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SRL_imm::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs


    rs1_op = rs1;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SRL_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute


    result = ((unsigned int)rs1_op) >> simm13;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SRL_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SRL_imm::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SRL_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::SRL_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    return retVal;
}

bool leon3_accat_trap::SRL_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SRL_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::SRL_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::SRL_imm::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::SRL_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SRL_imm::lockRegs_regs(){

}

bool leon3_accat_trap::SRL_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SRL_imm::lockRegs_execute(){

}

bool leon3_accat_trap::SRL_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SRL_imm::lockRegs_memory(){

}

bool leon3_accat_trap::SRL_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SRL_imm::lockRegs_exception(){

}

bool leon3_accat_trap::SRL_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SRL_imm::lockRegs_wb(){

}

void leon3_accat_trap::SRL_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::SRL_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::SRL_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::SRL_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::SRL_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::SRL_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::SRL_imm::replicate() const throw(){
    return new SRL_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::SRL_imm::getInstructionName() const throw(){
    return "SRL_imm";
}

unsigned int leon3_accat_trap::SRL_imm::getId() const throw(){
    return 63;
}

void leon3_accat_trap::SRL_imm::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::SRL_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "srl r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::SRL_imm::SRL_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::SRL_imm::~SRL_imm(){

}
unsigned int leon3_accat_trap::WRITEasr_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEasr_imm::behavior_decode( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEasr_imm::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs


    result = rs1 ^ SignExtend(simm13, 13);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEasr_imm::behavior_execute( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rs1 rs1_execute


    Y = result;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEasr_imm::behavior_memory( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEasr_imm::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEasr_imm::behavior_wb( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rs1 rs1_wb


    ASR[rd] = result;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::WRITEasr_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    return retVal;
}

bool leon3_accat_trap::WRITEasr_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEasr_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::WRITEasr_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::WRITEasr_imm::lockRegs_decode(){

}

bool leon3_accat_trap::WRITEasr_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEasr_imm::lockRegs_regs(){

}

bool leon3_accat_trap::WRITEasr_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEasr_imm::lockRegs_execute(){

}

bool leon3_accat_trap::WRITEasr_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEasr_imm::lockRegs_memory(){

}

bool leon3_accat_trap::WRITEasr_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEasr_imm::lockRegs_exception(){

}

bool leon3_accat_trap::WRITEasr_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEasr_imm::lockRegs_wb(){

}

void leon3_accat_trap::WRITEasr_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::WRITEasr_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::WRITEasr_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::WRITEasr_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::WRITEasr_imm::getUnlock_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){

}

void leon3_accat_trap::WRITEasr_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

Instruction * leon3_accat_trap::WRITEasr_imm::replicate() const throw(){
    return new WRITEasr_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, \
        GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, \
        NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, \
        PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::WRITEasr_imm::getInstructionName() const throw(){
    return "WRITEasr_imm";
}

unsigned int leon3_accat_trap::WRITEasr_imm::getId() const throw(){
    return 133;
}

void leon3_accat_trap::WRITEasr_imm::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rd = (bitString & 0x3e000000) >> 25;
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::WRITEasr_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "wr r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << " asr";
    oss << this->rd;
    return oss.str();
}

leon3_accat_trap::WRITEasr_imm::WRITEasr_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::WRITEasr_imm::~WRITEasr_imm(){

}
unsigned int leon3_accat_trap::UMULcc_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UMULcc_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UMULcc_reg::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    rs1_op = rs1;
    rs2_op = rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UMULcc_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    unsigned long long resultTemp = (unsigned long long)(((unsigned long long)((unsigned \
        int)rs1_op))*((unsigned long long)((unsigned int)rs2_op)));
    Y = resultTemp >> 32;
    result = resultTemp & 0x00000000FFFFFFFF;
    stall(2);


    PSR[key_ICC_n] = ((result & 0x80000000) >> 31);
    PSR[key_ICC_z] = (result == 0);
    PSR[key_ICC_v] = 0;
    PSR[key_ICC_c] = 0;
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&PSR_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UMULcc_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UMULcc_reg::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UMULcc_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[2].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::UMULcc_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::UMULcc_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UMULcc_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::UMULcc_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::UMULcc_reg::lockRegs_decode(){
    this->rd_decode.lock();
    this->Y_pipe.lock();
    this->PSR_pipe.lock();
}

bool leon3_accat_trap::UMULcc_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UMULcc_reg::lockRegs_regs(){

}

bool leon3_accat_trap::UMULcc_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UMULcc_reg::lockRegs_execute(){

}

bool leon3_accat_trap::UMULcc_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UMULcc_reg::lockRegs_memory(){

}

bool leon3_accat_trap::UMULcc_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UMULcc_reg::lockRegs_exception(){

}

bool leon3_accat_trap::UMULcc_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UMULcc_reg::lockRegs_wb(){

}

void leon3_accat_trap::UMULcc_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::UMULcc_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::UMULcc_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::UMULcc_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::UMULcc_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::UMULcc_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::UMULcc_reg::replicate() const throw(){
    return new UMULcc_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::UMULcc_reg::getInstructionName() const throw(){
    return "UMULcc_reg";
}

unsigned int leon3_accat_trap::UMULcc_reg::getId() const throw(){
    return 98;
}

void leon3_accat_trap::UMULcc_reg::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
}

std::string leon3_accat_trap::UMULcc_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "umulcc r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::UMULcc_reg::UMULcc_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::UMULcc_reg::~UMULcc_reg(){

}
unsigned int leon3_accat_trap::LDSTUB_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch
    #define rd rd_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSTUB_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSTUB_reg::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs
    #define rd rd_regs


    address = rs1 + rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSTUB_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSTUB_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_memory
    #define WIM WIM_memory
    #define TBR TBR_memory
    #define Y Y_memory
    #define PC PC_memory
    #define NPC NPC_memory
    #define GLOBAL GLOBAL_memory
    #define WINREGS WINREGS_memory
    #define ASR ASR_memory
    #define FP FP_memory
    #define LR LR_memory
    #define SP SP_memory
    #define PCR PCR_memory
    #define REGS REGS_memory
    #define rs1 rs1_memory
    #define rs2 rs2_memory
    #define rd rd_memory


    readValue = dataMem.read_byte(address);
    dataMem.write_byte(address, 0xff);
    stall(2);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSTUB_reg::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSTUB_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb
    #define rd rd_wb


    rd = readValue;
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

std::string leon3_accat_trap::LDSTUB_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::LDSTUB_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSTUB_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::LDSTUB_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::LDSTUB_reg::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::LDSTUB_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSTUB_reg::lockRegs_regs(){

}

bool leon3_accat_trap::LDSTUB_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSTUB_reg::lockRegs_execute(){

}

bool leon3_accat_trap::LDSTUB_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSTUB_reg::lockRegs_memory(){

}

bool leon3_accat_trap::LDSTUB_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSTUB_reg::lockRegs_exception(){

}

bool leon3_accat_trap::LDSTUB_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSTUB_reg::lockRegs_wb(){

}

void leon3_accat_trap::LDSTUB_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::LDSTUB_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::LDSTUB_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::LDSTUB_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::LDSTUB_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::LDSTUB_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::LDSTUB_reg::replicate() const throw(){
    return new LDSTUB_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::LDSTUB_reg::getInstructionName() const throw(){
    return "LDSTUB_reg";
}

unsigned int leon3_accat_trap::LDSTUB_reg::getId() const throw(){
    return 31;
}

void leon3_accat_trap::LDSTUB_reg::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->asi = (bitString & 0x1fe0) >> 5;
}

std::string leon3_accat_trap::LDSTUB_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "ldastub r";
    oss << this->rs1_bit;
    oss << "+r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::LDSTUB_reg::LDSTUB_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
}

leon3_accat_trap::LDSTUB_reg::~LDSTUB_reg(){

}
unsigned int leon3_accat_trap::XOR_imm::behavior_fetch( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XOR_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XOR_imm::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs


    rs1_op = rs1;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XOR_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute


    result = rs1_op ^ SignExtend(simm13, 13);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XOR_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XOR_imm::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XOR_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::XOR_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    return retVal;
}

bool leon3_accat_trap::XOR_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XOR_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::XOR_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::XOR_imm::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::XOR_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XOR_imm::lockRegs_regs(){

}

bool leon3_accat_trap::XOR_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XOR_imm::lockRegs_execute(){

}

bool leon3_accat_trap::XOR_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XOR_imm::lockRegs_memory(){

}

bool leon3_accat_trap::XOR_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XOR_imm::lockRegs_exception(){

}

bool leon3_accat_trap::XOR_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XOR_imm::lockRegs_wb(){

}

void leon3_accat_trap::XOR_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::XOR_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::XOR_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::XOR_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::XOR_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::XOR_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::XOR_imm::replicate() const throw(){
    return new XOR_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::XOR_imm::getInstructionName() const throw(){
    return "XOR_imm";
}

unsigned int leon3_accat_trap::XOR_imm::getId() const throw(){
    return 53;
}

void leon3_accat_trap::XOR_imm::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::XOR_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "xor r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::XOR_imm::XOR_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::XOR_imm::~XOR_imm(){

}
unsigned int leon3_accat_trap::SMAC_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SMAC_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SMAC_reg::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    rs1_op = rs1;
    rs2_op = rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SMAC_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    int resultTemp = ((int)SignExtend(rs1_op & 0x0000ffff, 16))*((int)SignExtend(rs2_op \
        & 0x0000ffff, 16));
    #ifndef ACC_MODEL
    long long resultAcc = ((((long long)(Y & 0x000000ff)) << 32) | (int)ASR[18]) + resultTemp;
    #else
    long long resultAcc = ((((long long)(Y_execute & 0x000000ff)) << 32) | (int)ASR_execute[18]) \
        + resultTemp;
    #endif
    Y = (resultAcc & 0x000000ff00000000LL) >> 32;
    ASR[18] = resultAcc & 0x00000000FFFFFFFFLL;
    result = resultAcc & 0x00000000FFFFFFFFLL;
    stall(1);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&ASR_execute[18]);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SMAC_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SMAC_reg::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SMAC_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&ASR_fetch[18]);
    unlockQueue[0].push_back(&ASR_decode[18]);
    unlockQueue[0].push_back(&ASR_regs[18]);
    unlockQueue[0].push_back(&ASR_memory[18]);
    unlockQueue[0].push_back(&ASR_exception[18]);
    unlockQueue[0].push_back(&ASR_wb[18]);
    unlockQueue[0].push_back(ASR_pipe[18].getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::SMAC_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    if(this->Y_decode.isLocked()){
        retVal += "Y - ";
    }
    if(this->ASR_decode[18].isLocked()){
        retVal += "ASR[18] - ";
    }
    return retVal;
}

bool leon3_accat_trap::SMAC_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SMAC_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::SMAC_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    regLocked = this->Y_execute.isLocked() || regLocked;
    regLocked = this->ASR_execute[18].isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::SMAC_reg::lockRegs_decode(){
    this->rd_decode.lock();
    this->Y_pipe.lock();
    this->ASR_pipe[18].lock();
}

bool leon3_accat_trap::SMAC_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SMAC_reg::lockRegs_regs(){

}

bool leon3_accat_trap::SMAC_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SMAC_reg::lockRegs_execute(){

}

bool leon3_accat_trap::SMAC_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SMAC_reg::lockRegs_memory(){

}

bool leon3_accat_trap::SMAC_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SMAC_reg::lockRegs_exception(){

}

bool leon3_accat_trap::SMAC_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SMAC_reg::lockRegs_wb(){

}

void leon3_accat_trap::SMAC_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&ASR_fetch[18]);
    unlockQueue[0].push_back(&ASR_decode[18]);
    unlockQueue[0].push_back(&ASR_regs[18]);
    unlockQueue[0].push_back(&ASR_execute[18]);
    unlockQueue[0].push_back(&ASR_memory[18]);
    unlockQueue[0].push_back(&ASR_exception[18]);
    unlockQueue[0].push_back(&ASR_wb[18]);
    unlockQueue[0].push_back(ASR_pipe[18].getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::SMAC_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&ASR_fetch[18]);
    unlockQueue[0].push_back(&ASR_decode[18]);
    unlockQueue[0].push_back(&ASR_regs[18]);
    unlockQueue[0].push_back(&ASR_execute[18]);
    unlockQueue[0].push_back(&ASR_memory[18]);
    unlockQueue[0].push_back(&ASR_exception[18]);
    unlockQueue[0].push_back(&ASR_wb[18]);
    unlockQueue[0].push_back(ASR_pipe[18].getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::SMAC_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&ASR_fetch[18]);
    unlockQueue[0].push_back(&ASR_decode[18]);
    unlockQueue[0].push_back(&ASR_regs[18]);
    unlockQueue[0].push_back(&ASR_execute[18]);
    unlockQueue[0].push_back(&ASR_memory[18]);
    unlockQueue[0].push_back(&ASR_exception[18]);
    unlockQueue[0].push_back(&ASR_wb[18]);
    unlockQueue[0].push_back(ASR_pipe[18].getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::SMAC_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&ASR_fetch[18]);
    unlockQueue[0].push_back(&ASR_decode[18]);
    unlockQueue[0].push_back(&ASR_regs[18]);
    unlockQueue[0].push_back(&ASR_memory[18]);
    unlockQueue[0].push_back(&ASR_exception[18]);
    unlockQueue[0].push_back(&ASR_wb[18]);
    unlockQueue[0].push_back(ASR_pipe[18].getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::SMAC_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&ASR_fetch[18]);
    unlockQueue[0].push_back(&ASR_decode[18]);
    unlockQueue[0].push_back(&ASR_regs[18]);
    unlockQueue[0].push_back(&ASR_memory[18]);
    unlockQueue[0].push_back(&ASR_exception[18]);
    unlockQueue[0].push_back(&ASR_wb[18]);
    unlockQueue[0].push_back(ASR_pipe[18].getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::SMAC_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&ASR_fetch[18]);
    unlockQueue[0].push_back(&ASR_decode[18]);
    unlockQueue[0].push_back(&ASR_regs[18]);
    unlockQueue[0].push_back(&ASR_memory[18]);
    unlockQueue[0].push_back(&ASR_exception[18]);
    unlockQueue[0].push_back(&ASR_wb[18]);
    unlockQueue[0].push_back(ASR_pipe[18].getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::SMAC_reg::replicate() const throw(){
    return new SMAC_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::SMAC_reg::getInstructionName() const throw(){
    return "SMAC_reg";
}

unsigned int leon3_accat_trap::SMAC_reg::getId() const throw(){
    return 104;
}

void leon3_accat_trap::SMAC_reg::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
}

std::string leon3_accat_trap::SMAC_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "smac r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::SMAC_reg::SMAC_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::SMAC_reg::~SMAC_reg(){

}
unsigned int leon3_accat_trap::WRITEasr_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEasr_reg::behavior_decode( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEasr_reg::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    result = rs1 ^ rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEasr_reg::behavior_execute( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    Y = result;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEasr_reg::behavior_memory( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEasr_reg::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEasr_reg::behavior_wb( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb


    ASR[rd] = result;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::WRITEasr_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::WRITEasr_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEasr_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::WRITEasr_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::WRITEasr_reg::lockRegs_decode(){

}

bool leon3_accat_trap::WRITEasr_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEasr_reg::lockRegs_regs(){

}

bool leon3_accat_trap::WRITEasr_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEasr_reg::lockRegs_execute(){

}

bool leon3_accat_trap::WRITEasr_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEasr_reg::lockRegs_memory(){

}

bool leon3_accat_trap::WRITEasr_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEasr_reg::lockRegs_exception(){

}

bool leon3_accat_trap::WRITEasr_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEasr_reg::lockRegs_wb(){

}

void leon3_accat_trap::WRITEasr_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::WRITEasr_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::WRITEasr_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::WRITEasr_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::WRITEasr_reg::getUnlock_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){

}

void leon3_accat_trap::WRITEasr_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

Instruction * leon3_accat_trap::WRITEasr_reg::replicate() const throw(){
    return new WRITEasr_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, \
        GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, \
        NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, \
        PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::WRITEasr_reg::getInstructionName() const throw(){
    return "WRITEasr_reg";
}

unsigned int leon3_accat_trap::WRITEasr_reg::getId() const throw(){
    return 132;
}

void leon3_accat_trap::WRITEasr_reg::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
    this->rd = (bitString & 0x3e000000) >> 25;
}

std::string leon3_accat_trap::WRITEasr_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "wr r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << " asr";
    oss << this->rd;
    return oss.str();
}

leon3_accat_trap::WRITEasr_reg::WRITEasr_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::WRITEasr_reg::~WRITEasr_reg(){

}
unsigned int leon3_accat_trap::LD_reg::behavior_fetch( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch
    #define rd rd_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LD_reg::behavior_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rs1 rs1_decode
    #define rs2 rs2_decode
    #define rd rd_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LD_reg::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs
    #define rd rd_regs


    address = rs1 + rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LD_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute
    #define rd rd_execute


    notAligned = (address & 0x00000003) != 0;
    #ifdef ACC_MODEL
    if(notAligned){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LD_reg::behavior_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_memory
    #define WIM WIM_memory
    #define TBR TBR_memory
    #define Y Y_memory
    #define PC PC_memory
    #define NPC NPC_memory
    #define GLOBAL GLOBAL_memory
    #define WINREGS WINREGS_memory
    #define ASR ASR_memory
    #define FP FP_memory
    #define LR LR_memory
    #define SP SP_memory
    #define PCR PCR_memory
    #define REGS REGS_memory
    #define rs1 rs1_memory
    #define rs2 rs2_memory
    #define rd rd_memory


    readValue = dataMem.read_word(address);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LD_reg::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rs1 rs1_exception
    #define rs2 rs2_exception
    #define rd rd_exception


    if(notAligned){
        RaiseException(pcounter, npcounter, MEM_ADDR_NOT_ALIGNED);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LD_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb
    #define rd rd_wb


    rd = readValue;
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

std::string leon3_accat_trap::LD_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::LD_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LD_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::LD_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::LD_reg::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::LD_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LD_reg::lockRegs_regs(){

}

bool leon3_accat_trap::LD_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LD_reg::lockRegs_execute(){

}

bool leon3_accat_trap::LD_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LD_reg::lockRegs_memory(){

}

bool leon3_accat_trap::LD_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LD_reg::lockRegs_exception(){

}

bool leon3_accat_trap::LD_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LD_reg::lockRegs_wb(){

}

void leon3_accat_trap::LD_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::LD_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::LD_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::LD_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::LD_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::LD_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::LD_reg::replicate() const throw(){
    return new LD_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::LD_reg::getInstructionName() const throw(){
    return "LD_reg";
}

unsigned int leon3_accat_trap::LD_reg::getId() const throw(){
    return 9;
}

void leon3_accat_trap::LD_reg::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->asi = (bitString & 0x1fe0) >> 5;
}

std::string leon3_accat_trap::LD_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "ld r";
    oss << this->rs1_bit;
    oss << "+r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::LD_reg::LD_reg( PipelineRegister & PSR_pipe, PipelineRegister & \
    WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
}

leon3_accat_trap::LD_reg::~LD_reg(){

}
unsigned int leon3_accat_trap::ST_reg::behavior_fetch( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch
    #define rd rd_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ST_reg::behavior_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rs1 rs1_decode
    #define rs2 rs2_decode
    #define rd rd_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ST_reg::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs
    #define rd rd_regs


    address = rs1 + rs2;
    toWrite = rd;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ST_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute
    #define rd rd_execute


    notAligned = (address & 0x00000003) != 0;
    #ifdef ACC_MODEL
    if(notAligned){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ST_reg::behavior_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_memory
    #define WIM WIM_memory
    #define TBR TBR_memory
    #define Y Y_memory
    #define PC PC_memory
    #define NPC NPC_memory
    #define GLOBAL GLOBAL_memory
    #define WINREGS WINREGS_memory
    #define ASR ASR_memory
    #define FP FP_memory
    #define LR LR_memory
    #define SP SP_memory
    #define PCR PCR_memory
    #define REGS REGS_memory
    #define rs1 rs1_memory
    #define rs2 rs2_memory
    #define rd rd_memory


    if(!notAligned){
        dataMem.write_word(address, toWrite);
    }
    else{
        flush();
    }
    stall(1);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ST_reg::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rs1 rs1_exception
    #define rs2 rs2_exception
    #define rd rd_exception


    if(notAligned){
        RaiseException(pcounter, npcounter, MEM_ADDR_NOT_ALIGNED);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ST_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

std::string leon3_accat_trap::ST_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    if(this->rd_decode.isLocked()){
        retVal += "rd - ";
    }
    return retVal;
}

bool leon3_accat_trap::ST_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ST_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::ST_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    regLocked = this->rd_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::ST_reg::lockRegs_decode(){

}

bool leon3_accat_trap::ST_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ST_reg::lockRegs_regs(){

}

bool leon3_accat_trap::ST_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ST_reg::lockRegs_execute(){

}

bool leon3_accat_trap::ST_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ST_reg::lockRegs_memory(){

}

bool leon3_accat_trap::ST_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ST_reg::lockRegs_exception(){

}

bool leon3_accat_trap::ST_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ST_reg::lockRegs_wb(){

}

void leon3_accat_trap::ST_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::ST_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::ST_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::ST_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::ST_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::ST_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

Instruction * leon3_accat_trap::ST_reg::replicate() const throw(){
    return new ST_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::ST_reg::getInstructionName() const throw(){
    return "ST_reg";
}

unsigned int leon3_accat_trap::ST_reg::getId() const throw(){
    return 23;
}

void leon3_accat_trap::ST_reg::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->asi = (bitString & 0x1fe0) >> 5;
}

std::string leon3_accat_trap::ST_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "st r";
    oss << this->rd_bit;
    oss << " r";
    oss << this->rs1_bit;
    oss << "+r";
    oss << this->rs2_bit;
    return oss.str();
}

leon3_accat_trap::ST_reg::ST_reg( PipelineRegister & PSR_pipe, PipelineRegister & \
    WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
}

leon3_accat_trap::ST_reg::~ST_reg(){

}
unsigned int leon3_accat_trap::SUBcc_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUBcc_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUBcc_reg::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    rs1_op = rs1;
    rs2_op = rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUBcc_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    result = rs1_op - rs2_op;


    PSR[key_ICC_n] = ((result & 0x80000000) >> 31);
    PSR[key_ICC_z] = (result == 0);
    PSR[key_ICC_v] = ((unsigned int)((rs1_op & (~rs2_op) & (~result)) | ((~rs1_op) & \
        rs2_op & result))) >> 31;
    PSR[key_ICC_c] = ((unsigned int)(((~rs1_op) & rs2_op) | (((~rs1_op) | rs2_op) & result))) \
        >> 31;
    unlockQueue[0].push_back(&PSR_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUBcc_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUBcc_reg::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUBcc_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::SUBcc_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::SUBcc_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUBcc_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::SUBcc_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::SUBcc_reg::lockRegs_decode(){
    this->rd_decode.lock();
    this->PSR_pipe.lock();
}

bool leon3_accat_trap::SUBcc_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUBcc_reg::lockRegs_regs(){

}

bool leon3_accat_trap::SUBcc_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUBcc_reg::lockRegs_execute(){

}

bool leon3_accat_trap::SUBcc_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUBcc_reg::lockRegs_memory(){

}

bool leon3_accat_trap::SUBcc_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUBcc_reg::lockRegs_exception(){

}

bool leon3_accat_trap::SUBcc_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUBcc_reg::lockRegs_wb(){

}

void leon3_accat_trap::SUBcc_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::SUBcc_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::SUBcc_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::SUBcc_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::SUBcc_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::SUBcc_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::SUBcc_reg::replicate() const throw(){
    return new SUBcc_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::SUBcc_reg::getInstructionName() const throw(){
    return "SUBcc_reg";
}

unsigned int leon3_accat_trap::SUBcc_reg::getId() const throw(){
    return 82;
}

void leon3_accat_trap::SUBcc_reg::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
}

std::string leon3_accat_trap::SUBcc_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "subcc r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::SUBcc_reg::SUBcc_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::SUBcc_reg::~SUBcc_reg(){

}
unsigned int leon3_accat_trap::LDD_reg::behavior_fetch( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch
    #define rd rd_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDD_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rs1 rs1_decode
    #define rs2 rs2_decode
    #define rd rd_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #ifdef ACC_MODEL
    REGS[rd_bit ^ 0x1].lock();
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDD_reg::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs
    #define rd rd_regs

    address = rs1 + rs2;
    notAligned = (address & 0x00000007) != 0;
    #ifdef ACC_MODEL
    if(notAligned){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDD_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute
    #define rd rd_execute

    #ifdef ACC_MODEL
    if(notAligned){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDD_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_memory
    #define WIM WIM_memory
    #define TBR TBR_memory
    #define Y Y_memory
    #define PC PC_memory
    #define NPC NPC_memory
    #define GLOBAL GLOBAL_memory
    #define WINREGS WINREGS_memory
    #define ASR ASR_memory
    #define FP FP_memory
    #define LR LR_memory
    #define SP SP_memory
    #define PCR PCR_memory
    #define REGS REGS_memory
    #define rs1 rs1_memory
    #define rs2 rs2_memory
    #define rd rd_memory


    if(!notAligned){
        readValue = dataMem.read_dword(address);
        stall(1);
    }
    #ifdef ACC_MODEL
    if(notAligned){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDD_reg::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rs1 rs1_exception
    #define rs2 rs2_exception
    #define rd rd_exception


    if(notAligned){
        RaiseException(pcounter, npcounter, MEM_ADDR_NOT_ALIGNED);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDD_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb
    #define rd rd_wb


    if(rd_bit % 2 == 0){
        rd = (unsigned int)(readValue & 0x00000000FFFFFFFFLL);
        REGS[rd_bit + 1] = (unsigned int)((readValue >> 32) & 0x00000000FFFFFFFFLL);
    }
    else{
        REGS[rd_bit - 1] = (unsigned int)(readValue & 0x00000000FFFFFFFFLL);
        rd = (unsigned int)((readValue >> 32) & 0x00000000FFFFFFFFLL);
    }
    #ifdef ACC_MODEL
    unlockQueue[0].push_back(REGS[rd_bit ^ 0x1].getPipeReg());
    #endif
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

std::string leon3_accat_trap::LDD_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::LDD_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDD_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::LDD_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::LDD_reg::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::LDD_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDD_reg::lockRegs_regs(){

}

bool leon3_accat_trap::LDD_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDD_reg::lockRegs_execute(){

}

bool leon3_accat_trap::LDD_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDD_reg::lockRegs_memory(){

}

bool leon3_accat_trap::LDD_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDD_reg::lockRegs_exception(){

}

bool leon3_accat_trap::LDD_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDD_reg::lockRegs_wb(){

}

void leon3_accat_trap::LDD_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::LDD_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::LDD_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::LDD_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::LDD_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::LDD_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::LDD_reg::replicate() const throw(){
    return new LDD_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::LDD_reg::getInstructionName() const throw(){
    return "LDD_reg";
}

unsigned int leon3_accat_trap::LDD_reg::getId() const throw(){
    return 11;
}

void leon3_accat_trap::LDD_reg::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->asi = (bitString & 0x1fe0) >> 5;
}

std::string leon3_accat_trap::LDD_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "ldd r";
    oss << this->rs1_bit;
    oss << "+r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::LDD_reg::LDD_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
}

leon3_accat_trap::LDD_reg::~LDD_reg(){

}
unsigned int leon3_accat_trap::ADDcc_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADDcc_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADDcc_imm::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs


    rs1_op = rs1;
    rs2_op = SignExtend(simm13, 13);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADDcc_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute


    result = rs1_op + rs2_op;


    PSR[key_ICC_n] = ((result & 0x80000000) >> 31);
    PSR[key_ICC_z] = (result == 0);
    PSR[key_ICC_v] = ((unsigned int)((rs1_op & rs2_op & (~result)) | ((~rs1_op) & (~rs2_op) \
        & result))) >> 31;
    PSR[key_ICC_c] = ((unsigned int)((rs1_op & rs2_op) | ((rs1_op | rs2_op) & (~result)))) \
        >> 31;
    unlockQueue[0].push_back(&PSR_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADDcc_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADDcc_imm::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADDcc_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::ADDcc_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    return retVal;
}

bool leon3_accat_trap::ADDcc_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADDcc_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::ADDcc_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::ADDcc_imm::lockRegs_decode(){
    this->rd_decode.lock();
    this->PSR_pipe.lock();
}

bool leon3_accat_trap::ADDcc_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADDcc_imm::lockRegs_regs(){

}

bool leon3_accat_trap::ADDcc_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADDcc_imm::lockRegs_execute(){

}

bool leon3_accat_trap::ADDcc_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADDcc_imm::lockRegs_memory(){

}

bool leon3_accat_trap::ADDcc_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADDcc_imm::lockRegs_exception(){

}

bool leon3_accat_trap::ADDcc_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADDcc_imm::lockRegs_wb(){

}

void leon3_accat_trap::ADDcc_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::ADDcc_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::ADDcc_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::ADDcc_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::ADDcc_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::ADDcc_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::ADDcc_imm::replicate() const throw(){
    return new ADDcc_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::ADDcc_imm::getInstructionName() const throw(){
    return "ADDcc_imm";
}

unsigned int leon3_accat_trap::ADDcc_imm::getId() const throw(){
    return 69;
}

void leon3_accat_trap::ADDcc_imm::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::ADDcc_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "addcc r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::ADDcc_imm::ADDcc_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::ADDcc_imm::~ADDcc_imm(){

}
unsigned int leon3_accat_trap::LDUH_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch
    #define rd rd_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDUH_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rs1 rs1_decode
    #define rs2 rs2_decode
    #define rd rd_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDUH_reg::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs
    #define rd rd_regs


    address = rs1 + rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDUH_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute
    #define rd rd_execute


    notAligned = (address & 0x00000001) != 0;
    #ifdef ACC_MODEL
    if(notAligned){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDUH_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_memory
    #define WIM WIM_memory
    #define TBR TBR_memory
    #define Y Y_memory
    #define PC PC_memory
    #define NPC NPC_memory
    #define GLOBAL GLOBAL_memory
    #define WINREGS WINREGS_memory
    #define ASR ASR_memory
    #define FP FP_memory
    #define LR LR_memory
    #define SP SP_memory
    #define PCR PCR_memory
    #define REGS REGS_memory
    #define rs1 rs1_memory
    #define rs2 rs2_memory
    #define rd rd_memory


    readValue = dataMem.read_half(address);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDUH_reg::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rs1 rs1_exception
    #define rs2 rs2_exception
    #define rd rd_exception


    if(notAligned){
        RaiseException(pcounter, npcounter, MEM_ADDR_NOT_ALIGNED);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDUH_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb
    #define rd rd_wb


    rd = readValue;
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

std::string leon3_accat_trap::LDUH_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::LDUH_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDUH_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::LDUH_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::LDUH_reg::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::LDUH_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDUH_reg::lockRegs_regs(){

}

bool leon3_accat_trap::LDUH_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDUH_reg::lockRegs_execute(){

}

bool leon3_accat_trap::LDUH_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDUH_reg::lockRegs_memory(){

}

bool leon3_accat_trap::LDUH_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDUH_reg::lockRegs_exception(){

}

bool leon3_accat_trap::LDUH_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDUH_reg::lockRegs_wb(){

}

void leon3_accat_trap::LDUH_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::LDUH_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::LDUH_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::LDUH_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::LDUH_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::LDUH_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::LDUH_reg::replicate() const throw(){
    return new LDUH_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::LDUH_reg::getInstructionName() const throw(){
    return "LDUH_reg";
}

unsigned int leon3_accat_trap::LDUH_reg::getId() const throw(){
    return 7;
}

void leon3_accat_trap::LDUH_reg::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->asi = (bitString & 0x1fe0) >> 5;
}

std::string leon3_accat_trap::LDUH_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "lduh r";
    oss << this->rs1_bit;
    oss << "+r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::LDUH_reg::LDUH_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
}

leon3_accat_trap::LDUH_reg::~LDUH_reg(){

}
unsigned int leon3_accat_trap::SRL_reg::behavior_fetch( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SRL_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SRL_reg::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    rs1_op = rs1;
    rs2_op = rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SRL_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    result = ((unsigned int)rs1_op) >> (rs2_op & 0x0000001f);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SRL_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SRL_reg::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SRL_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::SRL_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::SRL_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SRL_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::SRL_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::SRL_reg::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::SRL_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SRL_reg::lockRegs_regs(){

}

bool leon3_accat_trap::SRL_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SRL_reg::lockRegs_execute(){

}

bool leon3_accat_trap::SRL_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SRL_reg::lockRegs_memory(){

}

bool leon3_accat_trap::SRL_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SRL_reg::lockRegs_exception(){

}

bool leon3_accat_trap::SRL_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SRL_reg::lockRegs_wb(){

}

void leon3_accat_trap::SRL_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::SRL_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::SRL_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::SRL_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::SRL_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::SRL_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::SRL_reg::replicate() const throw(){
    return new SRL_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::SRL_reg::getInstructionName() const throw(){
    return "SRL_reg";
}

unsigned int leon3_accat_trap::SRL_reg::getId() const throw(){
    return 64;
}

void leon3_accat_trap::SRL_reg::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
}

std::string leon3_accat_trap::SRL_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "srl r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::SRL_reg::SRL_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::SRL_reg::~SRL_reg(){

}
unsigned int leon3_accat_trap::SAVE_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SAVE_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rd rd_decode
    #define rs1 rs1_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif
    result = rs1 + SignExtend(simm13, 13);

    okNewWin = DecrementRegWindow();
    #ifdef ACC_MODEL
    if(!okNewWin){
        flush();
    }
    else{
        rd.lock();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SAVE_imm::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs


    #ifdef ACC_MODEL
    if(!okNewWin){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SAVE_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute


    #ifdef ACC_MODEL
    if(!okNewWin){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SAVE_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_memory
    #define WIM WIM_memory
    #define TBR TBR_memory
    #define Y Y_memory
    #define PC PC_memory
    #define NPC NPC_memory
    #define GLOBAL GLOBAL_memory
    #define WINREGS WINREGS_memory
    #define ASR ASR_memory
    #define FP FP_memory
    #define LR LR_memory
    #define SP SP_memory
    #define PCR PCR_memory
    #define REGS REGS_memory
    #define rd rd_memory
    #define rs1 rs1_memory


    #ifdef ACC_MODEL
    if(!okNewWin){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SAVE_imm::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rd rd_exception
    #define rs1 rs1_exception


    if(!okNewWin){
        RaiseException(pcounter, npcounter, WINDOW_OVERFLOW);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SAVE_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb


    if(okNewWin){
        rd = result;
        #ifdef ACC_MODEL
        unlockQueue[0].push_back(rd.getPipeReg());
        #endif
    }
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::SAVE_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->PSR_decode.isLocked()){
        retVal += "PSR - ";
    }
    return retVal;
}

bool leon3_accat_trap::SAVE_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SAVE_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::SAVE_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->PSR_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::SAVE_imm::lockRegs_decode(){
    this->PSR_pipe.lock();
}

bool leon3_accat_trap::SAVE_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SAVE_imm::lockRegs_regs(){

}

bool leon3_accat_trap::SAVE_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SAVE_imm::lockRegs_execute(){

}

bool leon3_accat_trap::SAVE_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SAVE_imm::lockRegs_memory(){

}

bool leon3_accat_trap::SAVE_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SAVE_imm::lockRegs_exception(){

}

bool leon3_accat_trap::SAVE_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SAVE_imm::lockRegs_wb(){

}

void leon3_accat_trap::SAVE_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
}

void leon3_accat_trap::SAVE_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
}

void leon3_accat_trap::SAVE_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
}

void leon3_accat_trap::SAVE_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
}

void leon3_accat_trap::SAVE_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
}

void leon3_accat_trap::SAVE_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
}

Instruction * leon3_accat_trap::SAVE_imm::replicate() const throw(){
    return new SAVE_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::SAVE_imm::getInstructionName() const throw(){
    return "SAVE_imm";
}

unsigned int leon3_accat_trap::SAVE_imm::getId() const throw(){
    return 113;
}

void leon3_accat_trap::SAVE_imm::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::SAVE_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "save";
    oss << " r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::SAVE_imm::SAVE_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::SAVE_imm::~SAVE_imm(){

}
unsigned int leon3_accat_trap::MULScc_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::MULScc_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::MULScc_reg::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    rs1_op = rs1;
    rs2_op = rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::MULScc_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    #ifndef ACC_MODEL
    unsigned int yNew = (((unsigned int)Y) >> 1) | (rs1_op << 31);
    #else
    unsigned int yNew = (((unsigned int)Y_execute) >> 1) | (rs1_op << 31);
    #endif
    rs1_op = ((PSR[key_ICC_n] ^ PSR[key_ICC_v]) << 31) | (((unsigned int)rs1_op) >> 1);
    result = rs1_op;
    #ifndef ACC_MODEL
    unsigned int yOld = Y;
    #else
    unsigned int yOld = Y_execute;
    #endif
    if((yOld & 0x00000001) != 0){
        result += rs2_op;
    }
    else{
        rs2_op = 0;
    }
    Y = yNew;


    PSR[key_ICC_n] = ((result & 0x80000000) >> 31);
    PSR[key_ICC_z] = (result == 0);
    PSR[key_ICC_v] = ((unsigned int)((rs1_op & rs2_op & (~result)) | ((~rs1_op) & (~rs2_op) \
        & result))) >> 31;
    PSR[key_ICC_c] = ((unsigned int)((rs1_op & rs2_op) | ((rs1_op | rs2_op) & (~result)))) \
        >> 31;
    unlockQueue[0].push_back(&Y_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::MULScc_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::MULScc_reg::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::MULScc_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::MULScc_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    if(this->PSR_decode.isLocked()){
        retVal += "PSR - ";
    }
    if(this->Y_decode.isLocked()){
        retVal += "Y - ";
    }
    return retVal;
}

bool leon3_accat_trap::MULScc_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::MULScc_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::MULScc_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    regLocked = this->PSR_decode.isLocked() || regLocked;
    regLocked = this->Y_execute.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::MULScc_reg::lockRegs_decode(){
    this->rd_decode.lock();
    this->Y_pipe.lock();
}

bool leon3_accat_trap::MULScc_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::MULScc_reg::lockRegs_regs(){

}

bool leon3_accat_trap::MULScc_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::MULScc_reg::lockRegs_execute(){

}

bool leon3_accat_trap::MULScc_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::MULScc_reg::lockRegs_memory(){

}

bool leon3_accat_trap::MULScc_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::MULScc_reg::lockRegs_exception(){

}

bool leon3_accat_trap::MULScc_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::MULScc_reg::lockRegs_wb(){

}

void leon3_accat_trap::MULScc_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::MULScc_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::MULScc_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::MULScc_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::MULScc_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::MULScc_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::MULScc_reg::replicate() const throw(){
    return new MULScc_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::MULScc_reg::getInstructionName() const throw(){
    return "MULScc_reg";
}

unsigned int leon3_accat_trap::MULScc_reg::getId() const throw(){
    return 92;
}

void leon3_accat_trap::MULScc_reg::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
}

std::string leon3_accat_trap::MULScc_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "mulscc r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::MULScc_reg::MULScc_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::MULScc_reg::~MULScc_reg(){

}
unsigned int leon3_accat_trap::OR_imm::behavior_fetch( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::OR_imm::behavior_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::OR_imm::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs


    rs1_op = rs1;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::OR_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute


    result = rs1_op | SignExtend(simm13, 13);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::OR_imm::behavior_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::OR_imm::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::OR_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::OR_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    return retVal;
}

bool leon3_accat_trap::OR_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::OR_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::OR_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::OR_imm::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::OR_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::OR_imm::lockRegs_regs(){

}

bool leon3_accat_trap::OR_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::OR_imm::lockRegs_execute(){

}

bool leon3_accat_trap::OR_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::OR_imm::lockRegs_memory(){

}

bool leon3_accat_trap::OR_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::OR_imm::lockRegs_exception(){

}

bool leon3_accat_trap::OR_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::OR_imm::lockRegs_wb(){

}

void leon3_accat_trap::OR_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::OR_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::OR_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::OR_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::OR_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::OR_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::OR_imm::replicate() const throw(){
    return new OR_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::OR_imm::getInstructionName() const throw(){
    return "OR_imm";
}

unsigned int leon3_accat_trap::OR_imm::getId() const throw(){
    return 45;
}

void leon3_accat_trap::OR_imm::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::OR_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "or r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::OR_imm::OR_imm( PipelineRegister & PSR_pipe, PipelineRegister & \
    WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::OR_imm::~OR_imm(){

}
unsigned int leon3_accat_trap::STD_imm::behavior_fetch( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch
    #define rd rd_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STD_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rs1 rs1_decode
    #define rd rd_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STD_imm::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs
    #define rd rd_regs

    address = rs1 + SignExtend(simm13, 13);
    if(rd_bit % 2 == 0){
        toWrite = rd | (((unsigned long long)REGS[rd_bit + 1]) << 32);
    }
    else{
        toWrite = REGS[rd_bit - 1] | (((unsigned long long)rd) << 32);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STD_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rs1 rs1_execute
    #define rd rd_execute


    notAligned = (address & 0x00000007) != 0;
    #ifdef ACC_MODEL
    if(notAligned){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STD_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_memory
    #define WIM WIM_memory
    #define TBR TBR_memory
    #define Y Y_memory
    #define PC PC_memory
    #define NPC NPC_memory
    #define GLOBAL GLOBAL_memory
    #define WINREGS WINREGS_memory
    #define ASR ASR_memory
    #define FP FP_memory
    #define LR LR_memory
    #define SP SP_memory
    #define PCR PCR_memory
    #define REGS REGS_memory
    #define rs1 rs1_memory
    #define rd rd_memory


    if(!notAligned){
        dataMem.write_dword(address, toWrite);
    }
    else{
        flush();
    }
    stall(2);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STD_imm::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rs1 rs1_exception
    #define rd rd_exception


    if(notAligned){
        RaiseException(pcounter, npcounter, MEM_ADDR_NOT_ALIGNED);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STD_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

std::string leon3_accat_trap::STD_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rd_decode.isLocked()){
        retVal += "rd - ";
    }
    return retVal;
}

bool leon3_accat_trap::STD_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STD_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::STD_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rd_decode.isLocked() || regLocked;
    regLocked = REGS_decode[rd_bit ^ 0x1].isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::STD_imm::lockRegs_decode(){

}

bool leon3_accat_trap::STD_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STD_imm::lockRegs_regs(){

}

bool leon3_accat_trap::STD_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STD_imm::lockRegs_execute(){

}

bool leon3_accat_trap::STD_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STD_imm::lockRegs_memory(){

}

bool leon3_accat_trap::STD_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STD_imm::lockRegs_exception(){

}

bool leon3_accat_trap::STD_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STD_imm::lockRegs_wb(){

}

void leon3_accat_trap::STD_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STD_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STD_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STD_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STD_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STD_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

Instruction * leon3_accat_trap::STD_imm::replicate() const throw(){
    return new STD_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::STD_imm::getInstructionName() const throw(){
    return "STD_imm";
}

unsigned int leon3_accat_trap::STD_imm::getId() const throw(){
    return 24;
}

void leon3_accat_trap::STD_imm::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::STD_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "std r";
    oss << this->rd_bit;
    oss << " r";
    oss << this->rs1_bit;
    oss << "+";
    oss << this->simm13;
    return oss.str();
}

leon3_accat_trap::STD_imm::STD_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
}

leon3_accat_trap::STD_imm::~STD_imm(){

}
unsigned int leon3_accat_trap::SUBXcc_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUBXcc_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUBXcc_reg::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    rs1_op = rs1;
    rs2_op = rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUBXcc_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    #ifndef ACC_MODEL
    result = rs1_op - rs2_op - PSR[key_ICC_c];
    #else
    result = rs1_op - rs2_op - PSR_execute[key_ICC_c];
    #endif


    PSR[key_ICC_n] = ((result & 0x80000000) >> 31);
    PSR[key_ICC_z] = (result == 0);
    PSR[key_ICC_v] = ((unsigned int)((rs1_op & (~rs2_op) & (~result)) | ((~rs1_op) & \
        rs2_op & result))) >> 31;
    PSR[key_ICC_c] = ((unsigned int)(((~rs1_op) & rs2_op) | (((~rs1_op) | rs2_op) & result))) \
        >> 31;
    unlockQueue[0].push_back(&PSR_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUBXcc_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUBXcc_reg::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUBXcc_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::SUBXcc_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    if(this->PSR_decode.isLocked()){
        retVal += "PSR - ";
    }
    return retVal;
}

bool leon3_accat_trap::SUBXcc_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUBXcc_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::SUBXcc_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    regLocked = this->PSR_execute.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::SUBXcc_reg::lockRegs_decode(){
    this->rd_decode.lock();
    this->PSR_pipe.lock();
}

bool leon3_accat_trap::SUBXcc_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUBXcc_reg::lockRegs_regs(){

}

bool leon3_accat_trap::SUBXcc_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUBXcc_reg::lockRegs_execute(){

}

bool leon3_accat_trap::SUBXcc_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUBXcc_reg::lockRegs_memory(){

}

bool leon3_accat_trap::SUBXcc_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUBXcc_reg::lockRegs_exception(){

}

bool leon3_accat_trap::SUBXcc_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUBXcc_reg::lockRegs_wb(){

}

void leon3_accat_trap::SUBXcc_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::SUBXcc_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::SUBXcc_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::SUBXcc_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::SUBXcc_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::SUBXcc_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::SUBXcc_reg::replicate() const throw(){
    return new SUBXcc_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::SUBXcc_reg::getInstructionName() const throw(){
    return "SUBXcc_reg";
}

unsigned int leon3_accat_trap::SUBXcc_reg::getId() const throw(){
    return 86;
}

void leon3_accat_trap::SUBXcc_reg::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
}

std::string leon3_accat_trap::SUBXcc_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "subxcc r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::SUBXcc_reg::SUBXcc_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::SUBXcc_reg::~SUBXcc_reg(){

}
unsigned int leon3_accat_trap::ADDX_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADDX_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADDX_imm::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs


    rs1_op = rs1;
    rs2_op = SignExtend(simm13, 13);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADDX_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute


    #ifndef ACC_MODEL
    result = rs1_op + rs2_op + PSR[key_ICC_c];
    #else
    //I read the register of the execute stage since this
    //is the one containing the bypass value
    result = rs1_op + rs2_op + PSR_execute[key_ICC_c];
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADDX_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADDX_imm::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADDX_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::ADDX_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->PSR_decode.isLocked()){
        retVal += "PSR - ";
    }
    return retVal;
}

bool leon3_accat_trap::ADDX_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADDX_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::ADDX_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->PSR_execute.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::ADDX_imm::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::ADDX_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADDX_imm::lockRegs_regs(){

}

bool leon3_accat_trap::ADDX_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADDX_imm::lockRegs_execute(){

}

bool leon3_accat_trap::ADDX_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADDX_imm::lockRegs_memory(){

}

bool leon3_accat_trap::ADDX_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADDX_imm::lockRegs_exception(){

}

bool leon3_accat_trap::ADDX_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADDX_imm::lockRegs_wb(){

}

void leon3_accat_trap::ADDX_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::ADDX_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::ADDX_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::ADDX_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::ADDX_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::ADDX_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::ADDX_imm::replicate() const throw(){
    return new ADDX_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::ADDX_imm::getInstructionName() const throw(){
    return "ADDX_imm";
}

unsigned int leon3_accat_trap::ADDX_imm::getId() const throw(){
    return 71;
}

void leon3_accat_trap::ADDX_imm::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::ADDX_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "addx r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::ADDX_imm::ADDX_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::ADDX_imm::~ADDX_imm(){

}
unsigned int leon3_accat_trap::SWAP_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch
    #define rd rd_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SWAP_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rs1 rs1_decode
    #define rd rd_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SWAP_imm::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs
    #define rd rd_regs


    address = rs1 + SignExtend(simm13, 13);
    toWrite = rd;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SWAP_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rs1 rs1_execute
    #define rd rd_execute


    notAligned = (address & 0x00000003) != 0;
    #ifdef ACC_MODEL
    if(notAligned){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SWAP_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_memory
    #define WIM WIM_memory
    #define TBR TBR_memory
    #define Y Y_memory
    #define PC PC_memory
    #define NPC NPC_memory
    #define GLOBAL GLOBAL_memory
    #define WINREGS WINREGS_memory
    #define ASR ASR_memory
    #define FP FP_memory
    #define LR LR_memory
    #define SP SP_memory
    #define PCR PCR_memory
    #define REGS REGS_memory
    #define rs1 rs1_memory
    #define rd rd_memory


    if(notAligned){
        flush();
    }
    else{
        readValue = dataMem.read_word(address);
        dataMem.write_word(address, toWrite);
    }
    stall(2);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SWAP_imm::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rs1 rs1_exception
    #define rd rd_exception


    if(notAligned){
        RaiseException(pcounter, npcounter, MEM_ADDR_NOT_ALIGNED);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SWAP_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rs1 rs1_wb
    #define rd rd_wb


    rd = readValue;
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

std::string leon3_accat_trap::SWAP_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rd_decode.isLocked()){
        retVal += "rd - ";
    }
    return retVal;
}

bool leon3_accat_trap::SWAP_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SWAP_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::SWAP_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rd_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::SWAP_imm::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::SWAP_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SWAP_imm::lockRegs_regs(){

}

bool leon3_accat_trap::SWAP_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SWAP_imm::lockRegs_execute(){

}

bool leon3_accat_trap::SWAP_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SWAP_imm::lockRegs_memory(){

}

bool leon3_accat_trap::SWAP_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SWAP_imm::lockRegs_exception(){

}

bool leon3_accat_trap::SWAP_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SWAP_imm::lockRegs_wb(){

}

void leon3_accat_trap::SWAP_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::SWAP_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::SWAP_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::SWAP_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::SWAP_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::SWAP_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::SWAP_imm::replicate() const throw(){
    return new SWAP_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::SWAP_imm::getInstructionName() const throw(){
    return "SWAP_imm";
}

unsigned int leon3_accat_trap::SWAP_imm::getId() const throw(){
    return 33;
}

void leon3_accat_trap::SWAP_imm::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::SWAP_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "swap r";
    oss << this->rs1_bit;
    oss << "+";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::SWAP_imm::SWAP_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
}

leon3_accat_trap::SWAP_imm::~SWAP_imm(){

}
unsigned int leon3_accat_trap::UMUL_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UMUL_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UMUL_reg::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    rs1_op = rs1;
    rs2_op = rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UMUL_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    unsigned long long resultTemp = (unsigned long long)(((unsigned long long)((unsigned \
        int)rs1_op))*((unsigned long long)((unsigned int)rs2_op)));
    Y = resultTemp >> 32;
    result = resultTemp & 0x00000000FFFFFFFF;
    stall(2);
    unlockQueue[0].push_back(&Y_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UMUL_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UMUL_reg::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UMUL_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[2].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::UMUL_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::UMUL_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UMUL_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::UMUL_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::UMUL_reg::lockRegs_decode(){
    this->rd_decode.lock();
    this->Y_pipe.lock();
}

bool leon3_accat_trap::UMUL_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UMUL_reg::lockRegs_regs(){

}

bool leon3_accat_trap::UMUL_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UMUL_reg::lockRegs_execute(){

}

bool leon3_accat_trap::UMUL_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UMUL_reg::lockRegs_memory(){

}

bool leon3_accat_trap::UMUL_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UMUL_reg::lockRegs_exception(){

}

bool leon3_accat_trap::UMUL_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UMUL_reg::lockRegs_wb(){

}

void leon3_accat_trap::UMUL_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::UMUL_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::UMUL_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::UMUL_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::UMUL_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::UMUL_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::UMUL_reg::replicate() const throw(){
    return new UMUL_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::UMUL_reg::getInstructionName() const throw(){
    return "UMUL_reg";
}

unsigned int leon3_accat_trap::UMUL_reg::getId() const throw(){
    return 94;
}

void leon3_accat_trap::UMUL_reg::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
}

std::string leon3_accat_trap::UMUL_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "umul r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::UMUL_reg::UMUL_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::UMUL_reg::~UMUL_reg(){

}
unsigned int leon3_accat_trap::WRITEY_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEY_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEY_imm::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs


    result = rs1 ^ SignExtend(simm13, 13);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEY_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rs1 rs1_execute


    Y = result;
    unlockQueue[0].push_back(&Y_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEY_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEY_imm::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEY_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rs1 rs1_wb

    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::WRITEY_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    return retVal;
}

bool leon3_accat_trap::WRITEY_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEY_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::WRITEY_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::WRITEY_imm::lockRegs_decode(){
    this->Y_pipe.lock();
}

bool leon3_accat_trap::WRITEY_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEY_imm::lockRegs_regs(){

}

bool leon3_accat_trap::WRITEY_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEY_imm::lockRegs_execute(){

}

bool leon3_accat_trap::WRITEY_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEY_imm::lockRegs_memory(){

}

bool leon3_accat_trap::WRITEY_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEY_imm::lockRegs_exception(){

}

bool leon3_accat_trap::WRITEY_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEY_imm::lockRegs_wb(){

}

void leon3_accat_trap::WRITEY_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
}

void leon3_accat_trap::WRITEY_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
}

void leon3_accat_trap::WRITEY_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
}

void leon3_accat_trap::WRITEY_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
}

void leon3_accat_trap::WRITEY_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
}

void leon3_accat_trap::WRITEY_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
}

Instruction * leon3_accat_trap::WRITEY_imm::replicate() const throw(){
    return new WRITEY_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::WRITEY_imm::getInstructionName() const throw(){
    return "WRITEY_imm";
}

unsigned int leon3_accat_trap::WRITEY_imm::getId() const throw(){
    return 131;
}

void leon3_accat_trap::WRITEY_imm::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::WRITEY_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "wr r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << " y";
    return oss.str();
}

leon3_accat_trap::WRITEY_imm::WRITEY_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::WRITEY_imm::~WRITEY_imm(){

}
unsigned int leon3_accat_trap::AND_reg::behavior_fetch( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::AND_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::AND_reg::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    rs1_op = rs1;
    rs2_op = rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::AND_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    result = rs1_op & rs2_op;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::AND_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::AND_reg::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::AND_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::AND_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::AND_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::AND_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::AND_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::AND_reg::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::AND_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::AND_reg::lockRegs_regs(){

}

bool leon3_accat_trap::AND_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::AND_reg::lockRegs_execute(){

}

bool leon3_accat_trap::AND_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::AND_reg::lockRegs_memory(){

}

bool leon3_accat_trap::AND_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::AND_reg::lockRegs_exception(){

}

bool leon3_accat_trap::AND_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::AND_reg::lockRegs_wb(){

}

void leon3_accat_trap::AND_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::AND_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::AND_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::AND_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::AND_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::AND_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::AND_reg::replicate() const throw(){
    return new AND_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::AND_reg::getInstructionName() const throw(){
    return "AND_reg";
}

unsigned int leon3_accat_trap::AND_reg::getId() const throw(){
    return 38;
}

void leon3_accat_trap::AND_reg::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
}

std::string leon3_accat_trap::AND_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "and r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::AND_reg::AND_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::AND_reg::~AND_reg(){

}
unsigned int leon3_accat_trap::FLUSH_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::FLUSH_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::FLUSH_imm::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::FLUSH_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute



    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::FLUSH_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::FLUSH_imm::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::FLUSH_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

std::string leon3_accat_trap::FLUSH_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    return retVal;
}

bool leon3_accat_trap::FLUSH_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::FLUSH_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::FLUSH_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::FLUSH_imm::lockRegs_decode(){

}

bool leon3_accat_trap::FLUSH_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::FLUSH_imm::lockRegs_regs(){

}

bool leon3_accat_trap::FLUSH_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::FLUSH_imm::lockRegs_execute(){

}

bool leon3_accat_trap::FLUSH_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::FLUSH_imm::lockRegs_memory(){

}

bool leon3_accat_trap::FLUSH_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::FLUSH_imm::lockRegs_exception(){

}

bool leon3_accat_trap::FLUSH_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::FLUSH_imm::lockRegs_wb(){

}

void leon3_accat_trap::FLUSH_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::FLUSH_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::FLUSH_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::FLUSH_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::FLUSH_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::FLUSH_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

Instruction * leon3_accat_trap::FLUSH_imm::replicate() const throw(){
    return new FLUSH_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::FLUSH_imm::getInstructionName() const throw(){
    return "FLUSH_imm";
}

unsigned int leon3_accat_trap::FLUSH_imm::getId() const throw(){
    return 143;
}

void leon3_accat_trap::FLUSH_imm::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::FLUSH_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "flush r";
    oss << this->rs1_bit;
    oss << "+";
    oss << this->simm13;
    return oss.str();
}

leon3_accat_trap::FLUSH_imm::FLUSH_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::FLUSH_imm::~FLUSH_imm(){

}
unsigned int leon3_accat_trap::SRA_reg::behavior_fetch( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SRA_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SRA_reg::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    rs1_op = rs1;
    rs2_op = rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SRA_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    result = ((int)rs1_op) >> (rs2_op & 0x0000001f);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SRA_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SRA_reg::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SRA_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::SRA_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::SRA_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SRA_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::SRA_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::SRA_reg::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::SRA_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SRA_reg::lockRegs_regs(){

}

bool leon3_accat_trap::SRA_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SRA_reg::lockRegs_execute(){

}

bool leon3_accat_trap::SRA_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SRA_reg::lockRegs_memory(){

}

bool leon3_accat_trap::SRA_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SRA_reg::lockRegs_exception(){

}

bool leon3_accat_trap::SRA_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SRA_reg::lockRegs_wb(){

}

void leon3_accat_trap::SRA_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::SRA_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::SRA_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::SRA_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::SRA_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::SRA_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::SRA_reg::replicate() const throw(){
    return new SRA_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::SRA_reg::getInstructionName() const throw(){
    return "SRA_reg";
}

unsigned int leon3_accat_trap::SRA_reg::getId() const throw(){
    return 66;
}

void leon3_accat_trap::SRA_reg::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
}

std::string leon3_accat_trap::SRA_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "sra r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::SRA_reg::SRA_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::SRA_reg::~SRA_reg(){

}
unsigned int leon3_accat_trap::STH_imm::behavior_fetch( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch
    #define rd rd_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STH_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rs1 rs1_decode
    #define rd rd_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STH_imm::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs
    #define rd rd_regs


    address = rs1 + SignExtend(simm13, 13);
    toWrite = (unsigned short int)(rd & 0x0000FFFF);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STH_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rs1 rs1_execute
    #define rd rd_execute


    notAligned = (address & 0x00000001) != 0;
    #ifdef ACC_MODEL
    if(notAligned){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STH_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_memory
    #define WIM WIM_memory
    #define TBR TBR_memory
    #define Y Y_memory
    #define PC PC_memory
    #define NPC NPC_memory
    #define GLOBAL GLOBAL_memory
    #define WINREGS WINREGS_memory
    #define ASR ASR_memory
    #define FP FP_memory
    #define LR LR_memory
    #define SP SP_memory
    #define PCR PCR_memory
    #define REGS REGS_memory
    #define rs1 rs1_memory
    #define rd rd_memory


    if(!notAligned){
        dataMem.write_half(address, toWrite);
    }
    else{
        flush();
    }
    stall(1);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STH_imm::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rs1 rs1_exception
    #define rd rd_exception


    if(notAligned){
        RaiseException(pcounter, npcounter, MEM_ADDR_NOT_ALIGNED);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STH_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

std::string leon3_accat_trap::STH_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rd_decode.isLocked()){
        retVal += "rd - ";
    }
    return retVal;
}

bool leon3_accat_trap::STH_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STH_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::STH_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rd_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::STH_imm::lockRegs_decode(){

}

bool leon3_accat_trap::STH_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STH_imm::lockRegs_regs(){

}

bool leon3_accat_trap::STH_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STH_imm::lockRegs_execute(){

}

bool leon3_accat_trap::STH_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STH_imm::lockRegs_memory(){

}

bool leon3_accat_trap::STH_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STH_imm::lockRegs_exception(){

}

bool leon3_accat_trap::STH_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STH_imm::lockRegs_wb(){

}

void leon3_accat_trap::STH_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STH_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STH_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STH_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STH_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STH_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

Instruction * leon3_accat_trap::STH_imm::replicate() const throw(){
    return new STH_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::STH_imm::getInstructionName() const throw(){
    return "STH_imm";
}

unsigned int leon3_accat_trap::STH_imm::getId() const throw(){
    return 20;
}

void leon3_accat_trap::STH_imm::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::STH_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "sth r";
    oss << this->rd_bit;
    oss << " r";
    oss << this->rs1_bit;
    oss << "+";
    oss << this->simm13;
    return oss.str();
}

leon3_accat_trap::STH_imm::STH_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
}

leon3_accat_trap::STH_imm::~STH_imm(){

}
unsigned int leon3_accat_trap::WRITEwim_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEwim_imm::behavior_decode( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rs1 rs1_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEwim_imm::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs


    result = rs1 ^ SignExtend(simm13, 13);
    raiseException = (PSR[key_S] == 0);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEwim_imm::behavior_execute( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEwim_imm::behavior_memory( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEwim_imm::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rs1 rs1_exception


    if(raiseException){
        RaiseException(pcounter, npcounter, PRIVILEDGE_INSTR);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEwim_imm::behavior_wb( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rs1 rs1_wb


    if(!raiseException){
        WIM = result & ((unsigned int)0xFFFFFFFF >> (32 - NUM_REG_WIN));
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::WRITEwim_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    return retVal;
}

bool leon3_accat_trap::WRITEwim_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEwim_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::WRITEwim_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::WRITEwim_imm::lockRegs_decode(){

}

bool leon3_accat_trap::WRITEwim_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEwim_imm::lockRegs_regs(){

}

bool leon3_accat_trap::WRITEwim_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEwim_imm::lockRegs_execute(){

}

bool leon3_accat_trap::WRITEwim_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEwim_imm::lockRegs_memory(){

}

bool leon3_accat_trap::WRITEwim_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEwim_imm::lockRegs_exception(){

}

bool leon3_accat_trap::WRITEwim_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEwim_imm::lockRegs_wb(){

}

void leon3_accat_trap::WRITEwim_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::WRITEwim_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::WRITEwim_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::WRITEwim_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::WRITEwim_imm::getUnlock_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){

}

void leon3_accat_trap::WRITEwim_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

Instruction * leon3_accat_trap::WRITEwim_imm::replicate() const throw(){
    return new WRITEwim_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, \
        GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, \
        NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, \
        PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::WRITEwim_imm::getInstructionName() const throw(){
    return "WRITEwim_imm";
}

unsigned int leon3_accat_trap::WRITEwim_imm::getId() const throw(){
    return 137;
}

void leon3_accat_trap::WRITEwim_imm::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rd = (bitString & 0x3e000000) >> 25;
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::WRITEwim_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "wr r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << " wim";
    return oss.str();
}

leon3_accat_trap::WRITEwim_imm::WRITEwim_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::WRITEwim_imm::~WRITEwim_imm(){

}
unsigned int leon3_accat_trap::LDD_imm::behavior_fetch( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch
    #define rd rd_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDD_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rs1 rs1_decode
    #define rd rd_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #ifdef ACC_MODEL
    REGS[rd_bit ^ 0x1].lock();
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDD_imm::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs
    #define rd rd_regs

    address = rs1 + SignExtend(simm13, 13);
    notAligned = (address & 0x00000007) != 0;
    #ifdef ACC_MODEL
    if(notAligned){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDD_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rs1 rs1_execute
    #define rd rd_execute

    #ifdef ACC_MODEL
    if(notAligned){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDD_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_memory
    #define WIM WIM_memory
    #define TBR TBR_memory
    #define Y Y_memory
    #define PC PC_memory
    #define NPC NPC_memory
    #define GLOBAL GLOBAL_memory
    #define WINREGS WINREGS_memory
    #define ASR ASR_memory
    #define FP FP_memory
    #define LR LR_memory
    #define SP SP_memory
    #define PCR PCR_memory
    #define REGS REGS_memory
    #define rs1 rs1_memory
    #define rd rd_memory


    if(!notAligned){
        readValue = dataMem.read_dword(address);
        stall(1);
    }
    #ifdef ACC_MODEL
    if(notAligned){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDD_imm::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rs1 rs1_exception
    #define rd rd_exception


    if(notAligned){
        RaiseException(pcounter, npcounter, MEM_ADDR_NOT_ALIGNED);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDD_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rs1 rs1_wb
    #define rd rd_wb


    if(rd_bit % 2 == 0){
        rd = (unsigned int)(readValue & 0x00000000FFFFFFFFLL);
        REGS[rd_bit + 1] = (unsigned int)((readValue >> 32) & 0x00000000FFFFFFFFLL);
    }
    else{
        REGS[rd_bit - 1] = (unsigned int)(readValue & 0x00000000FFFFFFFFLL);
        rd = (unsigned int)((readValue >> 32) & 0x00000000FFFFFFFFLL);
    }
    #ifdef ACC_MODEL
    unlockQueue[0].push_back(REGS[rd_bit ^ 0x1].getPipeReg());
    #endif
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

std::string leon3_accat_trap::LDD_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    return retVal;
}

bool leon3_accat_trap::LDD_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDD_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::LDD_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::LDD_imm::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::LDD_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDD_imm::lockRegs_regs(){

}

bool leon3_accat_trap::LDD_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDD_imm::lockRegs_execute(){

}

bool leon3_accat_trap::LDD_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDD_imm::lockRegs_memory(){

}

bool leon3_accat_trap::LDD_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDD_imm::lockRegs_exception(){

}

bool leon3_accat_trap::LDD_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDD_imm::lockRegs_wb(){

}

void leon3_accat_trap::LDD_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::LDD_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::LDD_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::LDD_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::LDD_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::LDD_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::LDD_imm::replicate() const throw(){
    return new LDD_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::LDD_imm::getInstructionName() const throw(){
    return "LDD_imm";
}

unsigned int leon3_accat_trap::LDD_imm::getId() const throw(){
    return 10;
}

void leon3_accat_trap::LDD_imm::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::LDD_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "ldd r";
    oss << this->rs1_bit;
    oss << "+";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::LDD_imm::LDD_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
}

leon3_accat_trap::LDD_imm::~LDD_imm(){

}
unsigned int leon3_accat_trap::SLL_imm::behavior_fetch( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SLL_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SLL_imm::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs


    rs1_op = rs1;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SLL_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute


    result = rs1_op << simm13;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SLL_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SLL_imm::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SLL_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::SLL_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    return retVal;
}

bool leon3_accat_trap::SLL_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SLL_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::SLL_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::SLL_imm::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::SLL_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SLL_imm::lockRegs_regs(){

}

bool leon3_accat_trap::SLL_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SLL_imm::lockRegs_execute(){

}

bool leon3_accat_trap::SLL_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SLL_imm::lockRegs_memory(){

}

bool leon3_accat_trap::SLL_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SLL_imm::lockRegs_exception(){

}

bool leon3_accat_trap::SLL_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SLL_imm::lockRegs_wb(){

}

void leon3_accat_trap::SLL_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::SLL_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::SLL_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::SLL_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::SLL_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::SLL_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::SLL_imm::replicate() const throw(){
    return new SLL_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::SLL_imm::getInstructionName() const throw(){
    return "SLL_imm";
}

unsigned int leon3_accat_trap::SLL_imm::getId() const throw(){
    return 61;
}

void leon3_accat_trap::SLL_imm::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::SLL_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "sll r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::SLL_imm::SLL_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::SLL_imm::~SLL_imm(){

}
unsigned int leon3_accat_trap::LDUHA_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch
    #define rd rd_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDUHA_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rs1 rs1_decode
    #define rs2 rs2_decode
    #define rd rd_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDUHA_reg::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs
    #define rd rd_regs


    address = rs1 + rs2;
    supervisor = PSR[key_S];

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDUHA_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute
    #define rd rd_execute


    notAligned = (address & 0x00000001) != 0;
    #ifdef ACC_MODEL
    if(notAligned || !supervisor){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDUHA_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_memory
    #define WIM WIM_memory
    #define TBR TBR_memory
    #define Y Y_memory
    #define PC PC_memory
    #define NPC NPC_memory
    #define GLOBAL GLOBAL_memory
    #define WINREGS WINREGS_memory
    #define ASR ASR_memory
    #define FP FP_memory
    #define LR LR_memory
    #define SP SP_memory
    #define PCR PCR_memory
    #define REGS REGS_memory
    #define rs1 rs1_memory
    #define rs2 rs2_memory
    #define rd rd_memory


    #ifdef ACC_MODEL
    if(notAligned || !supervisor){
        flush();
    }
    else{
        #endif
        readValue = dataMem.read_half(address);
        #ifdef ACC_MODEL
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDUHA_reg::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rs1 rs1_exception
    #define rs2 rs2_exception
    #define rd rd_exception


    if(!supervisor){
        RaiseException(pcounter, npcounter, PRIVILEDGE_INSTR);
    }
    if(notAligned){
        RaiseException(pcounter, npcounter, MEM_ADDR_NOT_ALIGNED);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDUHA_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb
    #define rd rd_wb


    rd = readValue;
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

std::string leon3_accat_trap::LDUHA_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::LDUHA_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDUHA_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::LDUHA_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::LDUHA_reg::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::LDUHA_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDUHA_reg::lockRegs_regs(){

}

bool leon3_accat_trap::LDUHA_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDUHA_reg::lockRegs_execute(){

}

bool leon3_accat_trap::LDUHA_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDUHA_reg::lockRegs_memory(){

}

bool leon3_accat_trap::LDUHA_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDUHA_reg::lockRegs_exception(){

}

bool leon3_accat_trap::LDUHA_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDUHA_reg::lockRegs_wb(){

}

void leon3_accat_trap::LDUHA_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::LDUHA_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::LDUHA_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::LDUHA_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::LDUHA_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::LDUHA_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::LDUHA_reg::replicate() const throw(){
    return new LDUHA_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::LDUHA_reg::getInstructionName() const throw(){
    return "LDUHA_reg";
}

unsigned int leon3_accat_trap::LDUHA_reg::getId() const throw(){
    return 15;
}

void leon3_accat_trap::LDUHA_reg::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->asi = (bitString & 0x1fe0) >> 5;
}

std::string leon3_accat_trap::LDUHA_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "lduha r";
    oss << this->rs1_bit;
    oss << "+r";
    oss << this->rs2_bit;
    oss << " ";
    oss << this->asi;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::LDUHA_reg::LDUHA_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
}

leon3_accat_trap::LDUHA_reg::~LDUHA_reg(){

}
unsigned int leon3_accat_trap::TADDcc_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TADDcc_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TADDcc_reg::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    rs1_op = rs1;
    rs2_op = rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TADDcc_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    result = rs1_op + rs2_op;
    temp_V = ((unsigned int)((rs1_op & rs2_op & (~result)) | ((~rs1_op) & (~rs2_op) & \
        result))) >> 31;
    if(!temp_V && (((rs1_op | rs2_op) & 0x00000003) != 0)){
        temp_V = 1;
    }


    PSR[key_ICC_n] = ((result & 0x80000000) >> 31);
    PSR[key_ICC_z] = (result == 0);
    PSR[key_ICC_v] = temp_V;
    PSR[key_ICC_c] = ((unsigned int)((rs1_op & rs2_op) | ((rs1_op | rs2_op) & (~result)))) \
        >> 31;
    unlockQueue[0].push_back(&PSR_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TADDcc_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TADDcc_reg::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TADDcc_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::TADDcc_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::TADDcc_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TADDcc_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::TADDcc_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::TADDcc_reg::lockRegs_decode(){
    this->rd_decode.lock();
    this->PSR_pipe.lock();
}

bool leon3_accat_trap::TADDcc_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TADDcc_reg::lockRegs_regs(){

}

bool leon3_accat_trap::TADDcc_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TADDcc_reg::lockRegs_execute(){

}

bool leon3_accat_trap::TADDcc_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TADDcc_reg::lockRegs_memory(){

}

bool leon3_accat_trap::TADDcc_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TADDcc_reg::lockRegs_exception(){

}

bool leon3_accat_trap::TADDcc_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TADDcc_reg::lockRegs_wb(){

}

void leon3_accat_trap::TADDcc_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::TADDcc_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::TADDcc_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::TADDcc_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::TADDcc_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::TADDcc_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::TADDcc_reg::replicate() const throw(){
    return new TADDcc_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::TADDcc_reg::getInstructionName() const throw(){
    return "TADDcc_reg";
}

unsigned int leon3_accat_trap::TADDcc_reg::getId() const throw(){
    return 76;
}

void leon3_accat_trap::TADDcc_reg::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
}

std::string leon3_accat_trap::TADDcc_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "taddcc r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::TADDcc_reg::TADDcc_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::TADDcc_reg::~TADDcc_reg(){

}
unsigned int leon3_accat_trap::TADDcc_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TADDcc_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TADDcc_imm::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs


    rs1_op = rs1;
    rs2_op = SignExtend(simm13, 13);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TADDcc_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute


    result = rs1_op + rs2_op;
    temp_V = ((unsigned int)((rs1_op & rs2_op & (~result)) | ((~rs1_op) & (~rs2_op) & \
        result))) >> 31;
    if(!temp_V && (((rs1_op | rs2_op) & 0x00000003) != 0)){
        temp_V = 1;
    }


    PSR[key_ICC_n] = ((result & 0x80000000) >> 31);
    PSR[key_ICC_z] = (result == 0);
    PSR[key_ICC_v] = temp_V;
    PSR[key_ICC_c] = ((unsigned int)((rs1_op & rs2_op) | ((rs1_op | rs2_op) & (~result)))) \
        >> 31;
    unlockQueue[0].push_back(&PSR_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TADDcc_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TADDcc_imm::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TADDcc_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::TADDcc_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    return retVal;
}

bool leon3_accat_trap::TADDcc_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TADDcc_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::TADDcc_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::TADDcc_imm::lockRegs_decode(){
    this->rd_decode.lock();
    this->PSR_pipe.lock();
}

bool leon3_accat_trap::TADDcc_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TADDcc_imm::lockRegs_regs(){

}

bool leon3_accat_trap::TADDcc_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TADDcc_imm::lockRegs_execute(){

}

bool leon3_accat_trap::TADDcc_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TADDcc_imm::lockRegs_memory(){

}

bool leon3_accat_trap::TADDcc_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TADDcc_imm::lockRegs_exception(){

}

bool leon3_accat_trap::TADDcc_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TADDcc_imm::lockRegs_wb(){

}

void leon3_accat_trap::TADDcc_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::TADDcc_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::TADDcc_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::TADDcc_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::TADDcc_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::TADDcc_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::TADDcc_imm::replicate() const throw(){
    return new TADDcc_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::TADDcc_imm::getInstructionName() const throw(){
    return "TADDcc_imm";
}

unsigned int leon3_accat_trap::TADDcc_imm::getId() const throw(){
    return 75;
}

void leon3_accat_trap::TADDcc_imm::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::TADDcc_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "taddcc r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::TADDcc_imm::TADDcc_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::TADDcc_imm::~TADDcc_imm(){

}
unsigned int leon3_accat_trap::SDIV_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SDIV_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rd rd_decode
    #define rs1 rs1_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SDIV_imm::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs


    rs1_op = rs1;
    rs2_op = SignExtend(simm13, 13);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SDIV_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute


    exception = rs2_op == 0;
    if(!exception){
        #ifndef ACC_MODEL
        long long res64 = ((long long)((((unsigned long long)Y) << 32) | (unsigned long long)rs1_op))/((long \
            long)((int)rs2_op));
        #else
        long long res64 = ((long long)((((unsigned long long)Y_execute) << 32) | (unsigned \
            long long)rs1_op))/((long long)((int)rs2_op));
        #endif
        temp_V = (res64 & 0xFFFFFFFF80000000LL) != 0 && (res64 & 0xFFFFFFFF80000000LL) != \
            0xFFFFFFFF80000000LL;
        if(temp_V){
            if(res64 > 0){
                result = 0x7FFFFFFF;
            }
            else{
                result = 0x80000000;
            }
        }
        else{
            result = (unsigned int)(res64 & 0x00000000FFFFFFFFLL);
        }
    }
    stall(2);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SDIV_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SDIV_imm::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rd rd_exception
    #define rs1 rs1_exception


    if(exception){
        RaiseException(pcounter, npcounter, DIV_ZERO);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SDIV_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb

    {


        rd = result;
    }
    unlockQueue[33].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::SDIV_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->Y_decode.isLocked()){
        retVal += "Y - ";
    }
    return retVal;
}

bool leon3_accat_trap::SDIV_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SDIV_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::SDIV_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->Y_execute.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::SDIV_imm::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::SDIV_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SDIV_imm::lockRegs_regs(){

}

bool leon3_accat_trap::SDIV_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SDIV_imm::lockRegs_execute(){

}

bool leon3_accat_trap::SDIV_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SDIV_imm::lockRegs_memory(){

}

bool leon3_accat_trap::SDIV_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SDIV_imm::lockRegs_exception(){

}

bool leon3_accat_trap::SDIV_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SDIV_imm::lockRegs_wb(){

}

void leon3_accat_trap::SDIV_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::SDIV_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::SDIV_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::SDIV_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::SDIV_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::SDIV_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::SDIV_imm::replicate() const throw(){
    return new SDIV_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::SDIV_imm::getInstructionName() const throw(){
    return "SDIV_imm";
}

unsigned int leon3_accat_trap::SDIV_imm::getId() const throw(){
    return 107;
}

void leon3_accat_trap::SDIV_imm::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::SDIV_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "sdiv";
    oss << " r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::SDIV_imm::SDIV_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::SDIV_imm::~SDIV_imm(){

}
unsigned int leon3_accat_trap::TSUBccTV_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TSUBccTV_imm::behavior_decode( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rd rd_decode
    #define rs1 rs1_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TSUBccTV_imm::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs


    rs1_op = rs1;
    rs2_op = SignExtend(simm13, 13);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TSUBccTV_imm::behavior_execute( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute


    result = rs1_op - rs2_op;
    temp_V = ((unsigned int)((rs1_op & (~rs2_op) & (~result)) | ((~rs1_op) & rs2_op & \
        result))) >> 31;
    if(!temp_V && (((rs1_op | rs2_op) & 0x00000003) != 0)){
        temp_V = 1;
    }


    if(!temp_V){
        PSR[key_ICC_n] = ((result & 0x80000000) >> 31);
        PSR[key_ICC_z] = (result == 0);
        PSR[key_ICC_v] = temp_V;
        PSR[key_ICC_c] = ((unsigned int)(((~rs1_op) & rs2_op) | (((~rs1_op) | rs2_op) & result))) \
            >> 31;
    }
    unlockQueue[0].push_back(&PSR_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TSUBccTV_imm::behavior_memory( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TSUBccTV_imm::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rd rd_exception
    #define rs1 rs1_exception


    if(temp_V){
        RaiseException(pcounter, npcounter, TAG_OVERFLOW);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TSUBccTV_imm::behavior_wb( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb

    {


        if(!temp_V){
            rd = result;
        }
    }
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::TSUBccTV_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    return retVal;
}

bool leon3_accat_trap::TSUBccTV_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TSUBccTV_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::TSUBccTV_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::TSUBccTV_imm::lockRegs_decode(){
    this->rd_decode.lock();
    this->PSR_pipe.lock();
}

bool leon3_accat_trap::TSUBccTV_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TSUBccTV_imm::lockRegs_regs(){

}

bool leon3_accat_trap::TSUBccTV_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TSUBccTV_imm::lockRegs_execute(){

}

bool leon3_accat_trap::TSUBccTV_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TSUBccTV_imm::lockRegs_memory(){

}

bool leon3_accat_trap::TSUBccTV_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TSUBccTV_imm::lockRegs_exception(){

}

bool leon3_accat_trap::TSUBccTV_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TSUBccTV_imm::lockRegs_wb(){

}

void leon3_accat_trap::TSUBccTV_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::TSUBccTV_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::TSUBccTV_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::TSUBccTV_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::TSUBccTV_imm::getUnlock_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::TSUBccTV_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::TSUBccTV_imm::replicate() const throw(){
    return new TSUBccTV_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, \
        GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, \
        NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, \
        PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::TSUBccTV_imm::getInstructionName() const throw(){
    return "TSUBccTV_imm";
}

unsigned int leon3_accat_trap::TSUBccTV_imm::getId() const throw(){
    return 89;
}

void leon3_accat_trap::TSUBccTV_imm::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::TSUBccTV_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "tsubcctv r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::TSUBccTV_imm::TSUBccTV_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::TSUBccTV_imm::~TSUBccTV_imm(){

}
unsigned int leon3_accat_trap::FLUSH_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::FLUSH_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::FLUSH_reg::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::FLUSH_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute



    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::FLUSH_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::FLUSH_reg::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::FLUSH_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

std::string leon3_accat_trap::FLUSH_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::FLUSH_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::FLUSH_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::FLUSH_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::FLUSH_reg::lockRegs_decode(){

}

bool leon3_accat_trap::FLUSH_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::FLUSH_reg::lockRegs_regs(){

}

bool leon3_accat_trap::FLUSH_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::FLUSH_reg::lockRegs_execute(){

}

bool leon3_accat_trap::FLUSH_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::FLUSH_reg::lockRegs_memory(){

}

bool leon3_accat_trap::FLUSH_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::FLUSH_reg::lockRegs_exception(){

}

bool leon3_accat_trap::FLUSH_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::FLUSH_reg::lockRegs_wb(){

}

void leon3_accat_trap::FLUSH_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::FLUSH_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::FLUSH_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::FLUSH_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::FLUSH_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::FLUSH_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

Instruction * leon3_accat_trap::FLUSH_reg::replicate() const throw(){
    return new FLUSH_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::FLUSH_reg::getInstructionName() const throw(){
    return "FLUSH_reg";
}

unsigned int leon3_accat_trap::FLUSH_reg::getId() const throw(){
    return 142;
}

void leon3_accat_trap::FLUSH_reg::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
}

std::string leon3_accat_trap::FLUSH_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "flush r";
    oss << this->rs1_bit;
    oss << "+r";
    oss << this->rs2_bit;
    return oss.str();
}

leon3_accat_trap::FLUSH_reg::FLUSH_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::FLUSH_reg::~FLUSH_reg(){

}
unsigned int leon3_accat_trap::ORNcc_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ORNcc_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ORNcc_reg::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    rs1_op = rs1;
    rs2_op = rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ORNcc_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    result = rs1_op | ~rs2_op;


    PSR[key_ICC_n] = ((result & 0x80000000) >> 31);
    PSR[key_ICC_z] = (result == 0);
    PSR[key_ICC_v] = 0;
    PSR[key_ICC_c] = 0;
    unlockQueue[0].push_back(&PSR_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ORNcc_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ORNcc_reg::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ORNcc_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::ORNcc_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::ORNcc_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ORNcc_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::ORNcc_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::ORNcc_reg::lockRegs_decode(){
    this->rd_decode.lock();
    this->PSR_pipe.lock();
}

bool leon3_accat_trap::ORNcc_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ORNcc_reg::lockRegs_regs(){

}

bool leon3_accat_trap::ORNcc_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ORNcc_reg::lockRegs_execute(){

}

bool leon3_accat_trap::ORNcc_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ORNcc_reg::lockRegs_memory(){

}

bool leon3_accat_trap::ORNcc_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ORNcc_reg::lockRegs_exception(){

}

bool leon3_accat_trap::ORNcc_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ORNcc_reg::lockRegs_wb(){

}

void leon3_accat_trap::ORNcc_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::ORNcc_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::ORNcc_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::ORNcc_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::ORNcc_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::ORNcc_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::ORNcc_reg::replicate() const throw(){
    return new ORNcc_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::ORNcc_reg::getInstructionName() const throw(){
    return "ORNcc_reg";
}

unsigned int leon3_accat_trap::ORNcc_reg::getId() const throw(){
    return 52;
}

void leon3_accat_trap::ORNcc_reg::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
}

std::string leon3_accat_trap::ORNcc_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "orncc r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::ORNcc_reg::ORNcc_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::ORNcc_reg::~ORNcc_reg(){

}
unsigned int leon3_accat_trap::RETT_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::RETT_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rd rd_decode
    #define rs1 rs1_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif
    targetAddr = rs1 + SignExtend(simm13, 13);
    newCwp = ((unsigned int)(PSR[key_CWP] + 1)) % NUM_REG_WIN;
    exceptionEnabled = PSR[key_ET];
    supervisor = PSR[key_S];
    invalidWin = ((0x01 << (newCwp)) & WIM) != 0;
    notAligned = (targetAddr & 0x00000003) != 0;
    if(!exceptionEnabled && supervisor && !invalidWin && !notAligned){
        #ifdef ACC_MODEL
        PC = targetAddr;
        NPC = targetAddr + 4;
        #else
        PC = npcounter;
        NPC = targetAddr;
        #endif
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::RETT_imm::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs


    #ifdef ACC_MODEL
    if(exceptionEnabled || !supervisor || invalidWin || notAligned){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::RETT_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute


    if(exceptionEnabled || !supervisor || invalidWin || notAligned){
        flush();
    }
    else{
        PSR.immediateWrite((PSR & 0xFFFFFF40) | (newCwp | 0x20 | (PSR[key_PS] << 7)));
        stall(2);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::RETT_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_memory
    #define WIM WIM_memory
    #define TBR TBR_memory
    #define Y Y_memory
    #define PC PC_memory
    #define NPC NPC_memory
    #define GLOBAL GLOBAL_memory
    #define WINREGS WINREGS_memory
    #define ASR ASR_memory
    #define FP FP_memory
    #define LR LR_memory
    #define SP SP_memory
    #define PCR PCR_memory
    #define REGS REGS_memory
    #define rd rd_memory
    #define rs1 rs1_memory


    #ifdef ACC_MODEL
    if(exceptionEnabled || !supervisor || invalidWin || notAligned){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::RETT_imm::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rd rd_exception
    #define rs1 rs1_exception


    if(exceptionEnabled){
        if(supervisor){
            RaiseException(pcounter, npcounter, ILLEGAL_INSTR);
        }
        else{
            RaiseException(pcounter, npcounter, PRIVILEDGE_INSTR);
        }
    }
    else if(!supervisor || invalidWin || notAligned){
        THROW_EXCEPTION("Invalid processor mode during execution of the RETT instruction \
            - supervisor: " << supervisor << " newCwp: " << std::hex << std::showbase << newCwp \
            << " targetAddr: " << std::hex << std::showbase << targetAddr);
    }
    else{
        #ifndef ACC_MODEL
        //Functional model: we simply immediately update the alias
        for(int i = 8; i < 32; i++){
            REGS[i].updateAlias(WINREGS[(newCwp*16 + i - 8) & 0x7f]);
        }
        #else
        //Cycle accurate model: we have to update the alias using the pipeline register
        //We update the aliases for this stage and for all the preceding ones (we are in the
        //execute stage and we need to update fetch, decode, and register read and execute)
        for(int i = 8; i < 32; i++){
            REGS_fetch[i].updateAlias(WINREGS_pipe[(newCwp*16 + i - 8) & 0x7f]);
            REGS_decode[i].updateAlias(WINREGS_pipe[(newCwp*16 + i - 8) & 0x7f]);
            REGS_regs[i].updateAlias(WINREGS_pipe[(newCwp*16 + i - 8) & 0x7f]);
            REGS_execute[i].updateAlias(WINREGS_pipe[(newCwp*16 + i - 8) & 0x7f]);
            REGS_memory[i].updateAlias(WINREGS_pipe[(newCwp*16 + i - 8) & 0x7f]);
            REGS_exception[i].updateAlias(WINREGS_pipe[(newCwp*16 + i - 8) & 0x7f]);
        }
        #endif

    }
    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::RETT_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb


    #ifdef ACC_MODEL
    if(exceptionEnabled || !supervisor || invalidWin || notAligned){
        flush();
    }
    #endif
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::RETT_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->PSR_decode.isLocked()){
        retVal += "PSR - ";
    }
    return retVal;
}

bool leon3_accat_trap::RETT_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::RETT_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::RETT_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->PSR_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::RETT_imm::lockRegs_decode(){
    this->rd_decode.lock();
    this->PSR_pipe.lock();
}

bool leon3_accat_trap::RETT_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::RETT_imm::lockRegs_regs(){

}

bool leon3_accat_trap::RETT_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::RETT_imm::lockRegs_execute(){

}

bool leon3_accat_trap::RETT_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::RETT_imm::lockRegs_memory(){

}

bool leon3_accat_trap::RETT_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::RETT_imm::lockRegs_exception(){

}

bool leon3_accat_trap::RETT_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::RETT_imm::lockRegs_wb(){

}

void leon3_accat_trap::RETT_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::RETT_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::RETT_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::RETT_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::RETT_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::RETT_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::RETT_imm::replicate() const throw(){
    return new RETT_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::RETT_imm::getInstructionName() const throw(){
    return "RETT_imm";
}

unsigned int leon3_accat_trap::RETT_imm::getId() const throw(){
    return 121;
}

void leon3_accat_trap::RETT_imm::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::RETT_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "rett r";
    oss << this->rs1_bit;
    oss << "+";
    oss << this->simm13;
    return oss.str();
}

leon3_accat_trap::RETT_imm::RETT_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::RETT_imm::~RETT_imm(){

}
unsigned int leon3_accat_trap::SDIVcc_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SDIVcc_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rd rd_decode
    #define rs1 rs1_decode
    #define rs2 rs2_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SDIVcc_reg::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    rs1_op = rs1;
    rs2_op = rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SDIVcc_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    exception = rs2_op == 0;
    if(!exception){
        #ifndef ACC_MODEL
        long long res64 = ((long long)((((unsigned long long)Y) << 32) | (unsigned long long)rs1_op))/((long \
            long)((int)rs2_op));
        #else
        long long res64 = ((long long)((((unsigned long long)Y_execute) << 32) | (unsigned \
            long long)rs1_op))/((long long)((int)rs2_op));
        #endif
        temp_V = (res64 & 0xFFFFFFFF80000000LL) != 0 && (res64 & 0xFFFFFFFF80000000LL) != \
            0xFFFFFFFF80000000LL;
        if(temp_V){
            if(res64 > 0){
                result = 0x7FFFFFFF;
            }
            else{
                result = 0x80000000;
            }
        }
        else{
            result = (unsigned int)(res64 & 0x00000000FFFFFFFFLL);
        }
    }
    stall(2);


    if(!exception){
        PSR[key_ICC_n] = ((result & 0x80000000) >> 31);
        PSR[key_ICC_z] = (result == 0);
        PSR[key_ICC_v] = temp_V;
        PSR[key_ICC_c] = 0;
    }
    unlockQueue[0].push_back(&PSR_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SDIVcc_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SDIVcc_reg::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rd rd_exception
    #define rs1 rs1_exception
    #define rs2 rs2_exception


    if(exception){
        RaiseException(pcounter, npcounter, DIV_ZERO);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SDIVcc_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[33].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::SDIVcc_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    if(this->Y_decode.isLocked()){
        retVal += "Y - ";
    }
    if(this->PSR_decode.isLocked()){
        retVal += "PSR - ";
    }
    return retVal;
}

bool leon3_accat_trap::SDIVcc_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SDIVcc_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::SDIVcc_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    regLocked = this->Y_execute.isLocked() || regLocked;
    regLocked = this->PSR_execute.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::SDIVcc_reg::lockRegs_decode(){
    this->rd_decode.lock();
    this->PSR_pipe.lock();
}

bool leon3_accat_trap::SDIVcc_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SDIVcc_reg::lockRegs_regs(){

}

bool leon3_accat_trap::SDIVcc_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SDIVcc_reg::lockRegs_execute(){

}

bool leon3_accat_trap::SDIVcc_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SDIVcc_reg::lockRegs_memory(){

}

bool leon3_accat_trap::SDIVcc_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SDIVcc_reg::lockRegs_exception(){

}

bool leon3_accat_trap::SDIVcc_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SDIVcc_reg::lockRegs_wb(){

}

void leon3_accat_trap::SDIVcc_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::SDIVcc_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::SDIVcc_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::SDIVcc_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::SDIVcc_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::SDIVcc_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::SDIVcc_reg::replicate() const throw(){
    return new SDIVcc_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::SDIVcc_reg::getInstructionName() const throw(){
    return "SDIVcc_reg";
}

unsigned int leon3_accat_trap::SDIVcc_reg::getId() const throw(){
    return 112;
}

void leon3_accat_trap::SDIVcc_reg::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
}

std::string leon3_accat_trap::SDIVcc_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "sdivcc";
    oss << " r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::SDIVcc_reg::SDIVcc_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::SDIVcc_reg::~SDIVcc_reg(){

}
unsigned int leon3_accat_trap::ADD_reg::behavior_fetch( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADD_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADD_reg::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    rs1_op = rs1;
    rs2_op = rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADD_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    result = rs1_op + rs2_op;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADD_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADD_reg::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADD_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::ADD_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::ADD_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADD_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::ADD_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::ADD_reg::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::ADD_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADD_reg::lockRegs_regs(){

}

bool leon3_accat_trap::ADD_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADD_reg::lockRegs_execute(){

}

bool leon3_accat_trap::ADD_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADD_reg::lockRegs_memory(){

}

bool leon3_accat_trap::ADD_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADD_reg::lockRegs_exception(){

}

bool leon3_accat_trap::ADD_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADD_reg::lockRegs_wb(){

}

void leon3_accat_trap::ADD_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::ADD_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::ADD_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::ADD_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::ADD_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::ADD_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::ADD_reg::replicate() const throw(){
    return new ADD_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::ADD_reg::getInstructionName() const throw(){
    return "ADD_reg";
}

unsigned int leon3_accat_trap::ADD_reg::getId() const throw(){
    return 68;
}

void leon3_accat_trap::ADD_reg::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
}

std::string leon3_accat_trap::ADD_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "add r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::ADD_reg::ADD_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::ADD_reg::~ADD_reg(){

}
unsigned int leon3_accat_trap::TRAP_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TRAP_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rs1 rs1_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #ifndef ACC_MODEL
    bool icc_z = PSR[key_ICC_z];
    bool icc_n = PSR[key_ICC_n];
    bool icc_v = PSR[key_ICC_v];
    bool icc_c = PSR[key_ICC_c];
    #else
    bool icc_z = PSR_execute[key_ICC_z];
    bool icc_n = PSR_execute[key_ICC_n];
    bool icc_v = PSR_execute[key_ICC_v];
    bool icc_c = PSR_execute[key_ICC_c];
    #endif
    raiseException = (cond == 0x8) ||
    ((cond == 0x9) && !icc_z) ||
    ((cond == 0x1) && icc_z) ||
    ((cond == 0xa) && !icc_z && (icc_n == icc_v)) ||
    ((cond == 0x2) && (icc_z || (icc_n != icc_v))) ||
    ((cond == 0xb) && (icc_n == icc_v)) ||
    ((cond == 0x3) && (icc_n != icc_v)) ||
    ((cond == 0xc) && !icc_c && !icc_z) ||
    ((cond == 0x4) && (icc_c || icc_z)) ||
    ((cond == 0xd) && !icc_c) ||
    ((cond == 0x5) && icc_c) ||
    ((cond == 0xe) && !icc_n) ||
    ((cond == 0x6) && icc_n) ||
    ((cond == 0xf) && !icc_v) ||
    ((cond == 0x7) && icc_v);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TRAP_imm::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TRAP_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TRAP_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TRAP_imm::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rs1 rs1_exception


    if(raiseException){
        stall(4);
        RaiseException(pcounter, npcounter, TRAP_INSTRUCTION, (rs1 + SignExtend(imm7, 7)) \
            & 0x0000007F);
    }
    #ifndef ACC_MODEL
    else{
        PC = npcounter;
        NPC = npcounter + 4;
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TRAP_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

std::string leon3_accat_trap::TRAP_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->PSR_decode.isLocked()){
        retVal += "PSR - ";
    }
    return retVal;
}

bool leon3_accat_trap::TRAP_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TRAP_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::TRAP_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->PSR_execute.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::TRAP_imm::lockRegs_decode(){

}

bool leon3_accat_trap::TRAP_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TRAP_imm::lockRegs_regs(){

}

bool leon3_accat_trap::TRAP_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TRAP_imm::lockRegs_execute(){

}

bool leon3_accat_trap::TRAP_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TRAP_imm::lockRegs_memory(){

}

bool leon3_accat_trap::TRAP_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TRAP_imm::lockRegs_exception(){

}

bool leon3_accat_trap::TRAP_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TRAP_imm::lockRegs_wb(){

}

void leon3_accat_trap::TRAP_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::TRAP_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::TRAP_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::TRAP_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::TRAP_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::TRAP_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

Instruction * leon3_accat_trap::TRAP_imm::replicate() const throw(){
    return new TRAP_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::TRAP_imm::getInstructionName() const throw(){
    return "TRAP_imm";
}

unsigned int leon3_accat_trap::TRAP_imm::getId() const throw(){
    return 123;
}

void leon3_accat_trap::TRAP_imm::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->reserved1 = (bitString & 0x20000000) >> 29;
    this->cond = (bitString & 0x1e000000) >> 25;
    this->reserved2 = (bitString & 0x1f80) >> 7;
    this->imm7 = (bitString & 0x7f);
}

std::string leon3_accat_trap::TRAP_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "t";
    switch(this->cond){
        case 0:{
            oss << "n";
        break;}
        case 1:{
            oss << "e";
        break;}
        case 2:{
            oss << "le";
        break;}
        case 3:{
            oss << "l";
        break;}
        case 4:{
            oss << "leu";
        break;}
        case 6:{
            oss << "neg";
        break;}
        case 7:{
            oss << "vs";
        break;}
        case 8:{
            oss << "a";
        break;}
        case 9:{
            oss << "ne";
        break;}
        case 10:{
            oss << "cs";
        break;}
        case 11:{
            oss << "ge";
        break;}
        case 12:{
            oss << "gu";
        break;}
        case 13:{
            oss << "cc";
        break;}
        case 14:{
            oss << "pos";
        break;}
        case 15:{
            oss << "vc";
        break;}
        default:
        break;
    }
    oss << " r";
    oss << this->rs1_bit;
    oss << "+";
    oss << this->imm7;
    return oss.str();
}

leon3_accat_trap::TRAP_imm::TRAP_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::TRAP_imm::~TRAP_imm(){

}
unsigned int leon3_accat_trap::WRITEtbr_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEtbr_imm::behavior_decode( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rs1 rs1_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEtbr_imm::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs


    result = rs1 ^ SignExtend(simm13, 13);
    raiseException = (PSR[key_S] == 0);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEtbr_imm::behavior_execute( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEtbr_imm::behavior_memory( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEtbr_imm::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rs1 rs1_exception


    if(raiseException){
        RaiseException(pcounter, npcounter, PRIVILEDGE_INSTR);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEtbr_imm::behavior_wb( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rs1 rs1_wb


    if(!raiseException){
        TBR |= (result & 0xFFFFF000);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::WRITEtbr_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    return retVal;
}

bool leon3_accat_trap::WRITEtbr_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEtbr_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::WRITEtbr_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::WRITEtbr_imm::lockRegs_decode(){

}

bool leon3_accat_trap::WRITEtbr_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEtbr_imm::lockRegs_regs(){

}

bool leon3_accat_trap::WRITEtbr_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEtbr_imm::lockRegs_execute(){

}

bool leon3_accat_trap::WRITEtbr_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEtbr_imm::lockRegs_memory(){

}

bool leon3_accat_trap::WRITEtbr_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEtbr_imm::lockRegs_exception(){

}

bool leon3_accat_trap::WRITEtbr_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEtbr_imm::lockRegs_wb(){

}

void leon3_accat_trap::WRITEtbr_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::WRITEtbr_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::WRITEtbr_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::WRITEtbr_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::WRITEtbr_imm::getUnlock_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){

}

void leon3_accat_trap::WRITEtbr_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

Instruction * leon3_accat_trap::WRITEtbr_imm::replicate() const throw(){
    return new WRITEtbr_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, \
        GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, \
        NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, \
        PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::WRITEtbr_imm::getInstructionName() const throw(){
    return "WRITEtbr_imm";
}

unsigned int leon3_accat_trap::WRITEtbr_imm::getId() const throw(){
    return 139;
}

void leon3_accat_trap::WRITEtbr_imm::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rd = (bitString & 0x3e000000) >> 25;
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::WRITEtbr_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "wr r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << " tbr";
    return oss.str();
}

leon3_accat_trap::WRITEtbr_imm::WRITEtbr_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::WRITEtbr_imm::~WRITEtbr_imm(){

}
unsigned int leon3_accat_trap::LDUB_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch
    #define rd rd_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDUB_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDUB_reg::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs
    #define rd rd_regs


    address = rs1 + rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDUB_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDUB_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_memory
    #define WIM WIM_memory
    #define TBR TBR_memory
    #define Y Y_memory
    #define PC PC_memory
    #define NPC NPC_memory
    #define GLOBAL GLOBAL_memory
    #define WINREGS WINREGS_memory
    #define ASR ASR_memory
    #define FP FP_memory
    #define LR LR_memory
    #define SP SP_memory
    #define PCR PCR_memory
    #define REGS REGS_memory
    #define rs1 rs1_memory
    #define rs2 rs2_memory
    #define rd rd_memory


    readValue = dataMem.read_byte(address);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDUB_reg::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDUB_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb
    #define rd rd_wb


    rd = readValue;
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

std::string leon3_accat_trap::LDUB_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::LDUB_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDUB_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::LDUB_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::LDUB_reg::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::LDUB_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDUB_reg::lockRegs_regs(){

}

bool leon3_accat_trap::LDUB_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDUB_reg::lockRegs_execute(){

}

bool leon3_accat_trap::LDUB_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDUB_reg::lockRegs_memory(){

}

bool leon3_accat_trap::LDUB_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDUB_reg::lockRegs_exception(){

}

bool leon3_accat_trap::LDUB_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDUB_reg::lockRegs_wb(){

}

void leon3_accat_trap::LDUB_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::LDUB_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::LDUB_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::LDUB_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::LDUB_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::LDUB_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::LDUB_reg::replicate() const throw(){
    return new LDUB_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::LDUB_reg::getInstructionName() const throw(){
    return "LDUB_reg";
}

unsigned int leon3_accat_trap::LDUB_reg::getId() const throw(){
    return 5;
}

void leon3_accat_trap::LDUB_reg::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->asi = (bitString & 0x1fe0) >> 5;
}

std::string leon3_accat_trap::LDUB_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "ldub r";
    oss << this->rs1_bit;
    oss << "+r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::LDUB_reg::LDUB_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
}

leon3_accat_trap::LDUB_reg::~LDUB_reg(){

}
unsigned int leon3_accat_trap::RESTORE_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::RESTORE_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rd rd_decode
    #define rs1 rs1_decode
    #define rs2 rs2_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif
    result = rs1 + rs2;

    okNewWin = IncrementRegWindow();
    #ifdef ACC_MODEL
    if(!okNewWin){
        flush();
    }
    else{
        rd.lock();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::RESTORE_reg::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    #ifdef ACC_MODEL
    if(!okNewWin){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::RESTORE_reg::behavior_execute( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    #ifdef ACC_MODEL
    if(!okNewWin){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::RESTORE_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_memory
    #define WIM WIM_memory
    #define TBR TBR_memory
    #define Y Y_memory
    #define PC PC_memory
    #define NPC NPC_memory
    #define GLOBAL GLOBAL_memory
    #define WINREGS WINREGS_memory
    #define ASR ASR_memory
    #define FP FP_memory
    #define LR LR_memory
    #define SP SP_memory
    #define PCR PCR_memory
    #define REGS REGS_memory
    #define rd rd_memory
    #define rs1 rs1_memory
    #define rs2 rs2_memory


    #ifdef ACC_MODEL
    if(!okNewWin){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::RESTORE_reg::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rd rd_exception
    #define rs1 rs1_exception
    #define rs2 rs2_exception


    if(!okNewWin){
        RaiseException(pcounter, npcounter, WINDOW_UNDERFLOW);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::RESTORE_reg::behavior_wb( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb


    if(okNewWin){
        rd = result;
        #ifdef ACC_MODEL
        unlockQueue[0].push_back(rd.getPipeReg());
        #endif
    }
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::RESTORE_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    if(this->PSR_decode.isLocked()){
        retVal += "PSR - ";
    }
    return retVal;
}

bool leon3_accat_trap::RESTORE_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::RESTORE_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::RESTORE_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    regLocked = this->PSR_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::RESTORE_reg::lockRegs_decode(){
    this->PSR_pipe.lock();
}

bool leon3_accat_trap::RESTORE_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::RESTORE_reg::lockRegs_regs(){

}

bool leon3_accat_trap::RESTORE_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::RESTORE_reg::lockRegs_execute(){

}

bool leon3_accat_trap::RESTORE_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::RESTORE_reg::lockRegs_memory(){

}

bool leon3_accat_trap::RESTORE_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::RESTORE_reg::lockRegs_exception(){

}

bool leon3_accat_trap::RESTORE_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::RESTORE_reg::lockRegs_wb(){

}

void leon3_accat_trap::RESTORE_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
}

void leon3_accat_trap::RESTORE_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
}

void leon3_accat_trap::RESTORE_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
}

void leon3_accat_trap::RESTORE_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
}

void leon3_accat_trap::RESTORE_reg::getUnlock_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
}

void leon3_accat_trap::RESTORE_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
}

Instruction * leon3_accat_trap::RESTORE_reg::replicate() const throw(){
    return new RESTORE_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::RESTORE_reg::getInstructionName() const throw(){
    return "RESTORE_reg";
}

unsigned int leon3_accat_trap::RESTORE_reg::getId() const throw(){
    return 116;
}

void leon3_accat_trap::RESTORE_reg::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
}

std::string leon3_accat_trap::RESTORE_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "restore";
    oss << " r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::RESTORE_reg::RESTORE_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::RESTORE_reg::~RESTORE_reg(){

}
unsigned int leon3_accat_trap::ADDXcc_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADDXcc_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADDXcc_reg::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    rs1_op = rs1;
    rs2_op = rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADDXcc_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    #ifndef ACC_MODEL
    result = rs1_op + rs2_op + PSR[key_ICC_c];
    #else
    //I read the register of the execute stage since this
    //is the one containing the bypass value
    result = rs1_op + rs2_op + PSR_execute[key_ICC_c];
    #endif


    PSR[key_ICC_n] = ((result & 0x80000000) >> 31);
    PSR[key_ICC_z] = (result == 0);
    PSR[key_ICC_v] = ((unsigned int)((rs1_op & rs2_op & (~result)) | ((~rs1_op) & (~rs2_op) \
        & result))) >> 31;
    PSR[key_ICC_c] = ((unsigned int)((rs1_op & rs2_op) | ((rs1_op | rs2_op) & (~result)))) \
        >> 31;
    unlockQueue[0].push_back(&PSR_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADDXcc_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADDXcc_reg::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADDXcc_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::ADDXcc_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    if(this->PSR_decode.isLocked()){
        retVal += "PSR - ";
    }
    return retVal;
}

bool leon3_accat_trap::ADDXcc_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADDXcc_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::ADDXcc_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    regLocked = this->PSR_execute.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::ADDXcc_reg::lockRegs_decode(){
    this->rd_decode.lock();
    this->PSR_pipe.lock();
}

bool leon3_accat_trap::ADDXcc_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADDXcc_reg::lockRegs_regs(){

}

bool leon3_accat_trap::ADDXcc_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADDXcc_reg::lockRegs_execute(){

}

bool leon3_accat_trap::ADDXcc_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADDXcc_reg::lockRegs_memory(){

}

bool leon3_accat_trap::ADDXcc_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADDXcc_reg::lockRegs_exception(){

}

bool leon3_accat_trap::ADDXcc_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADDXcc_reg::lockRegs_wb(){

}

void leon3_accat_trap::ADDXcc_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::ADDXcc_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::ADDXcc_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::ADDXcc_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::ADDXcc_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::ADDXcc_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::ADDXcc_reg::replicate() const throw(){
    return new ADDXcc_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::ADDXcc_reg::getInstructionName() const throw(){
    return "ADDXcc_reg";
}

unsigned int leon3_accat_trap::ADDXcc_reg::getId() const throw(){
    return 74;
}

void leon3_accat_trap::ADDXcc_reg::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
}

std::string leon3_accat_trap::ADDXcc_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "addxcc r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::ADDXcc_reg::ADDXcc_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::ADDXcc_reg::~ADDXcc_reg(){

}
unsigned int leon3_accat_trap::STB_reg::behavior_fetch( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch
    #define rd rd_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STB_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STB_reg::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs
    #define rd rd_regs


    address = rs1 + rs2;
    toWrite = (unsigned char)(rd & 0x000000FF);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STB_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STB_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_memory
    #define WIM WIM_memory
    #define TBR TBR_memory
    #define Y Y_memory
    #define PC PC_memory
    #define NPC NPC_memory
    #define GLOBAL GLOBAL_memory
    #define WINREGS WINREGS_memory
    #define ASR ASR_memory
    #define FP FP_memory
    #define LR LR_memory
    #define SP SP_memory
    #define PCR PCR_memory
    #define REGS REGS_memory
    #define rs1 rs1_memory
    #define rs2 rs2_memory
    #define rd rd_memory


    dataMem.write_byte(address, toWrite);
    stall(1);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STB_reg::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STB_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

std::string leon3_accat_trap::STB_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    if(this->rd_decode.isLocked()){
        retVal += "rd - ";
    }
    return retVal;
}

bool leon3_accat_trap::STB_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STB_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::STB_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    regLocked = this->rd_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::STB_reg::lockRegs_decode(){

}

bool leon3_accat_trap::STB_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STB_reg::lockRegs_regs(){

}

bool leon3_accat_trap::STB_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STB_reg::lockRegs_execute(){

}

bool leon3_accat_trap::STB_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STB_reg::lockRegs_memory(){

}

bool leon3_accat_trap::STB_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STB_reg::lockRegs_exception(){

}

bool leon3_accat_trap::STB_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STB_reg::lockRegs_wb(){

}

void leon3_accat_trap::STB_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STB_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STB_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STB_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STB_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STB_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

Instruction * leon3_accat_trap::STB_reg::replicate() const throw(){
    return new STB_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::STB_reg::getInstructionName() const throw(){
    return "STB_reg";
}

unsigned int leon3_accat_trap::STB_reg::getId() const throw(){
    return 19;
}

void leon3_accat_trap::STB_reg::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->asi = (bitString & 0x1fe0) >> 5;
}

std::string leon3_accat_trap::STB_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "stb r";
    oss << this->rd_bit;
    oss << " r";
    oss << this->rs1_bit;
    oss << "+r";
    oss << this->rs2_bit;
    return oss.str();
}

leon3_accat_trap::STB_reg::STB_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
}

leon3_accat_trap::STB_reg::~STB_reg(){

}
unsigned int leon3_accat_trap::AND_imm::behavior_fetch( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::AND_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::AND_imm::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs


    rs1_op = rs1;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::AND_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute


    result = rs1_op & SignExtend(simm13, 13);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::AND_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::AND_imm::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::AND_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::AND_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    return retVal;
}

bool leon3_accat_trap::AND_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::AND_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::AND_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::AND_imm::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::AND_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::AND_imm::lockRegs_regs(){

}

bool leon3_accat_trap::AND_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::AND_imm::lockRegs_execute(){

}

bool leon3_accat_trap::AND_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::AND_imm::lockRegs_memory(){

}

bool leon3_accat_trap::AND_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::AND_imm::lockRegs_exception(){

}

bool leon3_accat_trap::AND_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::AND_imm::lockRegs_wb(){

}

void leon3_accat_trap::AND_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::AND_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::AND_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::AND_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::AND_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::AND_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::AND_imm::replicate() const throw(){
    return new AND_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::AND_imm::getInstructionName() const throw(){
    return "AND_imm";
}

unsigned int leon3_accat_trap::AND_imm::getId() const throw(){
    return 37;
}

void leon3_accat_trap::AND_imm::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::AND_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "and r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::AND_imm::AND_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::AND_imm::~AND_imm(){

}
unsigned int leon3_accat_trap::SMUL_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SMUL_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SMUL_imm::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs


    rs1_op = rs1;
    rs2_op = SignExtend(simm13, 13);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SMUL_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute


    long long resultTemp = (long long)(((long long)((int)rs1_op))*((long long)((int)rs2_op)));
    Y = ((unsigned long long)resultTemp) >> 32;
    result = resultTemp & 0x00000000FFFFFFFF;
    stall(2);
    unlockQueue[0].push_back(&Y_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SMUL_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SMUL_imm::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SMUL_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[2].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::SMUL_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    return retVal;
}

bool leon3_accat_trap::SMUL_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SMUL_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::SMUL_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::SMUL_imm::lockRegs_decode(){
    this->rd_decode.lock();
    this->Y_pipe.lock();
}

bool leon3_accat_trap::SMUL_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SMUL_imm::lockRegs_regs(){

}

bool leon3_accat_trap::SMUL_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SMUL_imm::lockRegs_execute(){

}

bool leon3_accat_trap::SMUL_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SMUL_imm::lockRegs_memory(){

}

bool leon3_accat_trap::SMUL_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SMUL_imm::lockRegs_exception(){

}

bool leon3_accat_trap::SMUL_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SMUL_imm::lockRegs_wb(){

}

void leon3_accat_trap::SMUL_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::SMUL_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::SMUL_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::SMUL_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::SMUL_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::SMUL_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::SMUL_imm::replicate() const throw(){
    return new SMUL_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::SMUL_imm::getInstructionName() const throw(){
    return "SMUL_imm";
}

unsigned int leon3_accat_trap::SMUL_imm::getId() const throw(){
    return 95;
}

void leon3_accat_trap::SMUL_imm::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::SMUL_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "smul r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::SMUL_imm::SMUL_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::SMUL_imm::~SMUL_imm(){

}
unsigned int leon3_accat_trap::ADD_imm::behavior_fetch( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADD_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADD_imm::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs


    rs1_op = rs1;
    rs2_op = SignExtend(simm13, 13);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADD_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute


    result = rs1_op + rs2_op;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADD_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADD_imm::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADD_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::ADD_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    return retVal;
}

bool leon3_accat_trap::ADD_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADD_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::ADD_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::ADD_imm::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::ADD_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADD_imm::lockRegs_regs(){

}

bool leon3_accat_trap::ADD_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADD_imm::lockRegs_execute(){

}

bool leon3_accat_trap::ADD_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADD_imm::lockRegs_memory(){

}

bool leon3_accat_trap::ADD_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADD_imm::lockRegs_exception(){

}

bool leon3_accat_trap::ADD_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADD_imm::lockRegs_wb(){

}

void leon3_accat_trap::ADD_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::ADD_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::ADD_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::ADD_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::ADD_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::ADD_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::ADD_imm::replicate() const throw(){
    return new ADD_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::ADD_imm::getInstructionName() const throw(){
    return "ADD_imm";
}

unsigned int leon3_accat_trap::ADD_imm::getId() const throw(){
    return 67;
}

void leon3_accat_trap::ADD_imm::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::ADD_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "add r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::ADD_imm::ADD_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::ADD_imm::~ADD_imm(){

}
unsigned int leon3_accat_trap::UMUL_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UMUL_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UMUL_imm::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs


    rs1_op = rs1;
    rs2_op = SignExtend(simm13, 13);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UMUL_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute


    unsigned long long resultTemp = (unsigned long long)(((unsigned long long)((unsigned \
        int)rs1_op))*((unsigned long long)((unsigned int)rs2_op)));
    Y = resultTemp >> 32;
    result = resultTemp & 0x00000000FFFFFFFF;
    stall(2);
    unlockQueue[0].push_back(&Y_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UMUL_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UMUL_imm::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UMUL_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[2].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::UMUL_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    return retVal;
}

bool leon3_accat_trap::UMUL_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UMUL_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::UMUL_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::UMUL_imm::lockRegs_decode(){
    this->rd_decode.lock();
    this->Y_pipe.lock();
}

bool leon3_accat_trap::UMUL_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UMUL_imm::lockRegs_regs(){

}

bool leon3_accat_trap::UMUL_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UMUL_imm::lockRegs_execute(){

}

bool leon3_accat_trap::UMUL_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UMUL_imm::lockRegs_memory(){

}

bool leon3_accat_trap::UMUL_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UMUL_imm::lockRegs_exception(){

}

bool leon3_accat_trap::UMUL_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UMUL_imm::lockRegs_wb(){

}

void leon3_accat_trap::UMUL_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::UMUL_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::UMUL_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::UMUL_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::UMUL_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::UMUL_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::UMUL_imm::replicate() const throw(){
    return new UMUL_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::UMUL_imm::getInstructionName() const throw(){
    return "UMUL_imm";
}

unsigned int leon3_accat_trap::UMUL_imm::getId() const throw(){
    return 93;
}

void leon3_accat_trap::UMUL_imm::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::UMUL_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "umul r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::UMUL_imm::UMUL_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::UMUL_imm::~UMUL_imm(){

}
unsigned int leon3_accat_trap::READwim::behavior_fetch( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::READwim::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rd rd_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::READwim::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs


    wim_temp = WIM;
    supervisor = PSR[key_S];

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::READwim::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::READwim::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::READwim::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rd rd_exception


    if(!supervisor){
        RaiseException(pcounter, npcounter, PRIVILEDGE_INSTR);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::READwim::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb


    rd = wim_temp;
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    return this->stageCycles;
}

std::string leon3_accat_trap::READwim::printBusyRegs(){
    std::string retVal = "";
    return retVal;
}

bool leon3_accat_trap::READwim::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::READwim::lockRegs_fetch(){

}

bool leon3_accat_trap::READwim::checkHazard_decode(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::READwim::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::READwim::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::READwim::lockRegs_regs(){

}

bool leon3_accat_trap::READwim::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::READwim::lockRegs_execute(){

}

bool leon3_accat_trap::READwim::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::READwim::lockRegs_memory(){

}

bool leon3_accat_trap::READwim::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::READwim::lockRegs_exception(){

}

bool leon3_accat_trap::READwim::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::READwim::lockRegs_wb(){

}

void leon3_accat_trap::READwim::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::READwim::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::READwim::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::READwim::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::READwim::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::READwim::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::READwim::replicate() const throw(){
    return new READwim(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::READwim::getInstructionName() const throw(){
    return "READwim";
}

unsigned int leon3_accat_trap::READwim::getId() const throw(){
    return 128;
}

void leon3_accat_trap::READwim::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->asr = (bitString & 0x7c000) >> 14;
}

std::string leon3_accat_trap::READwim::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "rd ";
    oss << "wim r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::READwim::READwim( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
}

leon3_accat_trap::READwim::~READwim(){

}
unsigned int leon3_accat_trap::LDSTUB_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch
    #define rd rd_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSTUB_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSTUB_imm::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs
    #define rd rd_regs


    address = rs1 + SignExtend(simm13, 13);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSTUB_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSTUB_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_memory
    #define WIM WIM_memory
    #define TBR TBR_memory
    #define Y Y_memory
    #define PC PC_memory
    #define NPC NPC_memory
    #define GLOBAL GLOBAL_memory
    #define WINREGS WINREGS_memory
    #define ASR ASR_memory
    #define FP FP_memory
    #define LR LR_memory
    #define SP SP_memory
    #define PCR PCR_memory
    #define REGS REGS_memory
    #define rs1 rs1_memory
    #define rd rd_memory


    readValue = dataMem.read_byte(address);
    dataMem.write_byte(address, 0xff);
    stall(2);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSTUB_imm::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSTUB_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rs1 rs1_wb
    #define rd rd_wb


    rd = readValue;
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

std::string leon3_accat_trap::LDSTUB_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    return retVal;
}

bool leon3_accat_trap::LDSTUB_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSTUB_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::LDSTUB_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::LDSTUB_imm::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::LDSTUB_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSTUB_imm::lockRegs_regs(){

}

bool leon3_accat_trap::LDSTUB_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSTUB_imm::lockRegs_execute(){

}

bool leon3_accat_trap::LDSTUB_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSTUB_imm::lockRegs_memory(){

}

bool leon3_accat_trap::LDSTUB_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSTUB_imm::lockRegs_exception(){

}

bool leon3_accat_trap::LDSTUB_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSTUB_imm::lockRegs_wb(){

}

void leon3_accat_trap::LDSTUB_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::LDSTUB_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::LDSTUB_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::LDSTUB_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::LDSTUB_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::LDSTUB_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::LDSTUB_imm::replicate() const throw(){
    return new LDSTUB_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::LDSTUB_imm::getInstructionName() const throw(){
    return "LDSTUB_imm";
}

unsigned int leon3_accat_trap::LDSTUB_imm::getId() const throw(){
    return 30;
}

void leon3_accat_trap::LDSTUB_imm::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::LDSTUB_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "ldastub r";
    oss << this->rs1_bit;
    oss << "+";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::LDSTUB_imm::LDSTUB_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
}

leon3_accat_trap::LDSTUB_imm::~LDSTUB_imm(){

}
unsigned int leon3_accat_trap::SMAC_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SMAC_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SMAC_imm::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs


    rs1_op = rs1;
    rs2_op = SignExtend(simm13, 13);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SMAC_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute


    int resultTemp = ((int)SignExtend(rs1_op & 0x0000ffff, 16))*((int)SignExtend(rs2_op \
        & 0x0000ffff, 16));
    #ifndef ACC_MODEL
    long long resultAcc = ((((long long)(Y & 0x000000ff)) << 32) | (int)ASR[18]) + resultTemp;
    #else
    long long resultAcc = ((((long long)(Y_execute & 0x000000ff)) << 32) | (int)ASR_execute[18]) \
        + resultTemp;
    #endif
    Y = (resultAcc & 0x000000ff00000000LL) >> 32;
    ASR[18] = resultAcc & 0x00000000FFFFFFFFLL;
    result = resultAcc & 0x00000000FFFFFFFFLL;
    stall(1);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&ASR_execute[18]);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SMAC_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SMAC_imm::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SMAC_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&ASR_fetch[18]);
    unlockQueue[0].push_back(&ASR_decode[18]);
    unlockQueue[0].push_back(&ASR_regs[18]);
    unlockQueue[0].push_back(&ASR_memory[18]);
    unlockQueue[0].push_back(&ASR_exception[18]);
    unlockQueue[0].push_back(&ASR_wb[18]);
    unlockQueue[0].push_back(ASR_pipe[18].getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::SMAC_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->Y_decode.isLocked()){
        retVal += "Y - ";
    }
    if(this->ASR_decode[18].isLocked()){
        retVal += "ASR[18] - ";
    }
    return retVal;
}

bool leon3_accat_trap::SMAC_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SMAC_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::SMAC_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->Y_execute.isLocked() || regLocked;
    regLocked = this->ASR_execute[18].isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::SMAC_imm::lockRegs_decode(){
    this->rd_decode.lock();
    this->Y_pipe.lock();
    this->ASR_pipe[18].lock();
}

bool leon3_accat_trap::SMAC_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SMAC_imm::lockRegs_regs(){

}

bool leon3_accat_trap::SMAC_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SMAC_imm::lockRegs_execute(){

}

bool leon3_accat_trap::SMAC_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SMAC_imm::lockRegs_memory(){

}

bool leon3_accat_trap::SMAC_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SMAC_imm::lockRegs_exception(){

}

bool leon3_accat_trap::SMAC_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SMAC_imm::lockRegs_wb(){

}

void leon3_accat_trap::SMAC_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&ASR_fetch[18]);
    unlockQueue[0].push_back(&ASR_decode[18]);
    unlockQueue[0].push_back(&ASR_regs[18]);
    unlockQueue[0].push_back(&ASR_execute[18]);
    unlockQueue[0].push_back(&ASR_memory[18]);
    unlockQueue[0].push_back(&ASR_exception[18]);
    unlockQueue[0].push_back(&ASR_wb[18]);
    unlockQueue[0].push_back(ASR_pipe[18].getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::SMAC_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&ASR_fetch[18]);
    unlockQueue[0].push_back(&ASR_decode[18]);
    unlockQueue[0].push_back(&ASR_regs[18]);
    unlockQueue[0].push_back(&ASR_execute[18]);
    unlockQueue[0].push_back(&ASR_memory[18]);
    unlockQueue[0].push_back(&ASR_exception[18]);
    unlockQueue[0].push_back(&ASR_wb[18]);
    unlockQueue[0].push_back(ASR_pipe[18].getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::SMAC_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&ASR_fetch[18]);
    unlockQueue[0].push_back(&ASR_decode[18]);
    unlockQueue[0].push_back(&ASR_regs[18]);
    unlockQueue[0].push_back(&ASR_execute[18]);
    unlockQueue[0].push_back(&ASR_memory[18]);
    unlockQueue[0].push_back(&ASR_exception[18]);
    unlockQueue[0].push_back(&ASR_wb[18]);
    unlockQueue[0].push_back(ASR_pipe[18].getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::SMAC_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&ASR_fetch[18]);
    unlockQueue[0].push_back(&ASR_decode[18]);
    unlockQueue[0].push_back(&ASR_regs[18]);
    unlockQueue[0].push_back(&ASR_memory[18]);
    unlockQueue[0].push_back(&ASR_exception[18]);
    unlockQueue[0].push_back(&ASR_wb[18]);
    unlockQueue[0].push_back(ASR_pipe[18].getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::SMAC_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&ASR_fetch[18]);
    unlockQueue[0].push_back(&ASR_decode[18]);
    unlockQueue[0].push_back(&ASR_regs[18]);
    unlockQueue[0].push_back(&ASR_memory[18]);
    unlockQueue[0].push_back(&ASR_exception[18]);
    unlockQueue[0].push_back(&ASR_wb[18]);
    unlockQueue[0].push_back(ASR_pipe[18].getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::SMAC_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&ASR_fetch[18]);
    unlockQueue[0].push_back(&ASR_decode[18]);
    unlockQueue[0].push_back(&ASR_regs[18]);
    unlockQueue[0].push_back(&ASR_memory[18]);
    unlockQueue[0].push_back(&ASR_exception[18]);
    unlockQueue[0].push_back(&ASR_wb[18]);
    unlockQueue[0].push_back(ASR_pipe[18].getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::SMAC_imm::replicate() const throw(){
    return new SMAC_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::SMAC_imm::getInstructionName() const throw(){
    return "SMAC_imm";
}

unsigned int leon3_accat_trap::SMAC_imm::getId() const throw(){
    return 103;
}

void leon3_accat_trap::SMAC_imm::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::SMAC_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "smac r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::SMAC_imm::SMAC_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::SMAC_imm::~SMAC_imm(){

}
unsigned int leon3_accat_trap::LDSB_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch
    #define rd rd_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSB_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSB_reg::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs
    #define rd rd_regs


    address = rs1 + rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSB_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSB_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_memory
    #define WIM WIM_memory
    #define TBR TBR_memory
    #define Y Y_memory
    #define PC PC_memory
    #define NPC NPC_memory
    #define GLOBAL GLOBAL_memory
    #define WINREGS WINREGS_memory
    #define ASR ASR_memory
    #define FP FP_memory
    #define LR LR_memory
    #define SP SP_memory
    #define PCR PCR_memory
    #define REGS REGS_memory
    #define rs1 rs1_memory
    #define rs2 rs2_memory
    #define rd rd_memory


    readValue = SignExtend(dataMem.read_byte(address), 8);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSB_reg::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSB_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb
    #define rd rd_wb


    rd = readValue;
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

std::string leon3_accat_trap::LDSB_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::LDSB_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSB_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::LDSB_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::LDSB_reg::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::LDSB_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSB_reg::lockRegs_regs(){

}

bool leon3_accat_trap::LDSB_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSB_reg::lockRegs_execute(){

}

bool leon3_accat_trap::LDSB_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSB_reg::lockRegs_memory(){

}

bool leon3_accat_trap::LDSB_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSB_reg::lockRegs_exception(){

}

bool leon3_accat_trap::LDSB_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSB_reg::lockRegs_wb(){

}

void leon3_accat_trap::LDSB_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::LDSB_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::LDSB_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::LDSB_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::LDSB_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::LDSB_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::LDSB_reg::replicate() const throw(){
    return new LDSB_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::LDSB_reg::getInstructionName() const throw(){
    return "LDSB_reg";
}

unsigned int leon3_accat_trap::LDSB_reg::getId() const throw(){
    return 1;
}

void leon3_accat_trap::LDSB_reg::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->asi = (bitString & 0x1fe0) >> 5;
}

std::string leon3_accat_trap::LDSB_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "ldsb r";
    oss << this->rs1_bit;
    oss << "+r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::LDSB_reg::LDSB_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
}

leon3_accat_trap::LDSB_reg::~LDSB_reg(){

}
unsigned int leon3_accat_trap::ANDN_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ANDN_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ANDN_reg::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    rs1_op = rs1;
    rs2_op = rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ANDN_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    result = rs1_op & ~rs2_op;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ANDN_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ANDN_reg::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ANDN_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::ANDN_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::ANDN_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ANDN_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::ANDN_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::ANDN_reg::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::ANDN_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ANDN_reg::lockRegs_regs(){

}

bool leon3_accat_trap::ANDN_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ANDN_reg::lockRegs_execute(){

}

bool leon3_accat_trap::ANDN_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ANDN_reg::lockRegs_memory(){

}

bool leon3_accat_trap::ANDN_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ANDN_reg::lockRegs_exception(){

}

bool leon3_accat_trap::ANDN_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ANDN_reg::lockRegs_wb(){

}

void leon3_accat_trap::ANDN_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::ANDN_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::ANDN_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::ANDN_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::ANDN_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::ANDN_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::ANDN_reg::replicate() const throw(){
    return new ANDN_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::ANDN_reg::getInstructionName() const throw(){
    return "ANDN_reg";
}

unsigned int leon3_accat_trap::ANDN_reg::getId() const throw(){
    return 42;
}

void leon3_accat_trap::ANDN_reg::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
}

std::string leon3_accat_trap::ANDN_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "andn r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::ANDN_reg::ANDN_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::ANDN_reg::~ANDN_reg(){

}
unsigned int leon3_accat_trap::TSUBccTV_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TSUBccTV_reg::behavior_decode( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rd rd_decode
    #define rs1 rs1_decode
    #define rs2 rs2_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TSUBccTV_reg::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    rs1_op = rs1;
    rs2_op = rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TSUBccTV_reg::behavior_execute( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    result = rs1_op - rs2_op;
    temp_V = ((unsigned int)((rs1_op & (~rs2_op) & (~result)) | ((~rs1_op) & rs2_op & \
        result))) >> 31;
    if(!temp_V && (((rs1_op | rs2_op) & 0x00000003) != 0)){
        temp_V = 1;
    }


    if(!temp_V){
        PSR[key_ICC_n] = ((result & 0x80000000) >> 31);
        PSR[key_ICC_z] = (result == 0);
        PSR[key_ICC_v] = temp_V;
        PSR[key_ICC_c] = ((unsigned int)(((~rs1_op) & rs2_op) | (((~rs1_op) | rs2_op) & result))) \
            >> 31;
    }
    unlockQueue[0].push_back(&PSR_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TSUBccTV_reg::behavior_memory( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TSUBccTV_reg::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rd rd_exception
    #define rs1 rs1_exception
    #define rs2 rs2_exception


    if(temp_V){
        RaiseException(pcounter, npcounter, TAG_OVERFLOW);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TSUBccTV_reg::behavior_wb( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb

    {


        if(!temp_V){
            rd = result;
        }
    }
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::TSUBccTV_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::TSUBccTV_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TSUBccTV_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::TSUBccTV_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::TSUBccTV_reg::lockRegs_decode(){
    this->rd_decode.lock();
    this->PSR_pipe.lock();
}

bool leon3_accat_trap::TSUBccTV_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TSUBccTV_reg::lockRegs_regs(){

}

bool leon3_accat_trap::TSUBccTV_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TSUBccTV_reg::lockRegs_execute(){

}

bool leon3_accat_trap::TSUBccTV_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TSUBccTV_reg::lockRegs_memory(){

}

bool leon3_accat_trap::TSUBccTV_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TSUBccTV_reg::lockRegs_exception(){

}

bool leon3_accat_trap::TSUBccTV_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TSUBccTV_reg::lockRegs_wb(){

}

void leon3_accat_trap::TSUBccTV_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::TSUBccTV_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::TSUBccTV_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::TSUBccTV_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::TSUBccTV_reg::getUnlock_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::TSUBccTV_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::TSUBccTV_reg::replicate() const throw(){
    return new TSUBccTV_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, \
        GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, \
        NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, \
        PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::TSUBccTV_reg::getInstructionName() const throw(){
    return "TSUBccTV_reg";
}

unsigned int leon3_accat_trap::TSUBccTV_reg::getId() const throw(){
    return 90;
}

void leon3_accat_trap::TSUBccTV_reg::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
}

std::string leon3_accat_trap::TSUBccTV_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "tsubcctv r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::TSUBccTV_reg::TSUBccTV_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::TSUBccTV_reg::~TSUBccTV_reg(){

}
unsigned int leon3_accat_trap::SETHI::behavior_fetch( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SETHI::behavior_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SETHI::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SETHI::behavior_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute


    result = 0xfffffc00 & (imm22 << 10);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SETHI::behavior_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SETHI::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SETHI::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    return this->stageCycles;
}

std::string leon3_accat_trap::SETHI::printBusyRegs(){
    std::string retVal = "";
    return retVal;
}

bool leon3_accat_trap::SETHI::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SETHI::lockRegs_fetch(){

}

bool leon3_accat_trap::SETHI::checkHazard_decode(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SETHI::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::SETHI::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SETHI::lockRegs_regs(){

}

bool leon3_accat_trap::SETHI::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SETHI::lockRegs_execute(){

}

bool leon3_accat_trap::SETHI::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SETHI::lockRegs_memory(){

}

bool leon3_accat_trap::SETHI::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SETHI::lockRegs_exception(){

}

bool leon3_accat_trap::SETHI::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SETHI::lockRegs_wb(){

}

void leon3_accat_trap::SETHI::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::SETHI::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::SETHI::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::SETHI::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::SETHI::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::SETHI::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::SETHI::replicate() const throw(){
    return new SETHI(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::SETHI::getInstructionName() const throw(){
    return "SETHI";
}

unsigned int leon3_accat_trap::SETHI::getId() const throw(){
    return 36;
}

void leon3_accat_trap::SETHI::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->imm22 = (bitString & 0x3fffff);
}

std::string leon3_accat_trap::SETHI::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "sethi ";
    oss << this->imm22;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::SETHI::SETHI( PipelineRegister & PSR_pipe, PipelineRegister & WIM_pipe, \
    PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister & PC_pipe, \
    PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister * WINREGS_pipe, \
    PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, Reg32_2 & \
    TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, RegisterBankClass \
    & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias & FP_fetch, Alias \
    & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, Reg32_0 & PSR_decode, \
    Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, Reg32_3 & PC_decode, \
    Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 * WINREGS_decode, \
    Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias & SP_decode, Alias \
    & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 & WIM_regs, Reg32_2 \
    & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, RegisterBankClass \
    & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias & FP_regs, Alias \
    & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, Reg32_0 & PSR_execute, \
    Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, Reg32_3 & PC_execute, \
    Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, Reg32_3 * WINREGS_execute, \
    Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, Alias & SP_execute, \
    Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, Reg32_1 & WIM_memory, \
    Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, Reg32_3 & NPC_memory, \
    RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, Reg32_3 * ASR_memory, \
    Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias & PCR_memory, Alias \
    * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, Reg32_2 & TBR_exception, \
    Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & NPC_exception, RegisterBankClass \
    & GLOBAL_exception, Reg32_3 * WINREGS_exception, Reg32_3 * ASR_exception, Alias & \
    FP_exception, Alias & LR_exception, Alias & SP_exception, Alias & PCR_exception, \
    Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, Reg32_2 & TBR_wb, Reg32_3 \
    & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass & GLOBAL_wb, Reg32_3 \
    * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, Alias & SP_wb, Alias \
    & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & dataMem, PinTLM_out_32 \
    & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, \
    GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, \
    NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, \
    PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
    GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
    REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
    WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
    WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
    ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
    WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
    ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
    WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
    WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
    REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
    ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
}

leon3_accat_trap::SETHI::~SETHI(){

}
unsigned int leon3_accat_trap::SRA_imm::behavior_fetch( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SRA_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SRA_imm::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs


    rs1_op = rs1;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SRA_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute


    result = ((int)rs1_op) >> simm13;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SRA_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SRA_imm::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SRA_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::SRA_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    return retVal;
}

bool leon3_accat_trap::SRA_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SRA_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::SRA_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::SRA_imm::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::SRA_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SRA_imm::lockRegs_regs(){

}

bool leon3_accat_trap::SRA_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SRA_imm::lockRegs_execute(){

}

bool leon3_accat_trap::SRA_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SRA_imm::lockRegs_memory(){

}

bool leon3_accat_trap::SRA_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SRA_imm::lockRegs_exception(){

}

bool leon3_accat_trap::SRA_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SRA_imm::lockRegs_wb(){

}

void leon3_accat_trap::SRA_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::SRA_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::SRA_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::SRA_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::SRA_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::SRA_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::SRA_imm::replicate() const throw(){
    return new SRA_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::SRA_imm::getInstructionName() const throw(){
    return "SRA_imm";
}

unsigned int leon3_accat_trap::SRA_imm::getId() const throw(){
    return 65;
}

void leon3_accat_trap::SRA_imm::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::SRA_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "sra r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::SRA_imm::SRA_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::SRA_imm::~SRA_imm(){

}
unsigned int leon3_accat_trap::LDSH_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch
    #define rd rd_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSH_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rs1 rs1_decode
    #define rs2 rs2_decode
    #define rd rd_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSH_reg::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs
    #define rd rd_regs


    address = rs1 + rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSH_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute
    #define rd rd_execute


    notAligned = (address & 0x00000001) != 0;
    #ifdef ACC_MODEL
    if(notAligned){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSH_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_memory
    #define WIM WIM_memory
    #define TBR TBR_memory
    #define Y Y_memory
    #define PC PC_memory
    #define NPC NPC_memory
    #define GLOBAL GLOBAL_memory
    #define WINREGS WINREGS_memory
    #define ASR ASR_memory
    #define FP FP_memory
    #define LR LR_memory
    #define SP SP_memory
    #define PCR PCR_memory
    #define REGS REGS_memory
    #define rs1 rs1_memory
    #define rs2 rs2_memory
    #define rd rd_memory


    if(!notAligned){
        readValue = SignExtend(dataMem.read_half(address), 16);
    }
    #ifdef ACC_MODEL
    else{
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSH_reg::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rs1 rs1_exception
    #define rs2 rs2_exception
    #define rd rd_exception


    if(notAligned){
        RaiseException(pcounter, npcounter, MEM_ADDR_NOT_ALIGNED);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSH_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb
    #define rd rd_wb


    rd = readValue;
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

std::string leon3_accat_trap::LDSH_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::LDSH_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSH_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::LDSH_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::LDSH_reg::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::LDSH_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSH_reg::lockRegs_regs(){

}

bool leon3_accat_trap::LDSH_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSH_reg::lockRegs_execute(){

}

bool leon3_accat_trap::LDSH_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSH_reg::lockRegs_memory(){

}

bool leon3_accat_trap::LDSH_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSH_reg::lockRegs_exception(){

}

bool leon3_accat_trap::LDSH_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSH_reg::lockRegs_wb(){

}

void leon3_accat_trap::LDSH_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::LDSH_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::LDSH_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::LDSH_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::LDSH_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::LDSH_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::LDSH_reg::replicate() const throw(){
    return new LDSH_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::LDSH_reg::getInstructionName() const throw(){
    return "LDSH_reg";
}

unsigned int leon3_accat_trap::LDSH_reg::getId() const throw(){
    return 3;
}

void leon3_accat_trap::LDSH_reg::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->asi = (bitString & 0x1fe0) >> 5;
}

std::string leon3_accat_trap::LDSH_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "ldsh r";
    oss << this->rs1_bit;
    oss << "+r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::LDSH_reg::LDSH_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
}

leon3_accat_trap::LDSH_reg::~LDSH_reg(){

}
unsigned int leon3_accat_trap::UDIVcc_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UDIVcc_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rd rd_decode
    #define rs1 rs1_decode
    #define rs2 rs2_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UDIVcc_reg::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    rs1_op = rs1;
    rs2_op = rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UDIVcc_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    exception = rs2_op == 0;
    if(!exception){
        #ifndef ACC_MODEL
        unsigned long long res64 = ((unsigned long long)((((unsigned long long)Y) << 32) \
            | (unsigned long long)rs1_op))/(unsigned long long)rs2_op;
        #else
        unsigned long long res64 = ((unsigned long long)((((unsigned long long)Y_execute) \
            << 32) | (unsigned long long)rs1_op))/(unsigned long long)rs2_op;
        #endif
        temp_V = (res64 & 0xFFFFFFFF00000000LL) != 0;
        if(temp_V){
            result = 0xFFFFFFFF;
        }
        else{
            result = (unsigned int)(res64 & 0x00000000FFFFFFFFLL);
        }
    }
    stall(35);


    if(!exception){
        PSR[key_ICC_n] = ((result & 0x80000000) >> 31);
        PSR[key_ICC_z] = (result == 0);
        PSR[key_ICC_v] = temp_V;
        PSR[key_ICC_c] = 0;
    }
    unlockQueue[0].push_back(&PSR_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UDIVcc_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UDIVcc_reg::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rd rd_exception
    #define rs1 rs1_exception
    #define rs2 rs2_exception


    if(exception){
        RaiseException(pcounter, npcounter, DIV_ZERO);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UDIVcc_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[33].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::UDIVcc_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    if(this->Y_decode.isLocked()){
        retVal += "Y - ";
    }
    if(this->PSR_decode.isLocked()){
        retVal += "PSR - ";
    }
    return retVal;
}

bool leon3_accat_trap::UDIVcc_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UDIVcc_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::UDIVcc_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    regLocked = this->Y_execute.isLocked() || regLocked;
    regLocked = this->PSR_execute.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::UDIVcc_reg::lockRegs_decode(){
    this->rd_decode.lock();
    this->PSR_pipe.lock();
}

bool leon3_accat_trap::UDIVcc_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UDIVcc_reg::lockRegs_regs(){

}

bool leon3_accat_trap::UDIVcc_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UDIVcc_reg::lockRegs_execute(){

}

bool leon3_accat_trap::UDIVcc_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UDIVcc_reg::lockRegs_memory(){

}

bool leon3_accat_trap::UDIVcc_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UDIVcc_reg::lockRegs_exception(){

}

bool leon3_accat_trap::UDIVcc_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UDIVcc_reg::lockRegs_wb(){

}

void leon3_accat_trap::UDIVcc_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::UDIVcc_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::UDIVcc_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::UDIVcc_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::UDIVcc_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::UDIVcc_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::UDIVcc_reg::replicate() const throw(){
    return new UDIVcc_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::UDIVcc_reg::getInstructionName() const throw(){
    return "UDIVcc_reg";
}

unsigned int leon3_accat_trap::UDIVcc_reg::getId() const throw(){
    return 110;
}

void leon3_accat_trap::UDIVcc_reg::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
}

std::string leon3_accat_trap::UDIVcc_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "udivcc";
    oss << " r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::UDIVcc_reg::UDIVcc_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::UDIVcc_reg::~UDIVcc_reg(){

}
unsigned int leon3_accat_trap::ORN_imm::behavior_fetch( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ORN_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ORN_imm::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs


    rs1_op = rs1;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ORN_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute


    result = rs1_op | ~(SignExtend(simm13, 13));

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ORN_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ORN_imm::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ORN_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::ORN_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    return retVal;
}

bool leon3_accat_trap::ORN_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ORN_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::ORN_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::ORN_imm::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::ORN_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ORN_imm::lockRegs_regs(){

}

bool leon3_accat_trap::ORN_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ORN_imm::lockRegs_execute(){

}

bool leon3_accat_trap::ORN_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ORN_imm::lockRegs_memory(){

}

bool leon3_accat_trap::ORN_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ORN_imm::lockRegs_exception(){

}

bool leon3_accat_trap::ORN_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ORN_imm::lockRegs_wb(){

}

void leon3_accat_trap::ORN_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::ORN_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::ORN_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::ORN_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::ORN_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::ORN_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::ORN_imm::replicate() const throw(){
    return new ORN_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::ORN_imm::getInstructionName() const throw(){
    return "ORN_imm";
}

unsigned int leon3_accat_trap::ORN_imm::getId() const throw(){
    return 49;
}

void leon3_accat_trap::ORN_imm::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::ORN_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "orn r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::ORN_imm::ORN_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::ORN_imm::~ORN_imm(){

}
unsigned int leon3_accat_trap::STD_reg::behavior_fetch( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch
    #define rd rd_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STD_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rs1 rs1_decode
    #define rs2 rs2_decode
    #define rd rd_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STD_reg::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs
    #define rd rd_regs

    address = rs1 + rs2;
    if(rd_bit % 2 == 0){
        toWrite = rd | (((unsigned long long)REGS[rd_bit + 1]) << 32);
    }
    else{
        toWrite = REGS[rd_bit - 1] | (((unsigned long long)rd) << 32);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STD_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute
    #define rd rd_execute


    notAligned = (address & 0x00000007) != 0;
    #ifdef ACC_MODEL
    if(notAligned){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STD_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_memory
    #define WIM WIM_memory
    #define TBR TBR_memory
    #define Y Y_memory
    #define PC PC_memory
    #define NPC NPC_memory
    #define GLOBAL GLOBAL_memory
    #define WINREGS WINREGS_memory
    #define ASR ASR_memory
    #define FP FP_memory
    #define LR LR_memory
    #define SP SP_memory
    #define PCR PCR_memory
    #define REGS REGS_memory
    #define rs1 rs1_memory
    #define rs2 rs2_memory
    #define rd rd_memory


    if(!notAligned){
        dataMem.write_dword(address, toWrite);
    }
    else{
        flush();
    }
    stall(2);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STD_reg::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rs1 rs1_exception
    #define rs2 rs2_exception
    #define rd rd_exception


    if(notAligned){
        RaiseException(pcounter, npcounter, MEM_ADDR_NOT_ALIGNED);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STD_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

std::string leon3_accat_trap::STD_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    if(this->rd_decode.isLocked()){
        retVal += "rd - ";
    }
    return retVal;
}

bool leon3_accat_trap::STD_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STD_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::STD_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    regLocked = this->rd_decode.isLocked() || regLocked;
    regLocked = REGS_decode[rd_bit ^ 0x1].isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::STD_reg::lockRegs_decode(){

}

bool leon3_accat_trap::STD_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STD_reg::lockRegs_regs(){

}

bool leon3_accat_trap::STD_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STD_reg::lockRegs_execute(){

}

bool leon3_accat_trap::STD_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STD_reg::lockRegs_memory(){

}

bool leon3_accat_trap::STD_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STD_reg::lockRegs_exception(){

}

bool leon3_accat_trap::STD_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STD_reg::lockRegs_wb(){

}

void leon3_accat_trap::STD_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STD_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STD_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STD_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STD_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STD_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

Instruction * leon3_accat_trap::STD_reg::replicate() const throw(){
    return new STD_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::STD_reg::getInstructionName() const throw(){
    return "STD_reg";
}

unsigned int leon3_accat_trap::STD_reg::getId() const throw(){
    return 25;
}

void leon3_accat_trap::STD_reg::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->asi = (bitString & 0x1fe0) >> 5;
}

std::string leon3_accat_trap::STD_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "std r";
    oss << this->rd_bit;
    oss << " r";
    oss << this->rs1_bit;
    oss << "+r";
    oss << this->rs2_bit;
    return oss.str();
}

leon3_accat_trap::STD_reg::STD_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
}

leon3_accat_trap::STD_reg::~STD_reg(){

}
unsigned int leon3_accat_trap::ANDNcc_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ANDNcc_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ANDNcc_imm::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs


    rs1_op = rs1;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ANDNcc_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute


    result = rs1_op & ~(SignExtend(simm13, 13));


    PSR[key_ICC_n] = ((result & 0x80000000) >> 31);
    PSR[key_ICC_z] = (result == 0);
    PSR[key_ICC_v] = 0;
    PSR[key_ICC_c] = 0;
    unlockQueue[0].push_back(&PSR_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ANDNcc_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ANDNcc_imm::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ANDNcc_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::ANDNcc_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    return retVal;
}

bool leon3_accat_trap::ANDNcc_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ANDNcc_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::ANDNcc_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::ANDNcc_imm::lockRegs_decode(){
    this->rd_decode.lock();
    this->PSR_pipe.lock();
}

bool leon3_accat_trap::ANDNcc_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ANDNcc_imm::lockRegs_regs(){

}

bool leon3_accat_trap::ANDNcc_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ANDNcc_imm::lockRegs_execute(){

}

bool leon3_accat_trap::ANDNcc_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ANDNcc_imm::lockRegs_memory(){

}

bool leon3_accat_trap::ANDNcc_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ANDNcc_imm::lockRegs_exception(){

}

bool leon3_accat_trap::ANDNcc_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ANDNcc_imm::lockRegs_wb(){

}

void leon3_accat_trap::ANDNcc_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::ANDNcc_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::ANDNcc_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::ANDNcc_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::ANDNcc_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::ANDNcc_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::ANDNcc_imm::replicate() const throw(){
    return new ANDNcc_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::ANDNcc_imm::getInstructionName() const throw(){
    return "ANDNcc_imm";
}

unsigned int leon3_accat_trap::ANDNcc_imm::getId() const throw(){
    return 43;
}

void leon3_accat_trap::ANDNcc_imm::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::ANDNcc_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "andncc r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::ANDNcc_imm::ANDNcc_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::ANDNcc_imm::~ANDNcc_imm(){

}
unsigned int leon3_accat_trap::TADDccTV_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TADDccTV_imm::behavior_decode( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rd rd_decode
    #define rs1 rs1_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TADDccTV_imm::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs


    rs1_op = rs1;
    rs2_op = SignExtend(simm13, 13);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TADDccTV_imm::behavior_execute( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute


    result = rs1_op + rs2_op;
    temp_V = ((unsigned int)((rs1_op & rs2_op & (~result)) | ((~rs1_op) & (~rs2_op) & \
        result))) >> 31;
    if(!temp_V && (((rs1_op | rs2_op) & 0x00000003) != 0)){
        temp_V = 1;
    }


    if(!temp_V){
        PSR[key_ICC_n] = ((result & 0x80000000) >> 31);
        PSR[key_ICC_z] = (result == 0);
        PSR[key_ICC_v] = 0;
        PSR[key_ICC_c] = ((unsigned int)((rs1_op & rs2_op) | ((rs1_op | rs2_op) & (~result)))) \
            >> 31;
    }
    unlockQueue[0].push_back(&PSR_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TADDccTV_imm::behavior_memory( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TADDccTV_imm::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rd rd_exception
    #define rs1 rs1_exception


    if(temp_V){
        RaiseException(pcounter, npcounter, TAG_OVERFLOW);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TADDccTV_imm::behavior_wb( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb

    {


        if(!temp_V){
            rd = result;
        }
    }
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::TADDccTV_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    return retVal;
}

bool leon3_accat_trap::TADDccTV_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TADDccTV_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::TADDccTV_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::TADDccTV_imm::lockRegs_decode(){
    this->rd_decode.lock();
    this->PSR_pipe.lock();
}

bool leon3_accat_trap::TADDccTV_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TADDccTV_imm::lockRegs_regs(){

}

bool leon3_accat_trap::TADDccTV_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TADDccTV_imm::lockRegs_execute(){

}

bool leon3_accat_trap::TADDccTV_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TADDccTV_imm::lockRegs_memory(){

}

bool leon3_accat_trap::TADDccTV_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TADDccTV_imm::lockRegs_exception(){

}

bool leon3_accat_trap::TADDccTV_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TADDccTV_imm::lockRegs_wb(){

}

void leon3_accat_trap::TADDccTV_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::TADDccTV_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::TADDccTV_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::TADDccTV_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::TADDccTV_imm::getUnlock_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::TADDccTV_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::TADDccTV_imm::replicate() const throw(){
    return new TADDccTV_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, \
        GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, \
        NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, \
        PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::TADDccTV_imm::getInstructionName() const throw(){
    return "TADDccTV_imm";
}

unsigned int leon3_accat_trap::TADDccTV_imm::getId() const throw(){
    return 77;
}

void leon3_accat_trap::TADDccTV_imm::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::TADDccTV_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "taddcctv r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::TADDccTV_imm::TADDccTV_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::TADDccTV_imm::~TADDccTV_imm(){

}
unsigned int leon3_accat_trap::WRITEtbr_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEtbr_reg::behavior_decode( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rs1 rs1_decode
    #define rs2 rs2_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEtbr_reg::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    result = rs1 ^ rs2;
    raiseException = (PSR[key_S] == 0);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEtbr_reg::behavior_execute( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEtbr_reg::behavior_memory( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEtbr_reg::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rs1 rs1_exception
    #define rs2 rs2_exception


    if(raiseException){
        RaiseException(pcounter, npcounter, PRIVILEDGE_INSTR);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEtbr_reg::behavior_wb( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb


    if(!raiseException){
        TBR |= (result & 0xFFFFF000);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::WRITEtbr_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::WRITEtbr_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEtbr_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::WRITEtbr_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::WRITEtbr_reg::lockRegs_decode(){

}

bool leon3_accat_trap::WRITEtbr_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEtbr_reg::lockRegs_regs(){

}

bool leon3_accat_trap::WRITEtbr_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEtbr_reg::lockRegs_execute(){

}

bool leon3_accat_trap::WRITEtbr_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEtbr_reg::lockRegs_memory(){

}

bool leon3_accat_trap::WRITEtbr_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEtbr_reg::lockRegs_exception(){

}

bool leon3_accat_trap::WRITEtbr_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEtbr_reg::lockRegs_wb(){

}

void leon3_accat_trap::WRITEtbr_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::WRITEtbr_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::WRITEtbr_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::WRITEtbr_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::WRITEtbr_reg::getUnlock_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){

}

void leon3_accat_trap::WRITEtbr_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

Instruction * leon3_accat_trap::WRITEtbr_reg::replicate() const throw(){
    return new WRITEtbr_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, \
        GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, \
        NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, \
        PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::WRITEtbr_reg::getInstructionName() const throw(){
    return "WRITEtbr_reg";
}

unsigned int leon3_accat_trap::WRITEtbr_reg::getId() const throw(){
    return 138;
}

void leon3_accat_trap::WRITEtbr_reg::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
    this->rd = (bitString & 0x3e000000) >> 25;
}

std::string leon3_accat_trap::WRITEtbr_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "wr r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << " tbr";
    return oss.str();
}

leon3_accat_trap::WRITEtbr_reg::WRITEtbr_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::WRITEtbr_reg::~WRITEtbr_reg(){

}
unsigned int leon3_accat_trap::SUBX_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUBX_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUBX_reg::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    rs1_op = rs1;
    rs2_op = rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUBX_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    #ifndef ACC_MODEL
    result = rs1_op - rs2_op - PSR[key_ICC_c];
    #else
    result = rs1_op - rs2_op - PSR_execute[key_ICC_c];
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUBX_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUBX_reg::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUBX_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::SUBX_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    if(this->PSR_decode.isLocked()){
        retVal += "PSR - ";
    }
    return retVal;
}

bool leon3_accat_trap::SUBX_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUBX_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::SUBX_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    regLocked = this->PSR_execute.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::SUBX_reg::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::SUBX_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUBX_reg::lockRegs_regs(){

}

bool leon3_accat_trap::SUBX_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUBX_reg::lockRegs_execute(){

}

bool leon3_accat_trap::SUBX_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUBX_reg::lockRegs_memory(){

}

bool leon3_accat_trap::SUBX_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUBX_reg::lockRegs_exception(){

}

bool leon3_accat_trap::SUBX_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUBX_reg::lockRegs_wb(){

}

void leon3_accat_trap::SUBX_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::SUBX_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::SUBX_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::SUBX_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::SUBX_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::SUBX_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::SUBX_reg::replicate() const throw(){
    return new SUBX_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::SUBX_reg::getInstructionName() const throw(){
    return "SUBX_reg";
}

unsigned int leon3_accat_trap::SUBX_reg::getId() const throw(){
    return 84;
}

void leon3_accat_trap::SUBX_reg::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
}

std::string leon3_accat_trap::SUBX_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "subx r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::SUBX_reg::SUBX_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::SUBX_reg::~SUBX_reg(){

}
unsigned int leon3_accat_trap::XNOR_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XNOR_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XNOR_imm::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs


    rs1_op = rs1;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XNOR_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute


    result = rs1_op ^ ~(SignExtend(simm13, 13));

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XNOR_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XNOR_imm::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XNOR_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::XNOR_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    return retVal;
}

bool leon3_accat_trap::XNOR_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XNOR_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::XNOR_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::XNOR_imm::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::XNOR_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XNOR_imm::lockRegs_regs(){

}

bool leon3_accat_trap::XNOR_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XNOR_imm::lockRegs_execute(){

}

bool leon3_accat_trap::XNOR_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XNOR_imm::lockRegs_memory(){

}

bool leon3_accat_trap::XNOR_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XNOR_imm::lockRegs_exception(){

}

bool leon3_accat_trap::XNOR_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XNOR_imm::lockRegs_wb(){

}

void leon3_accat_trap::XNOR_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::XNOR_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::XNOR_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::XNOR_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::XNOR_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::XNOR_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::XNOR_imm::replicate() const throw(){
    return new XNOR_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::XNOR_imm::getInstructionName() const throw(){
    return "XNOR_imm";
}

unsigned int leon3_accat_trap::XNOR_imm::getId() const throw(){
    return 57;
}

void leon3_accat_trap::XNOR_imm::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::XNOR_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "xnor r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::XNOR_imm::XNOR_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::XNOR_imm::~XNOR_imm(){

}
unsigned int leon3_accat_trap::UDIV_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UDIV_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rd rd_decode
    #define rs1 rs1_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UDIV_imm::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs


    rs1_op = rs1;
    rs2_op = SignExtend(simm13, 13);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UDIV_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute


    exception = rs2_op == 0;
    if(!exception){
        #ifndef ACC_MODEL
        unsigned long long res64 = ((unsigned long long)((((unsigned long long)Y) << 32) \
            | (unsigned long long)rs1_op))/(unsigned long long)rs2_op;
        #else
        unsigned long long res64 = ((unsigned long long)((((unsigned long long)Y_execute) \
            << 32) | (unsigned long long)rs1_op))/(unsigned long long)rs2_op;
        #endif
        temp_V = (res64 & 0xFFFFFFFF00000000LL) != 0;
        if(temp_V){
            result = 0xFFFFFFFF;
        }
        else{
            result = (unsigned int)(res64 & 0x00000000FFFFFFFFLL);
        }
    }
    stall(35);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UDIV_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UDIV_imm::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rd rd_exception
    #define rs1 rs1_exception


    if(exception){
        RaiseException(pcounter, npcounter, DIV_ZERO);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UDIV_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb

    {


        rd = result;
    }
    unlockQueue[33].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::UDIV_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->Y_decode.isLocked()){
        retVal += "Y - ";
    }
    return retVal;
}

bool leon3_accat_trap::UDIV_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UDIV_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::UDIV_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->Y_execute.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::UDIV_imm::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::UDIV_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UDIV_imm::lockRegs_regs(){

}

bool leon3_accat_trap::UDIV_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UDIV_imm::lockRegs_execute(){

}

bool leon3_accat_trap::UDIV_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UDIV_imm::lockRegs_memory(){

}

bool leon3_accat_trap::UDIV_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UDIV_imm::lockRegs_exception(){

}

bool leon3_accat_trap::UDIV_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UDIV_imm::lockRegs_wb(){

}

void leon3_accat_trap::UDIV_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::UDIV_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::UDIV_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::UDIV_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::UDIV_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::UDIV_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::UDIV_imm::replicate() const throw(){
    return new UDIV_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::UDIV_imm::getInstructionName() const throw(){
    return "UDIV_imm";
}

unsigned int leon3_accat_trap::UDIV_imm::getId() const throw(){
    return 105;
}

void leon3_accat_trap::UDIV_imm::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::UDIV_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "udiv";
    oss << " r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::UDIV_imm::UDIV_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::UDIV_imm::~UDIV_imm(){

}
unsigned int leon3_accat_trap::LDSH_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch
    #define rd rd_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSH_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rs1 rs1_decode
    #define rd rd_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSH_imm::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs
    #define rd rd_regs


    address = rs1 + SignExtend(simm13, 13);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSH_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rs1 rs1_execute
    #define rd rd_execute


    notAligned = (address & 0x00000001) != 0;
    #ifdef ACC_MODEL
    if(notAligned){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSH_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_memory
    #define WIM WIM_memory
    #define TBR TBR_memory
    #define Y Y_memory
    #define PC PC_memory
    #define NPC NPC_memory
    #define GLOBAL GLOBAL_memory
    #define WINREGS WINREGS_memory
    #define ASR ASR_memory
    #define FP FP_memory
    #define LR LR_memory
    #define SP SP_memory
    #define PCR PCR_memory
    #define REGS REGS_memory
    #define rs1 rs1_memory
    #define rd rd_memory


    if(!notAligned){
        readValue = SignExtend(dataMem.read_half(address), 16);
    }
    #ifdef ACC_MODEL
    else{
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSH_imm::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rs1 rs1_exception
    #define rd rd_exception


    if(notAligned){
        RaiseException(pcounter, npcounter, MEM_ADDR_NOT_ALIGNED);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSH_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rs1 rs1_wb
    #define rd rd_wb


    rd = readValue;
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

std::string leon3_accat_trap::LDSH_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    return retVal;
}

bool leon3_accat_trap::LDSH_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSH_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::LDSH_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::LDSH_imm::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::LDSH_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSH_imm::lockRegs_regs(){

}

bool leon3_accat_trap::LDSH_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSH_imm::lockRegs_execute(){

}

bool leon3_accat_trap::LDSH_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSH_imm::lockRegs_memory(){

}

bool leon3_accat_trap::LDSH_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSH_imm::lockRegs_exception(){

}

bool leon3_accat_trap::LDSH_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSH_imm::lockRegs_wb(){

}

void leon3_accat_trap::LDSH_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::LDSH_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::LDSH_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::LDSH_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::LDSH_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::LDSH_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::LDSH_imm::replicate() const throw(){
    return new LDSH_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::LDSH_imm::getInstructionName() const throw(){
    return "LDSH_imm";
}

unsigned int leon3_accat_trap::LDSH_imm::getId() const throw(){
    return 2;
}

void leon3_accat_trap::LDSH_imm::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::LDSH_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "ldsh r";
    oss << this->rs1_bit;
    oss << "+";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::LDSH_imm::LDSH_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
}

leon3_accat_trap::LDSH_imm::~LDSH_imm(){

}
unsigned int leon3_accat_trap::UNIMP::behavior_fetch( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UNIMP::behavior_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rd rd_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UNIMP::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UNIMP::behavior_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UNIMP::behavior_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UNIMP::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rd rd_exception


    RaiseException(pcounter, npcounter, ILLEGAL_INSTR);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UNIMP::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

std::string leon3_accat_trap::UNIMP::printBusyRegs(){
    std::string retVal = "";
    return retVal;
}

bool leon3_accat_trap::UNIMP::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UNIMP::lockRegs_fetch(){

}

bool leon3_accat_trap::UNIMP::checkHazard_decode(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UNIMP::lockRegs_decode(){

}

bool leon3_accat_trap::UNIMP::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UNIMP::lockRegs_regs(){

}

bool leon3_accat_trap::UNIMP::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UNIMP::lockRegs_execute(){

}

bool leon3_accat_trap::UNIMP::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UNIMP::lockRegs_memory(){

}

bool leon3_accat_trap::UNIMP::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UNIMP::lockRegs_exception(){

}

bool leon3_accat_trap::UNIMP::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UNIMP::lockRegs_wb(){

}

void leon3_accat_trap::UNIMP::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::UNIMP::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::UNIMP::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::UNIMP::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::UNIMP::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::UNIMP::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

Instruction * leon3_accat_trap::UNIMP::replicate() const throw(){
    return new UNIMP(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::UNIMP::getInstructionName() const throw(){
    return "UNIMP";
}

unsigned int leon3_accat_trap::UNIMP::getId() const throw(){
    return 141;
}

void leon3_accat_trap::UNIMP::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->imm22 = (bitString & 0x3fffff);
}

std::string leon3_accat_trap::UNIMP::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "unimp ";
    oss << this->imm22;
    return oss.str();
}

leon3_accat_trap::UNIMP::UNIMP( PipelineRegister & PSR_pipe, PipelineRegister & WIM_pipe, \
    PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister & PC_pipe, \
    PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister * WINREGS_pipe, \
    PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, Reg32_2 & \
    TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, RegisterBankClass \
    & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias & FP_fetch, Alias \
    & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, Reg32_0 & PSR_decode, \
    Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, Reg32_3 & PC_decode, \
    Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 * WINREGS_decode, \
    Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias & SP_decode, Alias \
    & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 & WIM_regs, Reg32_2 \
    & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, RegisterBankClass \
    & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias & FP_regs, Alias \
    & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, Reg32_0 & PSR_execute, \
    Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, Reg32_3 & PC_execute, \
    Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, Reg32_3 * WINREGS_execute, \
    Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, Alias & SP_execute, \
    Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, Reg32_1 & WIM_memory, \
    Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, Reg32_3 & NPC_memory, \
    RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, Reg32_3 * ASR_memory, \
    Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias & PCR_memory, Alias \
    * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, Reg32_2 & TBR_exception, \
    Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & NPC_exception, RegisterBankClass \
    & GLOBAL_exception, Reg32_3 * WINREGS_exception, Reg32_3 * ASR_exception, Alias & \
    FP_exception, Alias & LR_exception, Alias & SP_exception, Alias & PCR_exception, \
    Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, Reg32_2 & TBR_wb, Reg32_3 \
    & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass & GLOBAL_wb, Reg32_3 \
    * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, Alias & SP_wb, Alias \
    & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & dataMem, PinTLM_out_32 \
    & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, \
    GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, \
    NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, \
    PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
    GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
    REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
    WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
    WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
    ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
    WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
    ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
    WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
    WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
    REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
    ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
}

leon3_accat_trap::UNIMP::~UNIMP(){

}
unsigned int leon3_accat_trap::LDSTUBA_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch
    #define rd rd_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSTUBA_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rs1 rs1_decode
    #define rs2 rs2_decode
    #define rd rd_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSTUBA_reg::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs
    #define rd rd_regs


    address = rs1 + rs2;
    supervisor = PSR[key_S];

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSTUBA_reg::behavior_execute( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute
    #define rd rd_execute


    #ifdef ACC_MODEL
    if(!supervisor){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSTUBA_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_memory
    #define WIM WIM_memory
    #define TBR TBR_memory
    #define Y Y_memory
    #define PC PC_memory
    #define NPC NPC_memory
    #define GLOBAL GLOBAL_memory
    #define WINREGS WINREGS_memory
    #define ASR ASR_memory
    #define FP FP_memory
    #define LR LR_memory
    #define SP SP_memory
    #define PCR PCR_memory
    #define REGS REGS_memory
    #define rs1 rs1_memory
    #define rs2 rs2_memory
    #define rd rd_memory


    if(supervisor){
        readValue = dataMem.read_byte(address);
        dataMem.write_byte(address, 0xff);
    }
    else{
        flush();
    }
    stall(2);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSTUBA_reg::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rs1 rs1_exception
    #define rs2 rs2_exception
    #define rd rd_exception


    if(!supervisor){
        RaiseException(pcounter, npcounter, PRIVILEDGE_INSTR);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDSTUBA_reg::behavior_wb( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb
    #define rd rd_wb


    rd = readValue;
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

std::string leon3_accat_trap::LDSTUBA_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::LDSTUBA_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSTUBA_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::LDSTUBA_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::LDSTUBA_reg::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::LDSTUBA_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSTUBA_reg::lockRegs_regs(){

}

bool leon3_accat_trap::LDSTUBA_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSTUBA_reg::lockRegs_execute(){

}

bool leon3_accat_trap::LDSTUBA_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSTUBA_reg::lockRegs_memory(){

}

bool leon3_accat_trap::LDSTUBA_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSTUBA_reg::lockRegs_exception(){

}

bool leon3_accat_trap::LDSTUBA_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDSTUBA_reg::lockRegs_wb(){

}

void leon3_accat_trap::LDSTUBA_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::LDSTUBA_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::LDSTUBA_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::LDSTUBA_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::LDSTUBA_reg::getUnlock_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::LDSTUBA_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::LDSTUBA_reg::replicate() const throw(){
    return new LDSTUBA_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::LDSTUBA_reg::getInstructionName() const throw(){
    return "LDSTUBA_reg";
}

unsigned int leon3_accat_trap::LDSTUBA_reg::getId() const throw(){
    return 32;
}

void leon3_accat_trap::LDSTUBA_reg::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->asi = (bitString & 0x1fe0) >> 5;
}

std::string leon3_accat_trap::LDSTUBA_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "ldastub r";
    oss << this->rs1_bit;
    oss << "+r";
    oss << this->rs2_bit;
    oss << " ";
    oss << this->asi;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::LDSTUBA_reg::LDSTUBA_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
}

leon3_accat_trap::LDSTUBA_reg::~LDSTUBA_reg(){

}
unsigned int leon3_accat_trap::UMULcc_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UMULcc_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UMULcc_imm::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs


    rs1_op = rs1;
    rs2_op = SignExtend(simm13, 13);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UMULcc_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute


    unsigned long long resultTemp = (unsigned long long)(((unsigned long long)((unsigned \
        int)rs1_op))*((unsigned long long)((unsigned int)rs2_op)));
    Y = resultTemp >> 32;
    result = resultTemp & 0x00000000FFFFFFFF;
    stall(2);


    PSR[key_ICC_n] = ((result & 0x80000000) >> 31);
    PSR[key_ICC_z] = (result == 0);
    PSR[key_ICC_v] = 0;
    PSR[key_ICC_c] = 0;
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&PSR_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UMULcc_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UMULcc_imm::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UMULcc_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[2].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::UMULcc_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    return retVal;
}

bool leon3_accat_trap::UMULcc_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UMULcc_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::UMULcc_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::UMULcc_imm::lockRegs_decode(){
    this->rd_decode.lock();
    this->Y_pipe.lock();
    this->PSR_pipe.lock();
}

bool leon3_accat_trap::UMULcc_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UMULcc_imm::lockRegs_regs(){

}

bool leon3_accat_trap::UMULcc_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UMULcc_imm::lockRegs_execute(){

}

bool leon3_accat_trap::UMULcc_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UMULcc_imm::lockRegs_memory(){

}

bool leon3_accat_trap::UMULcc_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UMULcc_imm::lockRegs_exception(){

}

bool leon3_accat_trap::UMULcc_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UMULcc_imm::lockRegs_wb(){

}

void leon3_accat_trap::UMULcc_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::UMULcc_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::UMULcc_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::UMULcc_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::UMULcc_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::UMULcc_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::UMULcc_imm::replicate() const throw(){
    return new UMULcc_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::UMULcc_imm::getInstructionName() const throw(){
    return "UMULcc_imm";
}

unsigned int leon3_accat_trap::UMULcc_imm::getId() const throw(){
    return 97;
}

void leon3_accat_trap::UMULcc_imm::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::UMULcc_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "umulcc r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::UMULcc_imm::UMULcc_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::UMULcc_imm::~UMULcc_imm(){

}
unsigned int leon3_accat_trap::ORcc_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ORcc_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ORcc_reg::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    rs1_op = rs1;
    rs2_op = rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ORcc_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    result = rs1_op | rs2_op;


    PSR[key_ICC_n] = ((result & 0x80000000) >> 31);
    PSR[key_ICC_z] = (result == 0);
    PSR[key_ICC_v] = 0;
    PSR[key_ICC_c] = 0;
    unlockQueue[0].push_back(&PSR_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ORcc_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ORcc_reg::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ORcc_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::ORcc_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::ORcc_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ORcc_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::ORcc_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::ORcc_reg::lockRegs_decode(){
    this->rd_decode.lock();
    this->PSR_pipe.lock();
}

bool leon3_accat_trap::ORcc_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ORcc_reg::lockRegs_regs(){

}

bool leon3_accat_trap::ORcc_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ORcc_reg::lockRegs_execute(){

}

bool leon3_accat_trap::ORcc_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ORcc_reg::lockRegs_memory(){

}

bool leon3_accat_trap::ORcc_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ORcc_reg::lockRegs_exception(){

}

bool leon3_accat_trap::ORcc_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ORcc_reg::lockRegs_wb(){

}

void leon3_accat_trap::ORcc_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::ORcc_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::ORcc_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::ORcc_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::ORcc_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::ORcc_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::ORcc_reg::replicate() const throw(){
    return new ORcc_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::ORcc_reg::getInstructionName() const throw(){
    return "ORcc_reg";
}

unsigned int leon3_accat_trap::ORcc_reg::getId() const throw(){
    return 48;
}

void leon3_accat_trap::ORcc_reg::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
}

std::string leon3_accat_trap::ORcc_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "orcc r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::ORcc_reg::ORcc_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::ORcc_reg::~ORcc_reg(){

}
unsigned int leon3_accat_trap::MULScc_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::MULScc_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::MULScc_imm::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs


    rs1_op = rs1;
    rs2_op = SignExtend(simm13, 13);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::MULScc_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute


    #ifndef ACC_MODEL
    unsigned int yNew = (((unsigned int)Y) >> 1) | (rs1_op << 31);
    #else
    unsigned int yNew = (((unsigned int)Y_execute) >> 1) | (rs1_op << 31);
    #endif
    rs1_op = ((PSR[key_ICC_n] ^ PSR[key_ICC_v]) << 31) | (((unsigned int)rs1_op) >> 1);
    result = rs1_op;
    #ifndef ACC_MODEL
    unsigned int yOld = Y;
    #else
    unsigned int yOld = Y_execute;
    #endif
    if((yOld & 0x00000001) != 0){
        result += rs2_op;
    }
    else{
        rs2_op = 0;
    }
    Y = yNew;


    PSR[key_ICC_n] = ((result & 0x80000000) >> 31);
    PSR[key_ICC_z] = (result == 0);
    PSR[key_ICC_v] = ((unsigned int)((rs1_op & rs2_op & (~result)) | ((~rs1_op) & (~rs2_op) \
        & result))) >> 31;
    PSR[key_ICC_c] = ((unsigned int)((rs1_op & rs2_op) | ((rs1_op | rs2_op) & (~result)))) \
        >> 31;
    unlockQueue[0].push_back(&Y_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::MULScc_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::MULScc_imm::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::MULScc_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::MULScc_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->PSR_decode.isLocked()){
        retVal += "PSR - ";
    }
    if(this->Y_decode.isLocked()){
        retVal += "Y - ";
    }
    return retVal;
}

bool leon3_accat_trap::MULScc_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::MULScc_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::MULScc_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->PSR_decode.isLocked() || regLocked;
    regLocked = this->Y_execute.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::MULScc_imm::lockRegs_decode(){
    this->rd_decode.lock();
    this->Y_pipe.lock();
}

bool leon3_accat_trap::MULScc_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::MULScc_imm::lockRegs_regs(){

}

bool leon3_accat_trap::MULScc_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::MULScc_imm::lockRegs_execute(){

}

bool leon3_accat_trap::MULScc_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::MULScc_imm::lockRegs_memory(){

}

bool leon3_accat_trap::MULScc_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::MULScc_imm::lockRegs_exception(){

}

bool leon3_accat_trap::MULScc_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::MULScc_imm::lockRegs_wb(){

}

void leon3_accat_trap::MULScc_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::MULScc_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::MULScc_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::MULScc_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::MULScc_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::MULScc_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::MULScc_imm::replicate() const throw(){
    return new MULScc_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::MULScc_imm::getInstructionName() const throw(){
    return "MULScc_imm";
}

unsigned int leon3_accat_trap::MULScc_imm::getId() const throw(){
    return 91;
}

void leon3_accat_trap::MULScc_imm::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::MULScc_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "mulscc r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::MULScc_imm::MULScc_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::MULScc_imm::~MULScc_imm(){

}
unsigned int leon3_accat_trap::XORcc_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XORcc_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XORcc_reg::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    rs1_op = rs1;
    rs2_op = rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XORcc_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    result = rs1_op ^ rs2_op;


    PSR[key_ICC_n] = ((result & 0x80000000) >> 31);
    PSR[key_ICC_z] = (result == 0);
    PSR[key_ICC_v] = 0;
    PSR[key_ICC_c] = 0;
    unlockQueue[0].push_back(&PSR_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XORcc_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XORcc_reg::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XORcc_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::XORcc_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::XORcc_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XORcc_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::XORcc_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::XORcc_reg::lockRegs_decode(){
    this->rd_decode.lock();
    this->PSR_pipe.lock();
}

bool leon3_accat_trap::XORcc_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XORcc_reg::lockRegs_regs(){

}

bool leon3_accat_trap::XORcc_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XORcc_reg::lockRegs_execute(){

}

bool leon3_accat_trap::XORcc_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XORcc_reg::lockRegs_memory(){

}

bool leon3_accat_trap::XORcc_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XORcc_reg::lockRegs_exception(){

}

bool leon3_accat_trap::XORcc_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XORcc_reg::lockRegs_wb(){

}

void leon3_accat_trap::XORcc_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::XORcc_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::XORcc_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::XORcc_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::XORcc_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::XORcc_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::XORcc_reg::replicate() const throw(){
    return new XORcc_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::XORcc_reg::getInstructionName() const throw(){
    return "XORcc_reg";
}

unsigned int leon3_accat_trap::XORcc_reg::getId() const throw(){
    return 56;
}

void leon3_accat_trap::XORcc_reg::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
}

std::string leon3_accat_trap::XORcc_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "xorcc r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::XORcc_reg::XORcc_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::XORcc_reg::~XORcc_reg(){

}
unsigned int leon3_accat_trap::SUB_reg::behavior_fetch( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUB_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUB_reg::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    rs1_op = rs1;
    rs2_op = rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUB_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    result = rs1_op - rs2_op;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUB_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUB_reg::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUB_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::SUB_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::SUB_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUB_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::SUB_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::SUB_reg::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::SUB_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUB_reg::lockRegs_regs(){

}

bool leon3_accat_trap::SUB_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUB_reg::lockRegs_execute(){

}

bool leon3_accat_trap::SUB_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUB_reg::lockRegs_memory(){

}

bool leon3_accat_trap::SUB_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUB_reg::lockRegs_exception(){

}

bool leon3_accat_trap::SUB_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUB_reg::lockRegs_wb(){

}

void leon3_accat_trap::SUB_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::SUB_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::SUB_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::SUB_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::SUB_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::SUB_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::SUB_reg::replicate() const throw(){
    return new SUB_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::SUB_reg::getInstructionName() const throw(){
    return "SUB_reg";
}

unsigned int leon3_accat_trap::SUB_reg::getId() const throw(){
    return 80;
}

void leon3_accat_trap::SUB_reg::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
}

std::string leon3_accat_trap::SUB_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "sub r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::SUB_reg::SUB_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::SUB_reg::~SUB_reg(){

}
unsigned int leon3_accat_trap::WRITEwim_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEwim_reg::behavior_decode( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rs1 rs1_decode
    #define rs2 rs2_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEwim_reg::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    result = rs1 ^ rs2;
    raiseException = (PSR[key_S] == 0);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEwim_reg::behavior_execute( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEwim_reg::behavior_memory( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEwim_reg::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rs1 rs1_exception
    #define rs2 rs2_exception


    if(raiseException){
        RaiseException(pcounter, npcounter, PRIVILEDGE_INSTR);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEwim_reg::behavior_wb( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb


    if(!raiseException){
        WIM = result & ((unsigned int)0xFFFFFFFF >> (32 - NUM_REG_WIN));
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::WRITEwim_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::WRITEwim_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEwim_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::WRITEwim_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::WRITEwim_reg::lockRegs_decode(){

}

bool leon3_accat_trap::WRITEwim_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEwim_reg::lockRegs_regs(){

}

bool leon3_accat_trap::WRITEwim_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEwim_reg::lockRegs_execute(){

}

bool leon3_accat_trap::WRITEwim_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEwim_reg::lockRegs_memory(){

}

bool leon3_accat_trap::WRITEwim_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEwim_reg::lockRegs_exception(){

}

bool leon3_accat_trap::WRITEwim_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEwim_reg::lockRegs_wb(){

}

void leon3_accat_trap::WRITEwim_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::WRITEwim_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::WRITEwim_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::WRITEwim_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::WRITEwim_reg::getUnlock_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){

}

void leon3_accat_trap::WRITEwim_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

Instruction * leon3_accat_trap::WRITEwim_reg::replicate() const throw(){
    return new WRITEwim_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, \
        GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, \
        NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, \
        PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::WRITEwim_reg::getInstructionName() const throw(){
    return "WRITEwim_reg";
}

unsigned int leon3_accat_trap::WRITEwim_reg::getId() const throw(){
    return 136;
}

void leon3_accat_trap::WRITEwim_reg::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
    this->rd = (bitString & 0x3e000000) >> 25;
}

std::string leon3_accat_trap::WRITEwim_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "wr r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << " wim";
    return oss.str();
}

leon3_accat_trap::WRITEwim_reg::WRITEwim_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::WRITEwim_reg::~WRITEwim_reg(){

}
unsigned int leon3_accat_trap::UMAC_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UMAC_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UMAC_imm::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs


    rs1_op = rs1;
    rs2_op = SignExtend(simm13, 13);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UMAC_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute


    unsigned int resultTemp = ((unsigned int)rs1_op & 0x0000ffff)*((unsigned int)rs2_op \
        & 0x0000ffff);
    #ifndef ACC_MODEL
    unsigned long long resultAcc = ((((unsigned long long)(Y & 0x000000ff)) << 32) | \
        (unsigned int)ASR[18]) + resultTemp;
    #else
    unsigned long long resultAcc = ((((unsigned long long)(Y_execute & 0x000000ff)) << \
        32) | (unsigned int)ASR_execute[18]) + resultTemp;
    #endif
    Y = (resultAcc & 0x000000ff00000000LL) >> 32;
    ASR[18] = resultAcc & 0x00000000FFFFFFFFLL;
    result = resultAcc & 0x00000000FFFFFFFFLL;
    stall(1);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&ASR_execute[18]);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UMAC_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UMAC_imm::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UMAC_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&ASR_fetch[18]);
    unlockQueue[0].push_back(&ASR_decode[18]);
    unlockQueue[0].push_back(&ASR_regs[18]);
    unlockQueue[0].push_back(&ASR_memory[18]);
    unlockQueue[0].push_back(&ASR_exception[18]);
    unlockQueue[0].push_back(&ASR_wb[18]);
    unlockQueue[0].push_back(ASR_pipe[18].getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::UMAC_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->Y_decode.isLocked()){
        retVal += "Y - ";
    }
    if(this->ASR_decode[18].isLocked()){
        retVal += "ASR[18] - ";
    }
    return retVal;
}

bool leon3_accat_trap::UMAC_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UMAC_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::UMAC_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->Y_execute.isLocked() || regLocked;
    regLocked = this->ASR_execute[18].isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::UMAC_imm::lockRegs_decode(){
    this->rd_decode.lock();
    this->Y_pipe.lock();
    this->ASR_pipe[18].lock();
}

bool leon3_accat_trap::UMAC_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UMAC_imm::lockRegs_regs(){

}

bool leon3_accat_trap::UMAC_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UMAC_imm::lockRegs_execute(){

}

bool leon3_accat_trap::UMAC_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UMAC_imm::lockRegs_memory(){

}

bool leon3_accat_trap::UMAC_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UMAC_imm::lockRegs_exception(){

}

bool leon3_accat_trap::UMAC_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UMAC_imm::lockRegs_wb(){

}

void leon3_accat_trap::UMAC_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&ASR_fetch[18]);
    unlockQueue[0].push_back(&ASR_decode[18]);
    unlockQueue[0].push_back(&ASR_regs[18]);
    unlockQueue[0].push_back(&ASR_execute[18]);
    unlockQueue[0].push_back(&ASR_memory[18]);
    unlockQueue[0].push_back(&ASR_exception[18]);
    unlockQueue[0].push_back(&ASR_wb[18]);
    unlockQueue[0].push_back(ASR_pipe[18].getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::UMAC_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&ASR_fetch[18]);
    unlockQueue[0].push_back(&ASR_decode[18]);
    unlockQueue[0].push_back(&ASR_regs[18]);
    unlockQueue[0].push_back(&ASR_execute[18]);
    unlockQueue[0].push_back(&ASR_memory[18]);
    unlockQueue[0].push_back(&ASR_exception[18]);
    unlockQueue[0].push_back(&ASR_wb[18]);
    unlockQueue[0].push_back(ASR_pipe[18].getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::UMAC_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&ASR_fetch[18]);
    unlockQueue[0].push_back(&ASR_decode[18]);
    unlockQueue[0].push_back(&ASR_regs[18]);
    unlockQueue[0].push_back(&ASR_execute[18]);
    unlockQueue[0].push_back(&ASR_memory[18]);
    unlockQueue[0].push_back(&ASR_exception[18]);
    unlockQueue[0].push_back(&ASR_wb[18]);
    unlockQueue[0].push_back(ASR_pipe[18].getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::UMAC_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&ASR_fetch[18]);
    unlockQueue[0].push_back(&ASR_decode[18]);
    unlockQueue[0].push_back(&ASR_regs[18]);
    unlockQueue[0].push_back(&ASR_memory[18]);
    unlockQueue[0].push_back(&ASR_exception[18]);
    unlockQueue[0].push_back(&ASR_wb[18]);
    unlockQueue[0].push_back(ASR_pipe[18].getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::UMAC_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&ASR_fetch[18]);
    unlockQueue[0].push_back(&ASR_decode[18]);
    unlockQueue[0].push_back(&ASR_regs[18]);
    unlockQueue[0].push_back(&ASR_memory[18]);
    unlockQueue[0].push_back(&ASR_exception[18]);
    unlockQueue[0].push_back(&ASR_wb[18]);
    unlockQueue[0].push_back(ASR_pipe[18].getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::UMAC_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&ASR_fetch[18]);
    unlockQueue[0].push_back(&ASR_decode[18]);
    unlockQueue[0].push_back(&ASR_regs[18]);
    unlockQueue[0].push_back(&ASR_memory[18]);
    unlockQueue[0].push_back(&ASR_exception[18]);
    unlockQueue[0].push_back(&ASR_wb[18]);
    unlockQueue[0].push_back(ASR_pipe[18].getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::UMAC_imm::replicate() const throw(){
    return new UMAC_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::UMAC_imm::getInstructionName() const throw(){
    return "UMAC_imm";
}

unsigned int leon3_accat_trap::UMAC_imm::getId() const throw(){
    return 101;
}

void leon3_accat_trap::UMAC_imm::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::UMAC_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "umac r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::UMAC_imm::UMAC_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::UMAC_imm::~UMAC_imm(){

}
unsigned int leon3_accat_trap::TSUBcc_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TSUBcc_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TSUBcc_reg::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    rs1_op = rs1;
    rs2_op = rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TSUBcc_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    result = rs1_op - rs2_op;
    temp_V = ((unsigned int)((rs1_op & (~rs2_op) & (~result)) | ((~rs1_op) & rs2_op & \
        result))) >> 31;
    if(!temp_V && (((rs1_op | rs2_op) & 0x00000003) != 0)){
        temp_V = 1;
    }


    PSR[key_ICC_n] = ((result & 0x80000000) >> 31);
    PSR[key_ICC_z] = (result == 0);
    PSR[key_ICC_v] = temp_V;
    PSR[key_ICC_c] = ((unsigned int)(((~rs1_op) & rs2_op) | (((~rs1_op) | rs2_op) & result))) \
        >> 31;
    unlockQueue[0].push_back(&PSR_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TSUBcc_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TSUBcc_reg::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TSUBcc_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::TSUBcc_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::TSUBcc_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TSUBcc_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::TSUBcc_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::TSUBcc_reg::lockRegs_decode(){
    this->rd_decode.lock();
    this->PSR_pipe.lock();
}

bool leon3_accat_trap::TSUBcc_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TSUBcc_reg::lockRegs_regs(){

}

bool leon3_accat_trap::TSUBcc_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TSUBcc_reg::lockRegs_execute(){

}

bool leon3_accat_trap::TSUBcc_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TSUBcc_reg::lockRegs_memory(){

}

bool leon3_accat_trap::TSUBcc_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TSUBcc_reg::lockRegs_exception(){

}

bool leon3_accat_trap::TSUBcc_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TSUBcc_reg::lockRegs_wb(){

}

void leon3_accat_trap::TSUBcc_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::TSUBcc_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::TSUBcc_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::TSUBcc_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::TSUBcc_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::TSUBcc_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::TSUBcc_reg::replicate() const throw(){
    return new TSUBcc_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::TSUBcc_reg::getInstructionName() const throw(){
    return "TSUBcc_reg";
}

unsigned int leon3_accat_trap::TSUBcc_reg::getId() const throw(){
    return 88;
}

void leon3_accat_trap::TSUBcc_reg::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
}

std::string leon3_accat_trap::TSUBcc_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "tsubcc r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::TSUBcc_reg::TSUBcc_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::TSUBcc_reg::~TSUBcc_reg(){

}
unsigned int leon3_accat_trap::BRANCH::behavior_fetch( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    return this->stageCycles;
}

unsigned int leon3_accat_trap::BRANCH::behavior_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    switch(cond){
        case 0x8:{
            // Branch Always
            unsigned int targetPc = pcounter + 4*(SignExtend(disp22, 22));
            #ifdef ACC_MODEL
            PC = targetPc;
            NPC = targetPc + 4;
            if(a == 1){
                flush();
            }
            #else
            if(a == 1){
                PC = targetPc;
                NPC = targetPc + 4;
            }
            else{
                PC = npcounter;
                NPC = targetPc;
            }
            #endif
        break;}
        case 0:{
            // Branch Never
            #ifdef ACC_MODEL
            if(a == 1){
                flush();
            }
            #else
            if(a == 1){
                PC = npcounter + 4;
                NPC = npcounter + 8;
            }
            else{
                PC = npcounter;
                NPC = npcounter + 4;
            }
            #endif
        break;}
        default:{
            #ifndef ACC_MODEL
            bool icc_z = PSR[key_ICC_z];
            bool icc_n = PSR[key_ICC_n];
            bool icc_v = PSR[key_ICC_v];
            bool icc_c = PSR[key_ICC_c];
            #else
            bool icc_z = PSR_execute[key_ICC_z];
            bool icc_n = PSR_execute[key_ICC_n];
            bool icc_v = PSR_execute[key_ICC_v];
            bool icc_c = PSR_execute[key_ICC_c];
            #endif
            // All the other non-special situations
            bool exec = ((cond == 0x9) && !icc_z) ||
            ((cond == 0x1) && icc_z) ||
            ((cond == 0xa) && !icc_z && (icc_n == icc_v)) ||
            ((cond == 0x2) && (icc_z || (icc_n != icc_v))) ||
            ((cond == 0xb) && (icc_n == icc_v)) ||
            ((cond == 0x3) && (icc_n != icc_v)) ||
            ((cond == 0xc) && !icc_c && !icc_z) ||
            ((cond == 0x4) && (icc_c || icc_z)) ||
            ((cond == 0xd) && !icc_c) ||
            ((cond == 0x5) && icc_c) ||
            ((cond == 0xe) && !icc_n) ||
            ((cond == 0x6) && icc_n) ||
            ((cond == 0xf) && !icc_v) ||
            ((cond == 0x7) && icc_v);
            if(exec){
                unsigned int targetPc = pcounter + 4*(SignExtend(disp22, 22));
                #ifdef ACC_MODEL
                PC = targetPc;
                NPC = targetPc + 4;
                #else
                PC = npcounter;
                NPC = targetPc;
                #endif
            }
            else{
                if(a == 1){
                    #ifdef ACC_MODEL
                    flush();
                    #else
                    PC = npcounter + 4;
                    NPC = npcounter + 8;
                    #endif
                }
                #ifndef ACC_MODEL
                else{
                    PC = npcounter;
                    NPC = npcounter + 4;
                }
                #endif
            }
        break;}
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    return this->stageCycles;
}

unsigned int leon3_accat_trap::BRANCH::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::BRANCH::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::BRANCH::behavior_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::BRANCH::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::BRANCH::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

std::string leon3_accat_trap::BRANCH::printBusyRegs(){
    std::string retVal = "";
    if(this->PSR_decode.isLocked()){
        retVal += "PSR - ";
    }
    return retVal;
}

bool leon3_accat_trap::BRANCH::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::BRANCH::lockRegs_fetch(){

}

bool leon3_accat_trap::BRANCH::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->PSR_execute.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::BRANCH::lockRegs_decode(){

}

bool leon3_accat_trap::BRANCH::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::BRANCH::lockRegs_regs(){

}

bool leon3_accat_trap::BRANCH::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::BRANCH::lockRegs_execute(){

}

bool leon3_accat_trap::BRANCH::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::BRANCH::lockRegs_memory(){

}

bool leon3_accat_trap::BRANCH::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::BRANCH::lockRegs_exception(){

}

bool leon3_accat_trap::BRANCH::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::BRANCH::lockRegs_wb(){

}

void leon3_accat_trap::BRANCH::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::BRANCH::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::BRANCH::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::BRANCH::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::BRANCH::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::BRANCH::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

Instruction * leon3_accat_trap::BRANCH::replicate() const throw(){
    return new BRANCH(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::BRANCH::getInstructionName() const throw(){
    return "BRANCH";
}

unsigned int leon3_accat_trap::BRANCH::getId() const throw(){
    return 117;
}

void leon3_accat_trap::BRANCH::setParams( const unsigned int & bitString ) throw(){
    this->a = (bitString & 0x20000000) >> 29;
    this->cond = (bitString & 0x1e000000) >> 25;
    this->disp22 = (bitString & 0x3fffff);
}

std::string leon3_accat_trap::BRANCH::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "b";
    switch(this->cond){
        case 0:{
            oss << "n";
        break;}
        case 1:{
            oss << "e";
        break;}
        case 2:{
            oss << "le";
        break;}
        case 3:{
            oss << "l";
        break;}
        case 4:{
            oss << "leu";
        break;}
        case 6:{
            oss << "neg";
        break;}
        case 7:{
            oss << "vs";
        break;}
        case 8:{
            oss << "a";
        break;}
        case 9:{
            oss << "ne";
        break;}
        case 10:{
            oss << "cs";
        break;}
        case 11:{
            oss << "ge";
        break;}
        case 12:{
            oss << "gu";
        break;}
        case 13:{
            oss << "cc";
        break;}
        case 14:{
            oss << "pos";
        break;}
        case 15:{
            oss << "vc";
        break;}
        default:
        break;
    }
    switch(this->a){
        case 1:{
            oss << ",a";
        break;}
        default:
        break;
    }
    oss << " ";
    oss << this->disp22;
    return oss.str();
}

leon3_accat_trap::BRANCH::BRANCH( PipelineRegister & PSR_pipe, PipelineRegister & \
    WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){

}

leon3_accat_trap::BRANCH::~BRANCH(){

}
unsigned int leon3_accat_trap::SMULcc_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SMULcc_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SMULcc_reg::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    rs1_op = rs1;
    rs2_op = rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SMULcc_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    long long resultTemp = (long long)(((long long)((int)rs1_op))*((long long)((int)rs2_op)));
    Y = ((unsigned long long)resultTemp) >> 32;
    result = resultTemp & 0x00000000FFFFFFFF;
    stall(2);


    PSR[key_ICC_n] = ((result & 0x80000000) >> 31);
    PSR[key_ICC_z] = (result == 0);
    PSR[key_ICC_v] = 0;
    PSR[key_ICC_c] = 0;
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&PSR_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SMULcc_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SMULcc_reg::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SMULcc_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[2].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::SMULcc_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::SMULcc_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SMULcc_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::SMULcc_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::SMULcc_reg::lockRegs_decode(){
    this->rd_decode.lock();
    this->Y_pipe.lock();
    this->PSR_pipe.lock();
}

bool leon3_accat_trap::SMULcc_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SMULcc_reg::lockRegs_regs(){

}

bool leon3_accat_trap::SMULcc_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SMULcc_reg::lockRegs_execute(){

}

bool leon3_accat_trap::SMULcc_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SMULcc_reg::lockRegs_memory(){

}

bool leon3_accat_trap::SMULcc_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SMULcc_reg::lockRegs_exception(){

}

bool leon3_accat_trap::SMULcc_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SMULcc_reg::lockRegs_wb(){

}

void leon3_accat_trap::SMULcc_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::SMULcc_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::SMULcc_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::SMULcc_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::SMULcc_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::SMULcc_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::SMULcc_reg::replicate() const throw(){
    return new SMULcc_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::SMULcc_reg::getInstructionName() const throw(){
    return "SMULcc_reg";
}

unsigned int leon3_accat_trap::SMULcc_reg::getId() const throw(){
    return 100;
}

void leon3_accat_trap::SMULcc_reg::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
}

std::string leon3_accat_trap::SMULcc_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "smulcc r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::SMULcc_reg::SMULcc_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::SMULcc_reg::~SMULcc_reg(){

}
unsigned int leon3_accat_trap::SUB_imm::behavior_fetch( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUB_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUB_imm::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs


    rs1_op = rs1;
    rs2_op = SignExtend(simm13, 13);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUB_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute


    result = rs1_op - rs2_op;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUB_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUB_imm::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUB_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::SUB_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    return retVal;
}

bool leon3_accat_trap::SUB_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUB_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::SUB_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::SUB_imm::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::SUB_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUB_imm::lockRegs_regs(){

}

bool leon3_accat_trap::SUB_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUB_imm::lockRegs_execute(){

}

bool leon3_accat_trap::SUB_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUB_imm::lockRegs_memory(){

}

bool leon3_accat_trap::SUB_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUB_imm::lockRegs_exception(){

}

bool leon3_accat_trap::SUB_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUB_imm::lockRegs_wb(){

}

void leon3_accat_trap::SUB_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::SUB_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::SUB_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::SUB_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::SUB_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::SUB_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::SUB_imm::replicate() const throw(){
    return new SUB_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::SUB_imm::getInstructionName() const throw(){
    return "SUB_imm";
}

unsigned int leon3_accat_trap::SUB_imm::getId() const throw(){
    return 79;
}

void leon3_accat_trap::SUB_imm::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::SUB_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "sub r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::SUB_imm::SUB_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::SUB_imm::~SUB_imm(){

}
unsigned int leon3_accat_trap::ADDcc_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADDcc_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADDcc_reg::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    rs1_op = rs1;
    rs2_op = rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADDcc_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    result = rs1_op + rs2_op;


    PSR[key_ICC_n] = ((result & 0x80000000) >> 31);
    PSR[key_ICC_z] = (result == 0);
    PSR[key_ICC_v] = ((unsigned int)((rs1_op & rs2_op & (~result)) | ((~rs1_op) & (~rs2_op) \
        & result))) >> 31;
    PSR[key_ICC_c] = ((unsigned int)((rs1_op & rs2_op) | ((rs1_op | rs2_op) & (~result)))) \
        >> 31;
    unlockQueue[0].push_back(&PSR_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADDcc_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADDcc_reg::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADDcc_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::ADDcc_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::ADDcc_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADDcc_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::ADDcc_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::ADDcc_reg::lockRegs_decode(){
    this->rd_decode.lock();
    this->PSR_pipe.lock();
}

bool leon3_accat_trap::ADDcc_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADDcc_reg::lockRegs_regs(){

}

bool leon3_accat_trap::ADDcc_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADDcc_reg::lockRegs_execute(){

}

bool leon3_accat_trap::ADDcc_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADDcc_reg::lockRegs_memory(){

}

bool leon3_accat_trap::ADDcc_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADDcc_reg::lockRegs_exception(){

}

bool leon3_accat_trap::ADDcc_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADDcc_reg::lockRegs_wb(){

}

void leon3_accat_trap::ADDcc_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::ADDcc_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::ADDcc_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::ADDcc_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::ADDcc_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::ADDcc_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::ADDcc_reg::replicate() const throw(){
    return new ADDcc_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::ADDcc_reg::getInstructionName() const throw(){
    return "ADDcc_reg";
}

unsigned int leon3_accat_trap::ADDcc_reg::getId() const throw(){
    return 70;
}

void leon3_accat_trap::ADDcc_reg::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
}

std::string leon3_accat_trap::ADDcc_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "addcc r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::ADDcc_reg::ADDcc_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::ADDcc_reg::~ADDcc_reg(){

}
unsigned int leon3_accat_trap::XOR_reg::behavior_fetch( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XOR_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XOR_reg::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    rs1_op = rs1;
    rs2_op = rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XOR_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    result = rs1_op ^ rs2_op;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XOR_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XOR_reg::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XOR_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::XOR_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::XOR_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XOR_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::XOR_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::XOR_reg::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::XOR_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XOR_reg::lockRegs_regs(){

}

bool leon3_accat_trap::XOR_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XOR_reg::lockRegs_execute(){

}

bool leon3_accat_trap::XOR_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XOR_reg::lockRegs_memory(){

}

bool leon3_accat_trap::XOR_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XOR_reg::lockRegs_exception(){

}

bool leon3_accat_trap::XOR_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XOR_reg::lockRegs_wb(){

}

void leon3_accat_trap::XOR_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::XOR_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::XOR_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::XOR_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::XOR_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::XOR_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::XOR_reg::replicate() const throw(){
    return new XOR_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::XOR_reg::getInstructionName() const throw(){
    return "XOR_reg";
}

unsigned int leon3_accat_trap::XOR_reg::getId() const throw(){
    return 54;
}

void leon3_accat_trap::XOR_reg::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
}

std::string leon3_accat_trap::XOR_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "xor r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::XOR_reg::XOR_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::XOR_reg::~XOR_reg(){

}
unsigned int leon3_accat_trap::SUBcc_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUBcc_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUBcc_imm::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs


    rs1_op = rs1;
    rs2_op = SignExtend(simm13, 13);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUBcc_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute


    result = rs1_op - rs2_op;


    PSR[key_ICC_n] = ((result & 0x80000000) >> 31);
    PSR[key_ICC_z] = (result == 0);
    PSR[key_ICC_v] = ((unsigned int)((rs1_op & (~rs2_op) & (~result)) | ((~rs1_op) & \
        rs2_op & result))) >> 31;
    PSR[key_ICC_c] = ((unsigned int)(((~rs1_op) & rs2_op) | (((~rs1_op) | rs2_op) & result))) \
        >> 31;
    unlockQueue[0].push_back(&PSR_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUBcc_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUBcc_imm::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUBcc_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::SUBcc_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    return retVal;
}

bool leon3_accat_trap::SUBcc_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUBcc_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::SUBcc_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::SUBcc_imm::lockRegs_decode(){
    this->rd_decode.lock();
    this->PSR_pipe.lock();
}

bool leon3_accat_trap::SUBcc_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUBcc_imm::lockRegs_regs(){

}

bool leon3_accat_trap::SUBcc_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUBcc_imm::lockRegs_execute(){

}

bool leon3_accat_trap::SUBcc_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUBcc_imm::lockRegs_memory(){

}

bool leon3_accat_trap::SUBcc_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUBcc_imm::lockRegs_exception(){

}

bool leon3_accat_trap::SUBcc_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUBcc_imm::lockRegs_wb(){

}

void leon3_accat_trap::SUBcc_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::SUBcc_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::SUBcc_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::SUBcc_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::SUBcc_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::SUBcc_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::SUBcc_imm::replicate() const throw(){
    return new SUBcc_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::SUBcc_imm::getInstructionName() const throw(){
    return "SUBcc_imm";
}

unsigned int leon3_accat_trap::SUBcc_imm::getId() const throw(){
    return 81;
}

void leon3_accat_trap::SUBcc_imm::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::SUBcc_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "subcc r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::SUBcc_imm::SUBcc_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::SUBcc_imm::~SUBcc_imm(){

}
unsigned int leon3_accat_trap::TADDccTV_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TADDccTV_reg::behavior_decode( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rd rd_decode
    #define rs1 rs1_decode
    #define rs2 rs2_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TADDccTV_reg::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    rs1_op = rs1;
    rs2_op = rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TADDccTV_reg::behavior_execute( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    result = rs1_op + rs2_op;
    temp_V = ((unsigned int)((rs1_op & rs2_op & (~result)) | ((~rs1_op) & (~rs2_op) & \
        result))) >> 31;
    if(!temp_V && (((rs1_op | rs2_op) & 0x00000003) != 0)){
        temp_V = 1;
    }


    if(!temp_V){
        PSR[key_ICC_n] = ((result & 0x80000000) >> 31);
        PSR[key_ICC_z] = (result == 0);
        PSR[key_ICC_v] = 0;
        PSR[key_ICC_c] = ((unsigned int)((rs1_op & rs2_op) | ((rs1_op | rs2_op) & (~result)))) \
            >> 31;
    }
    unlockQueue[0].push_back(&PSR_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TADDccTV_reg::behavior_memory( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TADDccTV_reg::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rd rd_exception
    #define rs1 rs1_exception
    #define rs2 rs2_exception


    if(temp_V){
        RaiseException(pcounter, npcounter, TAG_OVERFLOW);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TADDccTV_reg::behavior_wb( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb

    {


        if(!temp_V){
            rd = result;
        }
    }
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::TADDccTV_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::TADDccTV_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TADDccTV_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::TADDccTV_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::TADDccTV_reg::lockRegs_decode(){
    this->rd_decode.lock();
    this->PSR_pipe.lock();
}

bool leon3_accat_trap::TADDccTV_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TADDccTV_reg::lockRegs_regs(){

}

bool leon3_accat_trap::TADDccTV_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TADDccTV_reg::lockRegs_execute(){

}

bool leon3_accat_trap::TADDccTV_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TADDccTV_reg::lockRegs_memory(){

}

bool leon3_accat_trap::TADDccTV_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TADDccTV_reg::lockRegs_exception(){

}

bool leon3_accat_trap::TADDccTV_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TADDccTV_reg::lockRegs_wb(){

}

void leon3_accat_trap::TADDccTV_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::TADDccTV_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::TADDccTV_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::TADDccTV_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::TADDccTV_reg::getUnlock_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::TADDccTV_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::TADDccTV_reg::replicate() const throw(){
    return new TADDccTV_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, \
        GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, \
        NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, \
        PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::TADDccTV_reg::getInstructionName() const throw(){
    return "TADDccTV_reg";
}

unsigned int leon3_accat_trap::TADDccTV_reg::getId() const throw(){
    return 78;
}

void leon3_accat_trap::TADDccTV_reg::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
}

std::string leon3_accat_trap::TADDccTV_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "taddcctv r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::TADDccTV_reg::TADDccTV_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::TADDccTV_reg::~TADDccTV_reg(){

}
unsigned int leon3_accat_trap::SDIV_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SDIV_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rd rd_decode
    #define rs1 rs1_decode
    #define rs2 rs2_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SDIV_reg::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    rs1_op = rs1;
    rs2_op = rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SDIV_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    exception = rs2_op == 0;
    if(!exception){
        #ifndef ACC_MODEL
        long long res64 = ((long long)((((unsigned long long)Y) << 32) | (unsigned long long)rs1_op))/((long \
            long)((int)rs2_op));
        #else
        long long res64 = ((long long)((((unsigned long long)Y_execute) << 32) | (unsigned \
            long long)rs1_op))/((long long)((int)rs2_op));
        #endif
        temp_V = (res64 & 0xFFFFFFFF80000000LL) != 0 && (res64 & 0xFFFFFFFF80000000LL) != \
            0xFFFFFFFF80000000LL;
        if(temp_V){
            if(res64 > 0){
                result = 0x7FFFFFFF;
            }
            else{
                result = 0x80000000;
            }
        }
        else{
            result = (unsigned int)(res64 & 0x00000000FFFFFFFFLL);
        }
    }
    stall(2);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SDIV_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SDIV_reg::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rd rd_exception
    #define rs1 rs1_exception
    #define rs2 rs2_exception


    if(exception){
        RaiseException(pcounter, npcounter, DIV_ZERO);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SDIV_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb

    {


        rd = result;
    }
    unlockQueue[33].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::SDIV_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    if(this->Y_decode.isLocked()){
        retVal += "Y - ";
    }
    return retVal;
}

bool leon3_accat_trap::SDIV_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SDIV_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::SDIV_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    regLocked = this->Y_execute.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::SDIV_reg::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::SDIV_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SDIV_reg::lockRegs_regs(){

}

bool leon3_accat_trap::SDIV_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SDIV_reg::lockRegs_execute(){

}

bool leon3_accat_trap::SDIV_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SDIV_reg::lockRegs_memory(){

}

bool leon3_accat_trap::SDIV_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SDIV_reg::lockRegs_exception(){

}

bool leon3_accat_trap::SDIV_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SDIV_reg::lockRegs_wb(){

}

void leon3_accat_trap::SDIV_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::SDIV_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::SDIV_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::SDIV_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::SDIV_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::SDIV_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::SDIV_reg::replicate() const throw(){
    return new SDIV_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::SDIV_reg::getInstructionName() const throw(){
    return "SDIV_reg";
}

unsigned int leon3_accat_trap::SDIV_reg::getId() const throw(){
    return 108;
}

void leon3_accat_trap::SDIV_reg::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
}

std::string leon3_accat_trap::SDIV_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "sdiv";
    oss << " r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::SDIV_reg::SDIV_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::SDIV_reg::~SDIV_reg(){

}
unsigned int leon3_accat_trap::SMULcc_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SMULcc_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SMULcc_imm::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs


    rs1_op = rs1;
    rs2_op = SignExtend(simm13, 13);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SMULcc_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute


    long long resultTemp = (long long)(((long long)((int)rs1_op))*((long long)((int)rs2_op)));
    Y = ((unsigned long long)resultTemp) >> 32;
    result = resultTemp & 0x00000000FFFFFFFF;
    stall(2);


    PSR[key_ICC_n] = ((result & 0x80000000) >> 31);
    PSR[key_ICC_z] = (result == 0);
    PSR[key_ICC_v] = 0;
    PSR[key_ICC_c] = 0;
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&PSR_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SMULcc_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SMULcc_imm::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SMULcc_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[2].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::SMULcc_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    return retVal;
}

bool leon3_accat_trap::SMULcc_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SMULcc_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::SMULcc_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::SMULcc_imm::lockRegs_decode(){
    this->rd_decode.lock();
    this->Y_pipe.lock();
    this->PSR_pipe.lock();
}

bool leon3_accat_trap::SMULcc_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SMULcc_imm::lockRegs_regs(){

}

bool leon3_accat_trap::SMULcc_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SMULcc_imm::lockRegs_execute(){

}

bool leon3_accat_trap::SMULcc_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SMULcc_imm::lockRegs_memory(){

}

bool leon3_accat_trap::SMULcc_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SMULcc_imm::lockRegs_exception(){

}

bool leon3_accat_trap::SMULcc_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SMULcc_imm::lockRegs_wb(){

}

void leon3_accat_trap::SMULcc_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::SMULcc_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::SMULcc_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::SMULcc_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::SMULcc_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::SMULcc_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::SMULcc_imm::replicate() const throw(){
    return new SMULcc_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::SMULcc_imm::getInstructionName() const throw(){
    return "SMULcc_imm";
}

unsigned int leon3_accat_trap::SMULcc_imm::getId() const throw(){
    return 99;
}

void leon3_accat_trap::SMULcc_imm::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::SMULcc_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "smulcc r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::SMULcc_imm::SMULcc_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::SMULcc_imm::~SMULcc_imm(){

}
unsigned int leon3_accat_trap::SWAP_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch
    #define rd rd_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SWAP_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rs1 rs1_decode
    #define rs2 rs2_decode
    #define rd rd_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SWAP_reg::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs
    #define rd rd_regs


    address = rs1 + rs2;
    toWrite = rd;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SWAP_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute
    #define rd rd_execute


    notAligned = (address & 0x00000003) != 0;
    #ifdef ACC_MODEL
    if(notAligned){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SWAP_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_memory
    #define WIM WIM_memory
    #define TBR TBR_memory
    #define Y Y_memory
    #define PC PC_memory
    #define NPC NPC_memory
    #define GLOBAL GLOBAL_memory
    #define WINREGS WINREGS_memory
    #define ASR ASR_memory
    #define FP FP_memory
    #define LR LR_memory
    #define SP SP_memory
    #define PCR PCR_memory
    #define REGS REGS_memory
    #define rs1 rs1_memory
    #define rs2 rs2_memory
    #define rd rd_memory


    if(notAligned){
        flush();
    }
    else{
        readValue = dataMem.read_word(address);
        dataMem.write_word(address, toWrite);
    }
    stall(2);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SWAP_reg::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rs1 rs1_exception
    #define rs2 rs2_exception
    #define rd rd_exception


    if(notAligned){
        RaiseException(pcounter, npcounter, MEM_ADDR_NOT_ALIGNED);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SWAP_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb
    #define rd rd_wb


    rd = readValue;
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

std::string leon3_accat_trap::SWAP_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    if(this->rd_decode.isLocked()){
        retVal += "rd - ";
    }
    return retVal;
}

bool leon3_accat_trap::SWAP_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SWAP_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::SWAP_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    regLocked = this->rd_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::SWAP_reg::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::SWAP_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SWAP_reg::lockRegs_regs(){

}

bool leon3_accat_trap::SWAP_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SWAP_reg::lockRegs_execute(){

}

bool leon3_accat_trap::SWAP_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SWAP_reg::lockRegs_memory(){

}

bool leon3_accat_trap::SWAP_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SWAP_reg::lockRegs_exception(){

}

bool leon3_accat_trap::SWAP_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SWAP_reg::lockRegs_wb(){

}

void leon3_accat_trap::SWAP_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::SWAP_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::SWAP_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::SWAP_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::SWAP_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::SWAP_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::SWAP_reg::replicate() const throw(){
    return new SWAP_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::SWAP_reg::getInstructionName() const throw(){
    return "SWAP_reg";
}

unsigned int leon3_accat_trap::SWAP_reg::getId() const throw(){
    return 34;
}

void leon3_accat_trap::SWAP_reg::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->asi = (bitString & 0x1fe0) >> 5;
}

std::string leon3_accat_trap::SWAP_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "swap r";
    oss << this->rs1_bit;
    oss << "+r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::SWAP_reg::SWAP_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
}

leon3_accat_trap::SWAP_reg::~SWAP_reg(){

}
unsigned int leon3_accat_trap::SUBX_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUBX_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUBX_imm::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs


    rs1_op = rs1;
    rs2_op = SignExtend(simm13, 13);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUBX_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute


    #ifndef ACC_MODEL
    result = rs1_op - rs2_op - PSR[key_ICC_c];
    #else
    result = rs1_op - rs2_op - PSR_execute[key_ICC_c];
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUBX_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUBX_imm::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SUBX_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::SUBX_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->PSR_decode.isLocked()){
        retVal += "PSR - ";
    }
    return retVal;
}

bool leon3_accat_trap::SUBX_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUBX_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::SUBX_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->PSR_execute.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::SUBX_imm::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::SUBX_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUBX_imm::lockRegs_regs(){

}

bool leon3_accat_trap::SUBX_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUBX_imm::lockRegs_execute(){

}

bool leon3_accat_trap::SUBX_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUBX_imm::lockRegs_memory(){

}

bool leon3_accat_trap::SUBX_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUBX_imm::lockRegs_exception(){

}

bool leon3_accat_trap::SUBX_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SUBX_imm::lockRegs_wb(){

}

void leon3_accat_trap::SUBX_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::SUBX_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::SUBX_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::SUBX_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::SUBX_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::SUBX_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::SUBX_imm::replicate() const throw(){
    return new SUBX_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::SUBX_imm::getInstructionName() const throw(){
    return "SUBX_imm";
}

unsigned int leon3_accat_trap::SUBX_imm::getId() const throw(){
    return 83;
}

void leon3_accat_trap::SUBX_imm::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::SUBX_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "subx r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::SUBX_imm::SUBX_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::SUBX_imm::~SUBX_imm(){

}
unsigned int leon3_accat_trap::STDA_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch
    #define rd rd_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STDA_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rs1 rs1_decode
    #define rs2 rs2_decode
    #define rd rd_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STDA_reg::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs
    #define rd rd_regs


    address = rs1 + rs2;
    if(rd_bit % 2 == 0){
        toWrite = rd || (((unsigned long long)REGS[rd_bit + 1]) << 32);
    }
    else{
        toWrite = REGS[rd_bit + 1] || (((unsigned long long)rd) << 32);
    }
    supervisor = PSR[key_S];

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STDA_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute
    #define rd rd_execute


    notAligned = (address & 0x00000003) != 0;
    #ifdef ACC_MODEL
    if(!supervisor || notAligned){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STDA_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_memory
    #define WIM WIM_memory
    #define TBR TBR_memory
    #define Y Y_memory
    #define PC PC_memory
    #define NPC NPC_memory
    #define GLOBAL GLOBAL_memory
    #define WINREGS WINREGS_memory
    #define ASR ASR_memory
    #define FP FP_memory
    #define LR LR_memory
    #define SP SP_memory
    #define PCR PCR_memory
    #define REGS REGS_memory
    #define rs1 rs1_memory
    #define rs2 rs2_memory
    #define rd rd_memory


    if(supervisor || !notAligned){
        dataMem.write_dword(address, toWrite);
    }
    else{
        flush();
    }
    stall(1);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STDA_reg::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rs1 rs1_exception
    #define rs2 rs2_exception
    #define rd rd_exception


    if(!supervisor){
        RaiseException(pcounter, npcounter, PRIVILEDGE_INSTR);
    }
    if(notAligned){
        RaiseException(pcounter, npcounter, MEM_ADDR_NOT_ALIGNED);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STDA_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

std::string leon3_accat_trap::STDA_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    if(this->rd_decode.isLocked()){
        retVal += "rd - ";
    }
    return retVal;
}

bool leon3_accat_trap::STDA_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STDA_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::STDA_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    regLocked = this->rd_decode.isLocked() || regLocked;
    regLocked = REGS_decode[rd_bit ^ 0x1].isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::STDA_reg::lockRegs_decode(){

}

bool leon3_accat_trap::STDA_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STDA_reg::lockRegs_regs(){

}

bool leon3_accat_trap::STDA_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STDA_reg::lockRegs_execute(){

}

bool leon3_accat_trap::STDA_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STDA_reg::lockRegs_memory(){

}

bool leon3_accat_trap::STDA_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STDA_reg::lockRegs_exception(){

}

bool leon3_accat_trap::STDA_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STDA_reg::lockRegs_wb(){

}

void leon3_accat_trap::STDA_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STDA_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STDA_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STDA_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STDA_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STDA_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

Instruction * leon3_accat_trap::STDA_reg::replicate() const throw(){
    return new STDA_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::STDA_reg::getInstructionName() const throw(){
    return "STDA_reg";
}

unsigned int leon3_accat_trap::STDA_reg::getId() const throw(){
    return 29;
}

void leon3_accat_trap::STDA_reg::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->asi = (bitString & 0x1fe0) >> 5;
}

std::string leon3_accat_trap::STDA_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "stda r";
    oss << this->rd_bit;
    oss << " r";
    oss << this->rs1_bit;
    oss << "+r";
    oss << this->rs2_bit;
    oss << " ";
    oss << this->asi;
    return oss.str();
}

leon3_accat_trap::STDA_reg::STDA_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
}

leon3_accat_trap::STDA_reg::~STDA_reg(){

}
unsigned int leon3_accat_trap::UMAC_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UMAC_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UMAC_reg::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    rs1_op = rs1;
    rs2_op = rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UMAC_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    unsigned int resultTemp = ((unsigned int)rs1_op & 0x0000ffff)*((unsigned int)rs2_op \
        & 0x0000ffff);
    #ifndef ACC_MODEL
    unsigned long long resultAcc = ((((unsigned long long)(Y & 0x000000ff)) << 32) | \
        (unsigned int)ASR[18]) + resultTemp;
    #else
    unsigned long long resultAcc = ((((unsigned long long)(Y_execute & 0x000000ff)) << \
        32) | (unsigned int)ASR_execute[18]) + resultTemp;
    #endif
    Y = (resultAcc & 0x000000ff00000000LL) >> 32;
    ASR[18] = resultAcc & 0x00000000FFFFFFFFLL;
    result = resultAcc & 0x00000000FFFFFFFFLL;
    stall(1);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&ASR_execute[18]);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UMAC_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UMAC_reg::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UMAC_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&ASR_fetch[18]);
    unlockQueue[0].push_back(&ASR_decode[18]);
    unlockQueue[0].push_back(&ASR_regs[18]);
    unlockQueue[0].push_back(&ASR_memory[18]);
    unlockQueue[0].push_back(&ASR_exception[18]);
    unlockQueue[0].push_back(&ASR_wb[18]);
    unlockQueue[0].push_back(ASR_pipe[18].getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::UMAC_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    if(this->Y_decode.isLocked()){
        retVal += "Y - ";
    }
    if(this->ASR_decode[18].isLocked()){
        retVal += "ASR[18] - ";
    }
    return retVal;
}

bool leon3_accat_trap::UMAC_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UMAC_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::UMAC_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    regLocked = this->Y_execute.isLocked() || regLocked;
    regLocked = this->ASR_execute[18].isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::UMAC_reg::lockRegs_decode(){
    this->rd_decode.lock();
    this->Y_pipe.lock();
    this->ASR_pipe[18].lock();
}

bool leon3_accat_trap::UMAC_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UMAC_reg::lockRegs_regs(){

}

bool leon3_accat_trap::UMAC_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UMAC_reg::lockRegs_execute(){

}

bool leon3_accat_trap::UMAC_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UMAC_reg::lockRegs_memory(){

}

bool leon3_accat_trap::UMAC_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UMAC_reg::lockRegs_exception(){

}

bool leon3_accat_trap::UMAC_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UMAC_reg::lockRegs_wb(){

}

void leon3_accat_trap::UMAC_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&ASR_fetch[18]);
    unlockQueue[0].push_back(&ASR_decode[18]);
    unlockQueue[0].push_back(&ASR_regs[18]);
    unlockQueue[0].push_back(&ASR_execute[18]);
    unlockQueue[0].push_back(&ASR_memory[18]);
    unlockQueue[0].push_back(&ASR_exception[18]);
    unlockQueue[0].push_back(&ASR_wb[18]);
    unlockQueue[0].push_back(ASR_pipe[18].getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::UMAC_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&ASR_fetch[18]);
    unlockQueue[0].push_back(&ASR_decode[18]);
    unlockQueue[0].push_back(&ASR_regs[18]);
    unlockQueue[0].push_back(&ASR_execute[18]);
    unlockQueue[0].push_back(&ASR_memory[18]);
    unlockQueue[0].push_back(&ASR_exception[18]);
    unlockQueue[0].push_back(&ASR_wb[18]);
    unlockQueue[0].push_back(ASR_pipe[18].getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::UMAC_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&ASR_fetch[18]);
    unlockQueue[0].push_back(&ASR_decode[18]);
    unlockQueue[0].push_back(&ASR_regs[18]);
    unlockQueue[0].push_back(&ASR_execute[18]);
    unlockQueue[0].push_back(&ASR_memory[18]);
    unlockQueue[0].push_back(&ASR_exception[18]);
    unlockQueue[0].push_back(&ASR_wb[18]);
    unlockQueue[0].push_back(ASR_pipe[18].getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::UMAC_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&ASR_fetch[18]);
    unlockQueue[0].push_back(&ASR_decode[18]);
    unlockQueue[0].push_back(&ASR_regs[18]);
    unlockQueue[0].push_back(&ASR_memory[18]);
    unlockQueue[0].push_back(&ASR_exception[18]);
    unlockQueue[0].push_back(&ASR_wb[18]);
    unlockQueue[0].push_back(ASR_pipe[18].getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::UMAC_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&ASR_fetch[18]);
    unlockQueue[0].push_back(&ASR_decode[18]);
    unlockQueue[0].push_back(&ASR_regs[18]);
    unlockQueue[0].push_back(&ASR_memory[18]);
    unlockQueue[0].push_back(&ASR_exception[18]);
    unlockQueue[0].push_back(&ASR_wb[18]);
    unlockQueue[0].push_back(ASR_pipe[18].getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::UMAC_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(&ASR_fetch[18]);
    unlockQueue[0].push_back(&ASR_decode[18]);
    unlockQueue[0].push_back(&ASR_regs[18]);
    unlockQueue[0].push_back(&ASR_memory[18]);
    unlockQueue[0].push_back(&ASR_exception[18]);
    unlockQueue[0].push_back(&ASR_wb[18]);
    unlockQueue[0].push_back(ASR_pipe[18].getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::UMAC_reg::replicate() const throw(){
    return new UMAC_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::UMAC_reg::getInstructionName() const throw(){
    return "UMAC_reg";
}

unsigned int leon3_accat_trap::UMAC_reg::getId() const throw(){
    return 102;
}

void leon3_accat_trap::UMAC_reg::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
}

std::string leon3_accat_trap::UMAC_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "umac r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::UMAC_reg::UMAC_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::UMAC_reg::~UMAC_reg(){

}
unsigned int leon3_accat_trap::JUMP_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::JUMP_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rd rd_decode
    #define rs1 rs1_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    unsigned int jumpAddr = rs1 + SignExtend(simm13, 13);
    if((jumpAddr & 0x00000003) != 0){
        trapNotAligned = true;
    }
    else{
        trapNotAligned = false;
        #ifdef ACC_MODEL
        PC = jumpAddr;
        NPC = jumpAddr + 4;
        #else
        PC = npcounter;
        NPC = jumpAddr;
        #endif
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::JUMP_imm::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::JUMP_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute


    stall(2);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::JUMP_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::JUMP_imm::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rd rd_exception
    #define rs1 rs1_exception


    if(trapNotAligned){
        RaiseException(pcounter, npcounter, MEM_ADDR_NOT_ALIGNED);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::JUMP_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb


    if(!trapNotAligned){
        rd = pcounter;
    }
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::JUMP_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    return retVal;
}

bool leon3_accat_trap::JUMP_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::JUMP_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::JUMP_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::JUMP_imm::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::JUMP_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::JUMP_imm::lockRegs_regs(){

}

bool leon3_accat_trap::JUMP_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::JUMP_imm::lockRegs_execute(){

}

bool leon3_accat_trap::JUMP_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::JUMP_imm::lockRegs_memory(){

}

bool leon3_accat_trap::JUMP_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::JUMP_imm::lockRegs_exception(){

}

bool leon3_accat_trap::JUMP_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::JUMP_imm::lockRegs_wb(){

}

void leon3_accat_trap::JUMP_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::JUMP_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::JUMP_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::JUMP_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::JUMP_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::JUMP_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::JUMP_imm::replicate() const throw(){
    return new JUMP_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::JUMP_imm::getInstructionName() const throw(){
    return "JUMP_imm";
}

unsigned int leon3_accat_trap::JUMP_imm::getId() const throw(){
    return 119;
}

void leon3_accat_trap::JUMP_imm::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::JUMP_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "jmpl";
    oss << " r";
    oss << this->rs1_bit;
    oss << "+";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::JUMP_imm::JUMP_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::JUMP_imm::~JUMP_imm(){

}
unsigned int leon3_accat_trap::SMUL_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SMUL_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SMUL_reg::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    rs1_op = rs1;
    rs2_op = rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SMUL_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    long long resultTemp = (long long)(((long long)((int)rs1_op))*((long long)((int)rs2_op)));
    Y = ((unsigned long long)resultTemp) >> 32;
    result = resultTemp & 0x00000000FFFFFFFF;
    stall(2);
    unlockQueue[0].push_back(&Y_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SMUL_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SMUL_reg::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SMUL_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[2].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::SMUL_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::SMUL_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SMUL_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::SMUL_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::SMUL_reg::lockRegs_decode(){
    this->rd_decode.lock();
    this->Y_pipe.lock();
}

bool leon3_accat_trap::SMUL_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SMUL_reg::lockRegs_regs(){

}

bool leon3_accat_trap::SMUL_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SMUL_reg::lockRegs_execute(){

}

bool leon3_accat_trap::SMUL_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SMUL_reg::lockRegs_memory(){

}

bool leon3_accat_trap::SMUL_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SMUL_reg::lockRegs_exception(){

}

bool leon3_accat_trap::SMUL_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SMUL_reg::lockRegs_wb(){

}

void leon3_accat_trap::SMUL_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::SMUL_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::SMUL_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_execute);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::SMUL_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::SMUL_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::SMUL_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&Y_fetch);
    unlockQueue[0].push_back(&Y_decode);
    unlockQueue[0].push_back(&Y_regs);
    unlockQueue[0].push_back(&Y_memory);
    unlockQueue[0].push_back(&Y_exception);
    unlockQueue[0].push_back(&Y_wb);
    unlockQueue[0].push_back(Y_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::SMUL_reg::replicate() const throw(){
    return new SMUL_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::SMUL_reg::getInstructionName() const throw(){
    return "SMUL_reg";
}

unsigned int leon3_accat_trap::SMUL_reg::getId() const throw(){
    return 96;
}

void leon3_accat_trap::SMUL_reg::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
}

std::string leon3_accat_trap::SMUL_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "smul r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::SMUL_reg::SMUL_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::SMUL_reg::~SMUL_reg(){

}
unsigned int leon3_accat_trap::XORcc_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XORcc_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XORcc_imm::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs


    rs1_op = rs1;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XORcc_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute


    result = rs1_op ^ SignExtend(simm13, 13);


    PSR[key_ICC_n] = ((result & 0x80000000) >> 31);
    PSR[key_ICC_z] = (result == 0);
    PSR[key_ICC_v] = 0;
    PSR[key_ICC_c] = 0;
    unlockQueue[0].push_back(&PSR_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XORcc_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XORcc_imm::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XORcc_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::XORcc_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    return retVal;
}

bool leon3_accat_trap::XORcc_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XORcc_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::XORcc_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::XORcc_imm::lockRegs_decode(){
    this->rd_decode.lock();
    this->PSR_pipe.lock();
}

bool leon3_accat_trap::XORcc_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XORcc_imm::lockRegs_regs(){

}

bool leon3_accat_trap::XORcc_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XORcc_imm::lockRegs_execute(){

}

bool leon3_accat_trap::XORcc_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XORcc_imm::lockRegs_memory(){

}

bool leon3_accat_trap::XORcc_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XORcc_imm::lockRegs_exception(){

}

bool leon3_accat_trap::XORcc_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XORcc_imm::lockRegs_wb(){

}

void leon3_accat_trap::XORcc_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::XORcc_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::XORcc_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::XORcc_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::XORcc_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::XORcc_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::XORcc_imm::replicate() const throw(){
    return new XORcc_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::XORcc_imm::getInstructionName() const throw(){
    return "XORcc_imm";
}

unsigned int leon3_accat_trap::XORcc_imm::getId() const throw(){
    return 55;
}

void leon3_accat_trap::XORcc_imm::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::XORcc_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "xorcc r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::XORcc_imm::XORcc_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::XORcc_imm::~XORcc_imm(){

}
unsigned int leon3_accat_trap::ORNcc_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ORNcc_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ORNcc_imm::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs


    rs1_op = rs1;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ORNcc_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute


    result = rs1_op | ~(SignExtend(simm13, 13));


    PSR[key_ICC_n] = ((result & 0x80000000) >> 31);
    PSR[key_ICC_z] = (result == 0);
    PSR[key_ICC_v] = 0;
    PSR[key_ICC_c] = 0;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ORNcc_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ORNcc_imm::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ORNcc_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::ORNcc_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    return retVal;
}

bool leon3_accat_trap::ORNcc_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ORNcc_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::ORNcc_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::ORNcc_imm::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::ORNcc_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ORNcc_imm::lockRegs_regs(){

}

bool leon3_accat_trap::ORNcc_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ORNcc_imm::lockRegs_execute(){

}

bool leon3_accat_trap::ORNcc_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ORNcc_imm::lockRegs_memory(){

}

bool leon3_accat_trap::ORNcc_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ORNcc_imm::lockRegs_exception(){

}

bool leon3_accat_trap::ORNcc_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ORNcc_imm::lockRegs_wb(){

}

void leon3_accat_trap::ORNcc_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::ORNcc_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::ORNcc_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::ORNcc_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::ORNcc_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::ORNcc_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::ORNcc_imm::replicate() const throw(){
    return new ORNcc_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::ORNcc_imm::getInstructionName() const throw(){
    return "ORNcc_imm";
}

unsigned int leon3_accat_trap::ORNcc_imm::getId() const throw(){
    return 51;
}

void leon3_accat_trap::ORNcc_imm::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::ORNcc_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "orncc r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::ORNcc_imm::ORNcc_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::ORNcc_imm::~ORNcc_imm(){

}
unsigned int leon3_accat_trap::LDUBA_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch
    #define rd rd_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDUBA_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rs1 rs1_decode
    #define rs2 rs2_decode
    #define rd rd_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDUBA_reg::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs
    #define rd rd_regs


    address = rs1 + rs2;
    supervisor = PSR[key_S];

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDUBA_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute
    #define rd rd_execute


    #ifdef ACC_MODEL
    if(!supervisor){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDUBA_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_memory
    #define WIM WIM_memory
    #define TBR TBR_memory
    #define Y Y_memory
    #define PC PC_memory
    #define NPC NPC_memory
    #define GLOBAL GLOBAL_memory
    #define WINREGS WINREGS_memory
    #define ASR ASR_memory
    #define FP FP_memory
    #define LR LR_memory
    #define SP SP_memory
    #define PCR PCR_memory
    #define REGS REGS_memory
    #define rs1 rs1_memory
    #define rs2 rs2_memory
    #define rd rd_memory


    #ifdef ACC_MODEL
    if(!supervisor){
        flush();
    }
    else{
        #endif
        readValue = dataMem.read_byte(address);
        #ifdef ACC_MODEL
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDUBA_reg::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rs1 rs1_exception
    #define rs2 rs2_exception
    #define rd rd_exception


    if(!supervisor){
        RaiseException(pcounter, npcounter, PRIVILEDGE_INSTR);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDUBA_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb
    #define rd rd_wb


    rd = readValue;
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

std::string leon3_accat_trap::LDUBA_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::LDUBA_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDUBA_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::LDUBA_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::LDUBA_reg::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::LDUBA_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDUBA_reg::lockRegs_regs(){

}

bool leon3_accat_trap::LDUBA_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDUBA_reg::lockRegs_execute(){

}

bool leon3_accat_trap::LDUBA_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDUBA_reg::lockRegs_memory(){

}

bool leon3_accat_trap::LDUBA_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDUBA_reg::lockRegs_exception(){

}

bool leon3_accat_trap::LDUBA_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDUBA_reg::lockRegs_wb(){

}

void leon3_accat_trap::LDUBA_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::LDUBA_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::LDUBA_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::LDUBA_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::LDUBA_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::LDUBA_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::LDUBA_reg::replicate() const throw(){
    return new LDUBA_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::LDUBA_reg::getInstructionName() const throw(){
    return "LDUBA_reg";
}

unsigned int leon3_accat_trap::LDUBA_reg::getId() const throw(){
    return 14;
}

void leon3_accat_trap::LDUBA_reg::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->asi = (bitString & 0x1fe0) >> 5;
}

std::string leon3_accat_trap::LDUBA_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "lduba r";
    oss << this->rs1_bit;
    oss << "+r";
    oss << this->rs2_bit;
    oss << " ";
    oss << this->asi;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::LDUBA_reg::LDUBA_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
}

leon3_accat_trap::LDUBA_reg::~LDUBA_reg(){

}
unsigned int leon3_accat_trap::JUMP_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::JUMP_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rd rd_decode
    #define rs1 rs1_decode
    #define rs2 rs2_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    unsigned int jumpAddr = rs1 + rs2;
    if((jumpAddr & 0x00000003) != 0){
        trapNotAligned = true;
    }
    else{
        trapNotAligned = false;
        #ifdef ACC_MODEL
        PC = jumpAddr;
        NPC = jumpAddr + 4;
        #else
        PC = npcounter;
        NPC = jumpAddr;
        #endif
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::JUMP_reg::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::JUMP_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    stall(2);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::JUMP_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::JUMP_reg::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rd rd_exception
    #define rs1 rs1_exception
    #define rs2 rs2_exception


    if(trapNotAligned){
        RaiseException(pcounter, npcounter, MEM_ADDR_NOT_ALIGNED);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::JUMP_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb


    if(!trapNotAligned){
        rd = pcounter;
    }
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::JUMP_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::JUMP_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::JUMP_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::JUMP_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::JUMP_reg::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::JUMP_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::JUMP_reg::lockRegs_regs(){

}

bool leon3_accat_trap::JUMP_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::JUMP_reg::lockRegs_execute(){

}

bool leon3_accat_trap::JUMP_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::JUMP_reg::lockRegs_memory(){

}

bool leon3_accat_trap::JUMP_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::JUMP_reg::lockRegs_exception(){

}

bool leon3_accat_trap::JUMP_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::JUMP_reg::lockRegs_wb(){

}

void leon3_accat_trap::JUMP_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::JUMP_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::JUMP_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::JUMP_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::JUMP_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::JUMP_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::JUMP_reg::replicate() const throw(){
    return new JUMP_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::JUMP_reg::getInstructionName() const throw(){
    return "JUMP_reg";
}

unsigned int leon3_accat_trap::JUMP_reg::getId() const throw(){
    return 120;
}

void leon3_accat_trap::JUMP_reg::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
}

std::string leon3_accat_trap::JUMP_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "jmpl";
    oss << " r";
    oss << this->rs1_bit;
    oss << "+r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::JUMP_reg::JUMP_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::JUMP_reg::~JUMP_reg(){

}
unsigned int leon3_accat_trap::ADDX_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADDX_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADDX_reg::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    rs1_op = rs1;
    rs2_op = rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADDX_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    #ifndef ACC_MODEL
    result = rs1_op + rs2_op + PSR[key_ICC_c];
    #else
    //I read the register of the execute stage since this
    //is the one containing the bypass value
    result = rs1_op + rs2_op + PSR_execute[key_ICC_c];
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADDX_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADDX_reg::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ADDX_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::ADDX_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    if(this->PSR_decode.isLocked()){
        retVal += "PSR - ";
    }
    return retVal;
}

bool leon3_accat_trap::ADDX_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADDX_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::ADDX_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    regLocked = this->PSR_execute.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::ADDX_reg::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::ADDX_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADDX_reg::lockRegs_regs(){

}

bool leon3_accat_trap::ADDX_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADDX_reg::lockRegs_execute(){

}

bool leon3_accat_trap::ADDX_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADDX_reg::lockRegs_memory(){

}

bool leon3_accat_trap::ADDX_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADDX_reg::lockRegs_exception(){

}

bool leon3_accat_trap::ADDX_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ADDX_reg::lockRegs_wb(){

}

void leon3_accat_trap::ADDX_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::ADDX_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::ADDX_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::ADDX_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::ADDX_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::ADDX_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::ADDX_reg::replicate() const throw(){
    return new ADDX_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::ADDX_reg::getInstructionName() const throw(){
    return "ADDX_reg";
}

unsigned int leon3_accat_trap::ADDX_reg::getId() const throw(){
    return 72;
}

void leon3_accat_trap::ADDX_reg::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
}

std::string leon3_accat_trap::ADDX_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "addx r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::ADDX_reg::ADDX_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::ADDX_reg::~ADDX_reg(){

}
unsigned int leon3_accat_trap::UDIV_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UDIV_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rd rd_decode
    #define rs1 rs1_decode
    #define rs2 rs2_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UDIV_reg::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    rs1_op = rs1;
    rs2_op = rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UDIV_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    exception = rs2_op == 0;
    if(!exception){
        #ifndef ACC_MODEL
        unsigned long long res64 = ((unsigned long long)((((unsigned long long)Y) << 32) \
            | (unsigned long long)rs1_op))/(unsigned long long)rs2_op;
        #else
        unsigned long long res64 = ((unsigned long long)((((unsigned long long)Y_execute) \
            << 32) | (unsigned long long)rs1_op))/(unsigned long long)rs2_op;
        #endif
        temp_V = (res64 & 0xFFFFFFFF00000000LL) != 0;
        if(temp_V){
            result = 0xFFFFFFFF;
        }
        else{
            result = (unsigned int)(res64 & 0x00000000FFFFFFFFLL);
        }
    }
    stall(35);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UDIV_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UDIV_reg::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rd rd_exception
    #define rs1 rs1_exception
    #define rs2 rs2_exception


    if(exception){
        RaiseException(pcounter, npcounter, DIV_ZERO);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::UDIV_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb

    {


        rd = result;
    }
    unlockQueue[33].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::UDIV_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    if(this->Y_decode.isLocked()){
        retVal += "Y - ";
    }
    return retVal;
}

bool leon3_accat_trap::UDIV_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UDIV_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::UDIV_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    regLocked = this->Y_execute.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::UDIV_reg::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::UDIV_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UDIV_reg::lockRegs_regs(){

}

bool leon3_accat_trap::UDIV_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UDIV_reg::lockRegs_execute(){

}

bool leon3_accat_trap::UDIV_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UDIV_reg::lockRegs_memory(){

}

bool leon3_accat_trap::UDIV_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UDIV_reg::lockRegs_exception(){

}

bool leon3_accat_trap::UDIV_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::UDIV_reg::lockRegs_wb(){

}

void leon3_accat_trap::UDIV_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::UDIV_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::UDIV_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::UDIV_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::UDIV_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::UDIV_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::UDIV_reg::replicate() const throw(){
    return new UDIV_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::UDIV_reg::getInstructionName() const throw(){
    return "UDIV_reg";
}

unsigned int leon3_accat_trap::UDIV_reg::getId() const throw(){
    return 106;
}

void leon3_accat_trap::UDIV_reg::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
}

std::string leon3_accat_trap::UDIV_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "udiv";
    oss << " r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::UDIV_reg::UDIV_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::UDIV_reg::~UDIV_reg(){

}
unsigned int leon3_accat_trap::XNORcc_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XNORcc_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XNORcc_imm::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs


    rs1_op = rs1;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XNORcc_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute


    result = rs1_op ^ ~(SignExtend(simm13, 13));


    PSR[key_ICC_n] = ((result & 0x80000000) >> 31);
    PSR[key_ICC_z] = (result == 0);
    PSR[key_ICC_v] = 0;
    PSR[key_ICC_c] = 0;
    unlockQueue[0].push_back(&PSR_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XNORcc_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XNORcc_imm::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::XNORcc_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::XNORcc_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    return retVal;
}

bool leon3_accat_trap::XNORcc_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XNORcc_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::XNORcc_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::XNORcc_imm::lockRegs_decode(){
    this->rd_decode.lock();
    this->PSR_pipe.lock();
}

bool leon3_accat_trap::XNORcc_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XNORcc_imm::lockRegs_regs(){

}

bool leon3_accat_trap::XNORcc_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XNORcc_imm::lockRegs_execute(){

}

bool leon3_accat_trap::XNORcc_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XNORcc_imm::lockRegs_memory(){

}

bool leon3_accat_trap::XNORcc_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XNORcc_imm::lockRegs_exception(){

}

bool leon3_accat_trap::XNORcc_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::XNORcc_imm::lockRegs_wb(){

}

void leon3_accat_trap::XNORcc_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::XNORcc_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::XNORcc_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::XNORcc_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::XNORcc_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::XNORcc_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::XNORcc_imm::replicate() const throw(){
    return new XNORcc_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::XNORcc_imm::getInstructionName() const throw(){
    return "XNORcc_imm";
}

unsigned int leon3_accat_trap::XNORcc_imm::getId() const throw(){
    return 59;
}

void leon3_accat_trap::XNORcc_imm::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::XNORcc_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "xnorcc r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::XNORcc_imm::XNORcc_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::XNORcc_imm::~XNORcc_imm(){

}
unsigned int leon3_accat_trap::STBAR::behavior_fetch( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STBAR::behavior_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STBAR::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STBAR::behavior_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute



    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STBAR::behavior_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STBAR::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STBAR::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

std::string leon3_accat_trap::STBAR::printBusyRegs(){
    std::string retVal = "";
    return retVal;
}

bool leon3_accat_trap::STBAR::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STBAR::lockRegs_fetch(){

}

bool leon3_accat_trap::STBAR::checkHazard_decode(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STBAR::lockRegs_decode(){

}

bool leon3_accat_trap::STBAR::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STBAR::lockRegs_regs(){

}

bool leon3_accat_trap::STBAR::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STBAR::lockRegs_execute(){

}

bool leon3_accat_trap::STBAR::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STBAR::lockRegs_memory(){

}

bool leon3_accat_trap::STBAR::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STBAR::lockRegs_exception(){

}

bool leon3_accat_trap::STBAR::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STBAR::lockRegs_wb(){

}

void leon3_accat_trap::STBAR::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STBAR::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STBAR::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STBAR::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STBAR::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STBAR::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

Instruction * leon3_accat_trap::STBAR::replicate() const throw(){
    return new STBAR(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::STBAR::getInstructionName() const throw(){
    return "STBAR";
}

unsigned int leon3_accat_trap::STBAR::getId() const throw(){
    return 140;
}

void leon3_accat_trap::STBAR::setParams( const unsigned int & bitString ) throw(){

}

std::string leon3_accat_trap::STBAR::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "s";
    oss << "t";
    oss << "b";
    oss << "a";
    oss << "r";
    return oss.str();
}

leon3_accat_trap::STBAR::STBAR( PipelineRegister & PSR_pipe, PipelineRegister & WIM_pipe, \
    PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister & PC_pipe, \
    PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister * WINREGS_pipe, \
    PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, Reg32_2 & \
    TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, RegisterBankClass \
    & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias & FP_fetch, Alias \
    & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, Reg32_0 & PSR_decode, \
    Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, Reg32_3 & PC_decode, \
    Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 * WINREGS_decode, \
    Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias & SP_decode, Alias \
    & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 & WIM_regs, Reg32_2 \
    & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, RegisterBankClass \
    & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias & FP_regs, Alias \
    & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, Reg32_0 & PSR_execute, \
    Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, Reg32_3 & PC_execute, \
    Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, Reg32_3 * WINREGS_execute, \
    Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, Alias & SP_execute, \
    Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, Reg32_1 & WIM_memory, \
    Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, Reg32_3 & NPC_memory, \
    RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, Reg32_3 * ASR_memory, \
    Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias & PCR_memory, Alias \
    * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, Reg32_2 & TBR_exception, \
    Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & NPC_exception, RegisterBankClass \
    & GLOBAL_exception, Reg32_3 * WINREGS_exception, Reg32_3 * ASR_exception, Alias & \
    FP_exception, Alias & LR_exception, Alias & SP_exception, Alias & PCR_exception, \
    Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, Reg32_2 & TBR_wb, Reg32_3 \
    & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass & GLOBAL_wb, Reg32_3 \
    * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, Alias & SP_wb, Alias \
    & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & dataMem, PinTLM_out_32 \
    & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, \
    GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, \
    NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, \
    PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
    GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
    REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
    WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
    WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
    ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
    WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
    ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
    WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
    WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
    REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
    ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){

}

leon3_accat_trap::STBAR::~STBAR(){

}
unsigned int leon3_accat_trap::LDA_reg::behavior_fetch( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch
    #define rd rd_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDA_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rs1 rs1_decode
    #define rs2 rs2_decode
    #define rd rd_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDA_reg::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs
    #define rd rd_regs


    address = rs1 + rs2;
    supervisor = PSR[key_S];

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDA_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute
    #define rd rd_execute


    notAligned = (address & 0x00000003) != 0;
    #ifdef ACC_MODEL
    if(notAligned || !supervisor){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDA_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_memory
    #define WIM WIM_memory
    #define TBR TBR_memory
    #define Y Y_memory
    #define PC PC_memory
    #define NPC NPC_memory
    #define GLOBAL GLOBAL_memory
    #define WINREGS WINREGS_memory
    #define ASR ASR_memory
    #define FP FP_memory
    #define LR LR_memory
    #define SP SP_memory
    #define PCR PCR_memory
    #define REGS REGS_memory
    #define rs1 rs1_memory
    #define rs2 rs2_memory
    #define rd rd_memory


    #ifdef ACC_MODEL
    if(notAligned || !supervisor){
        flush();
    }
    else{
        #endif
        readValue = dataMem.read_word(address);
        #ifdef ACC_MODEL
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDA_reg::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rs1 rs1_exception
    #define rs2 rs2_exception
    #define rd rd_exception


    if(!supervisor){
        RaiseException(pcounter, npcounter, PRIVILEDGE_INSTR);
    }
    if(notAligned){
        RaiseException(pcounter, npcounter, MEM_ADDR_NOT_ALIGNED);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDA_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb
    #define rd rd_wb


    rd = readValue;
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

std::string leon3_accat_trap::LDA_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::LDA_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDA_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::LDA_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::LDA_reg::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::LDA_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDA_reg::lockRegs_regs(){

}

bool leon3_accat_trap::LDA_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDA_reg::lockRegs_execute(){

}

bool leon3_accat_trap::LDA_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDA_reg::lockRegs_memory(){

}

bool leon3_accat_trap::LDA_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDA_reg::lockRegs_exception(){

}

bool leon3_accat_trap::LDA_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDA_reg::lockRegs_wb(){

}

void leon3_accat_trap::LDA_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::LDA_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::LDA_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::LDA_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::LDA_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::LDA_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::LDA_reg::replicate() const throw(){
    return new LDA_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::LDA_reg::getInstructionName() const throw(){
    return "LDA_reg";
}

unsigned int leon3_accat_trap::LDA_reg::getId() const throw(){
    return 16;
}

void leon3_accat_trap::LDA_reg::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->asi = (bitString & 0x1fe0) >> 5;
}

std::string leon3_accat_trap::LDA_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "lda r";
    oss << this->rs1_bit;
    oss << "+r";
    oss << this->rs2_bit;
    oss << " ";
    oss << this->asi;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::LDA_reg::LDA_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
}

leon3_accat_trap::LDA_reg::~LDA_reg(){

}
unsigned int leon3_accat_trap::STHA_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch
    #define rd rd_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STHA_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rs1 rs1_decode
    #define rs2 rs2_decode
    #define rd rd_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STHA_reg::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs
    #define rd rd_regs


    address = rs1 + rs2;
    toWrite = (unsigned short int)(rd & 0x0000FFFF);
    supervisor = PSR[key_S];

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STHA_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute
    #define rd rd_execute


    notAligned = (address & 0x00000001) != 0;
    #ifdef ACC_MODEL
    if(!supervisor || notAligned){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STHA_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_memory
    #define WIM WIM_memory
    #define TBR TBR_memory
    #define Y Y_memory
    #define PC PC_memory
    #define NPC NPC_memory
    #define GLOBAL GLOBAL_memory
    #define WINREGS WINREGS_memory
    #define ASR ASR_memory
    #define FP FP_memory
    #define LR LR_memory
    #define SP SP_memory
    #define PCR PCR_memory
    #define REGS REGS_memory
    #define rs1 rs1_memory
    #define rs2 rs2_memory
    #define rd rd_memory


    if(supervisor || !notAligned){
        dataMem.write_half(address, toWrite);
    }
    else{
        flush();
    }
    stall(1);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STHA_reg::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rs1 rs1_exception
    #define rs2 rs2_exception
    #define rd rd_exception


    if(!supervisor){
        RaiseException(pcounter, npcounter, PRIVILEDGE_INSTR);
    }
    if(notAligned){
        RaiseException(pcounter, npcounter, MEM_ADDR_NOT_ALIGNED);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::STHA_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

std::string leon3_accat_trap::STHA_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    if(this->rd_decode.isLocked()){
        retVal += "rd - ";
    }
    return retVal;
}

bool leon3_accat_trap::STHA_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STHA_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::STHA_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    regLocked = this->rd_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::STHA_reg::lockRegs_decode(){

}

bool leon3_accat_trap::STHA_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STHA_reg::lockRegs_regs(){

}

bool leon3_accat_trap::STHA_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STHA_reg::lockRegs_execute(){

}

bool leon3_accat_trap::STHA_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STHA_reg::lockRegs_memory(){

}

bool leon3_accat_trap::STHA_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STHA_reg::lockRegs_exception(){

}

bool leon3_accat_trap::STHA_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::STHA_reg::lockRegs_wb(){

}

void leon3_accat_trap::STHA_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STHA_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STHA_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STHA_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STHA_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::STHA_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

Instruction * leon3_accat_trap::STHA_reg::replicate() const throw(){
    return new STHA_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::STHA_reg::getInstructionName() const throw(){
    return "STHA_reg";
}

unsigned int leon3_accat_trap::STHA_reg::getId() const throw(){
    return 27;
}

void leon3_accat_trap::STHA_reg::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->asi = (bitString & 0x1fe0) >> 5;
}

std::string leon3_accat_trap::STHA_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "stha r";
    oss << this->rd_bit;
    oss << " r";
    oss << this->rs1_bit;
    oss << "+r";
    oss << this->rs2_bit;
    oss << " ";
    oss << this->asi;
    return oss.str();
}

leon3_accat_trap::STHA_reg::STHA_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
}

leon3_accat_trap::STHA_reg::~STHA_reg(){

}
unsigned int leon3_accat_trap::LDDA_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch
    #define rd rd_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDDA_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rs1 rs1_decode
    #define rs2 rs2_decode
    #define rd rd_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #ifdef ACC_MODEL
    REGS[rd_bit ^ 0x1].lock();
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDDA_reg::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs
    #define rd rd_regs


    address = rs1 + rs2;
    supervisor = PSR[key_S];

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDDA_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute
    #define rd rd_execute


    notAligned = (address & 0x00000007) != 0;
    #ifdef ACC_MODEL
    if(notAligned || !supervisor){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDDA_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_memory
    #define WIM WIM_memory
    #define TBR TBR_memory
    #define Y Y_memory
    #define PC PC_memory
    #define NPC NPC_memory
    #define GLOBAL GLOBAL_memory
    #define WINREGS WINREGS_memory
    #define ASR ASR_memory
    #define FP FP_memory
    #define LR LR_memory
    #define SP SP_memory
    #define PCR PCR_memory
    #define REGS REGS_memory
    #define rs1 rs1_memory
    #define rs2 rs2_memory
    #define rd rd_memory


    #ifdef ACC_MODEL
    if(notAligned || !supervisor){
        flush();
    }
    else{
        #endif
        readValue = dataMem.read_dword(address);
        #ifdef ACC_MODEL
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDDA_reg::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rs1 rs1_exception
    #define rs2 rs2_exception
    #define rd rd_exception


    if(!supervisor){
        RaiseException(pcounter, npcounter, PRIVILEDGE_INSTR);
    }
    if(notAligned){
        RaiseException(pcounter, npcounter, MEM_ADDR_NOT_ALIGNED);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDDA_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb
    #define rd rd_wb


    if(rd_bit % 2 == 0){
        rd = (unsigned int)(readValue & 0x00000000FFFFFFFFLL);
        REGS[rd_bit + 1] = (unsigned int)((readValue >> 32) & 0x00000000FFFFFFFFLL);
    }
    else{
        REGS[rd_bit - 1] = (unsigned int)(readValue & 0x00000000FFFFFFFFLL);
        rd = (unsigned int)((readValue >> 32) & 0x00000000FFFFFFFFLL);
    }
    #ifdef ACC_MODEL
    unlockQueue[0].push_back(REGS[rd_bit ^ 0x1].getPipeReg());
    #endif
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    #undef rd
    return this->stageCycles;
}

std::string leon3_accat_trap::LDDA_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::LDDA_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDDA_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::LDDA_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::LDDA_reg::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::LDDA_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDDA_reg::lockRegs_regs(){

}

bool leon3_accat_trap::LDDA_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDDA_reg::lockRegs_execute(){

}

bool leon3_accat_trap::LDDA_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDDA_reg::lockRegs_memory(){

}

bool leon3_accat_trap::LDDA_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDDA_reg::lockRegs_exception(){

}

bool leon3_accat_trap::LDDA_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDDA_reg::lockRegs_wb(){

}

void leon3_accat_trap::LDDA_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::LDDA_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::LDDA_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::LDDA_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::LDDA_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::LDDA_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::LDDA_reg::replicate() const throw(){
    return new LDDA_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::LDDA_reg::getInstructionName() const throw(){
    return "LDDA_reg";
}

unsigned int leon3_accat_trap::LDDA_reg::getId() const throw(){
    return 17;
}

void leon3_accat_trap::LDDA_reg::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->asi = (bitString & 0x1fe0) >> 5;
}

std::string leon3_accat_trap::LDDA_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "ldda r";
    oss << this->rs1_bit;
    oss << "+r";
    oss << this->rs2_bit;
    oss << " ";
    oss << this->asi;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::LDDA_reg::LDDA_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
}

leon3_accat_trap::LDDA_reg::~LDDA_reg(){

}
unsigned int leon3_accat_trap::SLL_reg::behavior_fetch( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SLL_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SLL_reg::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    rs1_op = rs1;
    rs2_op = rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SLL_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    result = rs1_op << (rs2_op & 0x0000001f);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SLL_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SLL_reg::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SLL_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::SLL_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::SLL_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SLL_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::SLL_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::SLL_reg::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::SLL_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SLL_reg::lockRegs_regs(){

}

bool leon3_accat_trap::SLL_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SLL_reg::lockRegs_execute(){

}

bool leon3_accat_trap::SLL_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SLL_reg::lockRegs_memory(){

}

bool leon3_accat_trap::SLL_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SLL_reg::lockRegs_exception(){

}

bool leon3_accat_trap::SLL_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SLL_reg::lockRegs_wb(){

}

void leon3_accat_trap::SLL_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::SLL_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::SLL_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::SLL_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::SLL_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::SLL_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::SLL_reg::replicate() const throw(){
    return new SLL_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::SLL_reg::getInstructionName() const throw(){
    return "SLL_reg";
}

unsigned int leon3_accat_trap::SLL_reg::getId() const throw(){
    return 62;
}

void leon3_accat_trap::SLL_reg::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
}

std::string leon3_accat_trap::SLL_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "sll r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::SLL_reg::SLL_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::SLL_reg::~SLL_reg(){

}
unsigned int leon3_accat_trap::RESTORE_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::RESTORE_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rd rd_decode
    #define rs1 rs1_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif
    result = rs1 + SignExtend(simm13, 13);

    okNewWin = IncrementRegWindow();
    #ifdef ACC_MODEL
    if(!okNewWin){
        flush();
    }
    else{
        rd.lock();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::RESTORE_imm::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs


    #ifdef ACC_MODEL
    if(!okNewWin){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::RESTORE_imm::behavior_execute( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute


    #ifdef ACC_MODEL
    if(!okNewWin){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::RESTORE_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_memory
    #define WIM WIM_memory
    #define TBR TBR_memory
    #define Y Y_memory
    #define PC PC_memory
    #define NPC NPC_memory
    #define GLOBAL GLOBAL_memory
    #define WINREGS WINREGS_memory
    #define ASR ASR_memory
    #define FP FP_memory
    #define LR LR_memory
    #define SP SP_memory
    #define PCR PCR_memory
    #define REGS REGS_memory
    #define rd rd_memory
    #define rs1 rs1_memory


    #ifdef ACC_MODEL
    if(!okNewWin){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::RESTORE_imm::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rd rd_exception
    #define rs1 rs1_exception


    if(!okNewWin){
        RaiseException(pcounter, npcounter, WINDOW_UNDERFLOW);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::RESTORE_imm::behavior_wb( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb


    if(okNewWin){
        rd = result;
        #ifdef ACC_MODEL
        unlockQueue[0].push_back(rd.getPipeReg());
        #endif
    }
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::RESTORE_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->PSR_decode.isLocked()){
        retVal += "PSR - ";
    }
    return retVal;
}

bool leon3_accat_trap::RESTORE_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::RESTORE_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::RESTORE_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->PSR_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::RESTORE_imm::lockRegs_decode(){
    this->PSR_pipe.lock();
}

bool leon3_accat_trap::RESTORE_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::RESTORE_imm::lockRegs_regs(){

}

bool leon3_accat_trap::RESTORE_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::RESTORE_imm::lockRegs_execute(){

}

bool leon3_accat_trap::RESTORE_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::RESTORE_imm::lockRegs_memory(){

}

bool leon3_accat_trap::RESTORE_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::RESTORE_imm::lockRegs_exception(){

}

bool leon3_accat_trap::RESTORE_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::RESTORE_imm::lockRegs_wb(){

}

void leon3_accat_trap::RESTORE_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
}

void leon3_accat_trap::RESTORE_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
}

void leon3_accat_trap::RESTORE_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
}

void leon3_accat_trap::RESTORE_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
}

void leon3_accat_trap::RESTORE_imm::getUnlock_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
}

void leon3_accat_trap::RESTORE_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
}

Instruction * leon3_accat_trap::RESTORE_imm::replicate() const throw(){
    return new RESTORE_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::RESTORE_imm::getInstructionName() const throw(){
    return "RESTORE_imm";
}

unsigned int leon3_accat_trap::RESTORE_imm::getId() const throw(){
    return 115;
}

void leon3_accat_trap::RESTORE_imm::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::RESTORE_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "restore";
    oss << " r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::RESTORE_imm::RESTORE_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::RESTORE_imm::~RESTORE_imm(){

}
unsigned int leon3_accat_trap::LD_imm::behavior_fetch( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch
    #define rd rd_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LD_imm::behavior_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rs1 rs1_decode
    #define rd rd_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LD_imm::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs
    #define rd rd_regs


    address = rs1 + SignExtend(simm13, 13);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LD_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rs1 rs1_execute
    #define rd rd_execute


    notAligned = (address & 0x00000003) != 0;
    #ifdef ACC_MODEL
    if(notAligned){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LD_imm::behavior_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_memory
    #define WIM WIM_memory
    #define TBR TBR_memory
    #define Y Y_memory
    #define PC PC_memory
    #define NPC NPC_memory
    #define GLOBAL GLOBAL_memory
    #define WINREGS WINREGS_memory
    #define ASR ASR_memory
    #define FP FP_memory
    #define LR LR_memory
    #define SP SP_memory
    #define PCR PCR_memory
    #define REGS REGS_memory
    #define rs1 rs1_memory
    #define rd rd_memory


    readValue = dataMem.read_word(address);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LD_imm::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rs1 rs1_exception
    #define rd rd_exception


    if(notAligned){
        RaiseException(pcounter, npcounter, MEM_ADDR_NOT_ALIGNED);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LD_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rs1 rs1_wb
    #define rd rd_wb


    rd = readValue;
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

std::string leon3_accat_trap::LD_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    return retVal;
}

bool leon3_accat_trap::LD_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LD_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::LD_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::LD_imm::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::LD_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LD_imm::lockRegs_regs(){

}

bool leon3_accat_trap::LD_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LD_imm::lockRegs_execute(){

}

bool leon3_accat_trap::LD_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LD_imm::lockRegs_memory(){

}

bool leon3_accat_trap::LD_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LD_imm::lockRegs_exception(){

}

bool leon3_accat_trap::LD_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LD_imm::lockRegs_wb(){

}

void leon3_accat_trap::LD_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::LD_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::LD_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::LD_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::LD_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::LD_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::LD_imm::replicate() const throw(){
    return new LD_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::LD_imm::getInstructionName() const throw(){
    return "LD_imm";
}

unsigned int leon3_accat_trap::LD_imm::getId() const throw(){
    return 8;
}

void leon3_accat_trap::LD_imm::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::LD_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "ld r";
    oss << this->rs1_bit;
    oss << "+";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::LD_imm::LD_imm( PipelineRegister & PSR_pipe, PipelineRegister & \
    WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
}

leon3_accat_trap::LD_imm::~LD_imm(){

}
unsigned int leon3_accat_trap::TRAP_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TRAP_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rs1 rs1_decode
    #define rs2 rs2_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #ifndef ACC_MODEL
    bool icc_z = PSR[key_ICC_z];
    bool icc_n = PSR[key_ICC_n];
    bool icc_v = PSR[key_ICC_v];
    bool icc_c = PSR[key_ICC_c];
    #else
    bool icc_z = PSR_execute[key_ICC_z];
    bool icc_n = PSR_execute[key_ICC_n];
    bool icc_v = PSR_execute[key_ICC_v];
    bool icc_c = PSR_execute[key_ICC_c];
    #endif
    raiseException = (cond == 0x8) ||
    ((cond == 0x9) && !icc_z) ||
    ((cond == 0x1) && icc_z) ||
    ((cond == 0xa) && !icc_z && (icc_n == icc_v)) ||
    ((cond == 0x2) && (icc_z || (icc_n != icc_v))) ||
    ((cond == 0xb) && (icc_n == icc_v)) ||
    ((cond == 0x3) && (icc_n != icc_v)) ||
    ((cond == 0xc) && !icc_c && !icc_z) ||
    ((cond == 0x4) && (icc_c || icc_z)) ||
    ((cond == 0xd) && !icc_c) ||
    ((cond == 0x5) && icc_c) ||
    ((cond == 0xe) && !icc_n) ||
    ((cond == 0x6) && icc_n) ||
    ((cond == 0xf) && !icc_v) ||
    ((cond == 0x7) && icc_v);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TRAP_reg::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TRAP_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TRAP_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TRAP_reg::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rs1 rs1_exception
    #define rs2 rs2_exception


    if(raiseException){
        stall(4);
        RaiseException(pcounter, npcounter, TRAP_INSTRUCTION, (rs1 + rs2) & 0x0000007F);
    }
    #ifndef ACC_MODEL
    else{
        PC = npcounter;
        NPC = npcounter + 4;
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::TRAP_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

std::string leon3_accat_trap::TRAP_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    if(this->PSR_decode.isLocked()){
        retVal += "PSR - ";
    }
    return retVal;
}

bool leon3_accat_trap::TRAP_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TRAP_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::TRAP_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    regLocked = this->PSR_execute.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::TRAP_reg::lockRegs_decode(){

}

bool leon3_accat_trap::TRAP_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TRAP_reg::lockRegs_regs(){

}

bool leon3_accat_trap::TRAP_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TRAP_reg::lockRegs_execute(){

}

bool leon3_accat_trap::TRAP_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TRAP_reg::lockRegs_memory(){

}

bool leon3_accat_trap::TRAP_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TRAP_reg::lockRegs_exception(){

}

bool leon3_accat_trap::TRAP_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::TRAP_reg::lockRegs_wb(){

}

void leon3_accat_trap::TRAP_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::TRAP_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::TRAP_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::TRAP_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::TRAP_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

void leon3_accat_trap::TRAP_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){

}

Instruction * leon3_accat_trap::TRAP_reg::replicate() const throw(){
    return new TRAP_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::TRAP_reg::getInstructionName() const throw(){
    return "TRAP_reg";
}

unsigned int leon3_accat_trap::TRAP_reg::getId() const throw(){
    return 124;
}

void leon3_accat_trap::TRAP_reg::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
    this->reserved1 = (bitString & 0x20000000) >> 29;
    this->cond = (bitString & 0x1e000000) >> 25;
    this->asi = (bitString & 0x1fe0) >> 5;
}

std::string leon3_accat_trap::TRAP_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "t";
    switch(this->cond){
        case 0:{
            oss << "n";
        break;}
        case 1:{
            oss << "e";
        break;}
        case 2:{
            oss << "le";
        break;}
        case 3:{
            oss << "l";
        break;}
        case 4:{
            oss << "leu";
        break;}
        case 6:{
            oss << "neg";
        break;}
        case 7:{
            oss << "vs";
        break;}
        case 8:{
            oss << "a";
        break;}
        case 9:{
            oss << "ne";
        break;}
        case 10:{
            oss << "cs";
        break;}
        case 11:{
            oss << "ge";
        break;}
        case 12:{
            oss << "gu";
        break;}
        case 13:{
            oss << "cc";
        break;}
        case 14:{
            oss << "pos";
        break;}
        case 15:{
            oss << "vc";
        break;}
        default:
        break;
    }
    oss << " r";
    oss << this->rs1_bit;
    oss << "+r";
    oss << this->rs2_bit;
    return oss.str();
}

leon3_accat_trap::TRAP_reg::TRAP_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::TRAP_reg::~TRAP_reg(){

}
unsigned int leon3_accat_trap::LDUB_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch
    #define rd rd_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDUB_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDUB_imm::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs
    #define rd rd_regs


    address = rs1 + SignExtend(simm13, 13);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDUB_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDUB_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_memory
    #define WIM WIM_memory
    #define TBR TBR_memory
    #define Y Y_memory
    #define PC PC_memory
    #define NPC NPC_memory
    #define GLOBAL GLOBAL_memory
    #define WINREGS WINREGS_memory
    #define ASR ASR_memory
    #define FP FP_memory
    #define LR LR_memory
    #define SP SP_memory
    #define PCR PCR_memory
    #define REGS REGS_memory
    #define rs1 rs1_memory
    #define rd rd_memory


    readValue = dataMem.read_byte(address);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDUB_imm::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::LDUB_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rs1 rs1_wb
    #define rd rd_wb


    rd = readValue;
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rd
    return this->stageCycles;
}

std::string leon3_accat_trap::LDUB_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    return retVal;
}

bool leon3_accat_trap::LDUB_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDUB_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::LDUB_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::LDUB_imm::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::LDUB_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDUB_imm::lockRegs_regs(){

}

bool leon3_accat_trap::LDUB_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDUB_imm::lockRegs_execute(){

}

bool leon3_accat_trap::LDUB_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDUB_imm::lockRegs_memory(){

}

bool leon3_accat_trap::LDUB_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDUB_imm::lockRegs_exception(){

}

bool leon3_accat_trap::LDUB_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::LDUB_imm::lockRegs_wb(){

}

void leon3_accat_trap::LDUB_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::LDUB_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::LDUB_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::LDUB_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::LDUB_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::LDUB_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::LDUB_imm::replicate() const throw(){
    return new LDUB_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::LDUB_imm::getInstructionName() const throw(){
    return "LDUB_imm";
}

unsigned int leon3_accat_trap::LDUB_imm::getId() const throw(){
    return 4;
}

void leon3_accat_trap::LDUB_imm::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::LDUB_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "ldub r";
    oss << this->rs1_bit;
    oss << "+";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::LDUB_imm::LDUB_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
}

leon3_accat_trap::LDUB_imm::~LDUB_imm(){

}
unsigned int leon3_accat_trap::RETT_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::RETT_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rd rd_decode
    #define rs1 rs1_decode
    #define rs2 rs2_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif
    targetAddr = rs1 + rs2;
    newCwp = ((unsigned int)(PSR[key_CWP] + 1)) % NUM_REG_WIN;
    exceptionEnabled = PSR[key_ET];
    supervisor = PSR[key_S];
    invalidWin = ((0x01 << (newCwp)) & WIM) != 0;
    notAligned = (targetAddr & 0x00000003) != 0;
    if(!exceptionEnabled && supervisor && !invalidWin && !notAligned){
        #ifdef ACC_MODEL
        PC = targetAddr;
        NPC = targetAddr + 4;
        #else
        PC = npcounter;
        NPC = targetAddr;
        #endif
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::RETT_reg::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    #ifdef ACC_MODEL
    if(exceptionEnabled || !supervisor || invalidWin || notAligned){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::RETT_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    if(exceptionEnabled || !supervisor || invalidWin || notAligned){
        flush();
    }
    else{
        PSR.immediateWrite((PSR & 0xFFFFFF40) | (newCwp | 0x20 | (PSR[key_PS] << 7)));
        stall(2);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::RETT_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_memory
    #define WIM WIM_memory
    #define TBR TBR_memory
    #define Y Y_memory
    #define PC PC_memory
    #define NPC NPC_memory
    #define GLOBAL GLOBAL_memory
    #define WINREGS WINREGS_memory
    #define ASR ASR_memory
    #define FP FP_memory
    #define LR LR_memory
    #define SP SP_memory
    #define PCR PCR_memory
    #define REGS REGS_memory
    #define rd rd_memory
    #define rs1 rs1_memory
    #define rs2 rs2_memory


    #ifdef ACC_MODEL
    if(exceptionEnabled || !supervisor || invalidWin || notAligned){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::RETT_reg::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rd rd_exception
    #define rs1 rs1_exception
    #define rs2 rs2_exception


    if(exceptionEnabled){
        if(supervisor){
            RaiseException(pcounter, npcounter, ILLEGAL_INSTR);
        }
        else{
            RaiseException(pcounter, npcounter, PRIVILEDGE_INSTR);
        }
    }
    else if(!supervisor || invalidWin || notAligned){
        THROW_EXCEPTION("Invalid processor mode during execution of the RETT instruction \
            - supervisor: " << supervisor << " newCwp: " << std::hex << std::showbase << newCwp \
            << " targetAddr: " << std::hex << std::showbase << targetAddr);
    }
    else{
        #ifndef ACC_MODEL
        //Functional model: we simply immediately update the alias
        for(int i = 8; i < 32; i++){
            REGS[i].updateAlias(WINREGS[(newCwp*16 + i - 8) & 0x7f]);
        }
        #else
        //Cycle accurate model: we have to update the alias using the pipeline register
        //We update the aliases for this stage and for all the preceding ones (we are in the
        //execute stage and we need to update fetch, decode, and register read and execute)
        for(int i = 8; i < 32; i++){
            REGS_fetch[i].updateAlias(WINREGS_pipe[(newCwp*16 + i - 8) & 0x7f]);
            REGS_decode[i].updateAlias(WINREGS_pipe[(newCwp*16 + i - 8) & 0x7f]);
            REGS_regs[i].updateAlias(WINREGS_pipe[(newCwp*16 + i - 8) & 0x7f]);
            REGS_execute[i].updateAlias(WINREGS_pipe[(newCwp*16 + i - 8) & 0x7f]);
            REGS_memory[i].updateAlias(WINREGS_pipe[(newCwp*16 + i - 8) & 0x7f]);
            REGS_exception[i].updateAlias(WINREGS_pipe[(newCwp*16 + i - 8) & 0x7f]);
        }
        #endif

    }
    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::RETT_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb


    #ifdef ACC_MODEL
    if(exceptionEnabled || !supervisor || invalidWin || notAligned){
        flush();
    }
    #endif
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::RETT_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    if(this->PSR_decode.isLocked()){
        retVal += "PSR - ";
    }
    return retVal;
}

bool leon3_accat_trap::RETT_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::RETT_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::RETT_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    regLocked = this->PSR_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::RETT_reg::lockRegs_decode(){
    this->rd_decode.lock();
    this->PSR_pipe.lock();
}

bool leon3_accat_trap::RETT_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::RETT_reg::lockRegs_regs(){

}

bool leon3_accat_trap::RETT_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::RETT_reg::lockRegs_execute(){

}

bool leon3_accat_trap::RETT_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::RETT_reg::lockRegs_memory(){

}

bool leon3_accat_trap::RETT_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::RETT_reg::lockRegs_exception(){

}

bool leon3_accat_trap::RETT_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::RETT_reg::lockRegs_wb(){

}

void leon3_accat_trap::RETT_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::RETT_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::RETT_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::RETT_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::RETT_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::RETT_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::RETT_reg::replicate() const throw(){
    return new RETT_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::RETT_reg::getInstructionName() const throw(){
    return "RETT_reg";
}

unsigned int leon3_accat_trap::RETT_reg::getId() const throw(){
    return 122;
}

void leon3_accat_trap::RETT_reg::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
}

std::string leon3_accat_trap::RETT_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "rett r";
    oss << this->rs1_bit;
    oss << "+r";
    oss << this->rs2_bit;
    return oss.str();
}

leon3_accat_trap::RETT_reg::RETT_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::RETT_reg::~RETT_reg(){

}
unsigned int leon3_accat_trap::SDIVcc_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SDIVcc_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rd rd_decode
    #define rs1 rs1_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SDIVcc_imm::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs


    rs1_op = rs1;
    rs2_op = SignExtend(simm13, 13);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SDIVcc_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute


    exception = rs2_op == 0;
    if(!exception){
        #ifndef ACC_MODEL
        long long res64 = ((long long)((((unsigned long long)Y) << 32) | (unsigned long long)rs1_op))/((long \
            long)((int)rs2_op));
        #else
        long long res64 = ((long long)((((unsigned long long)Y_execute) << 32) | (unsigned \
            long long)rs1_op))/((long long)((int)rs2_op));
        #endif
        temp_V = (res64 & 0xFFFFFFFF80000000LL) != 0 && (res64 & 0xFFFFFFFF80000000LL) != \
            0xFFFFFFFF80000000LL;
        if(temp_V){
            if(res64 > 0){
                result = 0x7FFFFFFF;
            }
            else{
                result = 0x80000000;
            }
        }
        else{
            result = (unsigned int)(res64 & 0x00000000FFFFFFFFLL);
        }
    }
    stall(2);


    if(!exception){
        PSR[key_ICC_n] = ((result & 0x80000000) >> 31);
        PSR[key_ICC_z] = (result == 0);
        PSR[key_ICC_v] = temp_V;
        PSR[key_ICC_c] = 0;
    }
    unlockQueue[0].push_back(&PSR_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SDIVcc_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SDIVcc_imm::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rd rd_exception
    #define rs1 rs1_exception


    if(exception){
        RaiseException(pcounter, npcounter, DIV_ZERO);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SDIVcc_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[33].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::SDIVcc_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->Y_decode.isLocked()){
        retVal += "Y - ";
    }
    if(this->PSR_decode.isLocked()){
        retVal += "PSR - ";
    }
    return retVal;
}

bool leon3_accat_trap::SDIVcc_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SDIVcc_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::SDIVcc_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->Y_execute.isLocked() || regLocked;
    regLocked = this->PSR_execute.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::SDIVcc_imm::lockRegs_decode(){
    this->rd_decode.lock();
    this->PSR_pipe.lock();
}

bool leon3_accat_trap::SDIVcc_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SDIVcc_imm::lockRegs_regs(){

}

bool leon3_accat_trap::SDIVcc_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SDIVcc_imm::lockRegs_execute(){

}

bool leon3_accat_trap::SDIVcc_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SDIVcc_imm::lockRegs_memory(){

}

bool leon3_accat_trap::SDIVcc_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SDIVcc_imm::lockRegs_exception(){

}

bool leon3_accat_trap::SDIVcc_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SDIVcc_imm::lockRegs_wb(){

}

void leon3_accat_trap::SDIVcc_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::SDIVcc_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::SDIVcc_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::SDIVcc_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::SDIVcc_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::SDIVcc_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::SDIVcc_imm::replicate() const throw(){
    return new SDIVcc_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::SDIVcc_imm::getInstructionName() const throw(){
    return "SDIVcc_imm";
}

unsigned int leon3_accat_trap::SDIVcc_imm::getId() const throw(){
    return 111;
}

void leon3_accat_trap::SDIVcc_imm::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::SDIVcc_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "sdivcc";
    oss << " r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::SDIVcc_imm::SDIVcc_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::SDIVcc_imm::~SDIVcc_imm(){

}
unsigned int leon3_accat_trap::SAVE_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SAVE_reg::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rd rd_decode
    #define rs1 rs1_decode
    #define rs2 rs2_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif
    result = rs1 + rs2;

    okNewWin = DecrementRegWindow();
    #ifdef ACC_MODEL
    if(!okNewWin){
        flush();
    }
    else{
        rd.lock();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SAVE_reg::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    #ifdef ACC_MODEL
    if(!okNewWin){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SAVE_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    #ifdef ACC_MODEL
    if(!okNewWin){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SAVE_reg::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_memory
    #define WIM WIM_memory
    #define TBR TBR_memory
    #define Y Y_memory
    #define PC PC_memory
    #define NPC NPC_memory
    #define GLOBAL GLOBAL_memory
    #define WINREGS WINREGS_memory
    #define ASR ASR_memory
    #define FP FP_memory
    #define LR LR_memory
    #define SP SP_memory
    #define PCR PCR_memory
    #define REGS REGS_memory
    #define rd rd_memory
    #define rs1 rs1_memory
    #define rs2 rs2_memory


    #ifdef ACC_MODEL
    if(!okNewWin){
        flush();
    }
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SAVE_reg::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rd rd_exception
    #define rs1 rs1_exception
    #define rs2 rs2_exception


    if(!okNewWin){
        RaiseException(pcounter, npcounter, WINDOW_OVERFLOW);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::SAVE_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb


    if(okNewWin){
        rd = result;
        #ifdef ACC_MODEL
        unlockQueue[0].push_back(rd.getPipeReg());
        #endif
    }
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::SAVE_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    if(this->PSR_decode.isLocked()){
        retVal += "PSR - ";
    }
    return retVal;
}

bool leon3_accat_trap::SAVE_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SAVE_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::SAVE_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    regLocked = this->PSR_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::SAVE_reg::lockRegs_decode(){
    this->PSR_pipe.lock();
}

bool leon3_accat_trap::SAVE_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SAVE_reg::lockRegs_regs(){

}

bool leon3_accat_trap::SAVE_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SAVE_reg::lockRegs_execute(){

}

bool leon3_accat_trap::SAVE_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SAVE_reg::lockRegs_memory(){

}

bool leon3_accat_trap::SAVE_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SAVE_reg::lockRegs_exception(){

}

bool leon3_accat_trap::SAVE_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::SAVE_reg::lockRegs_wb(){

}

void leon3_accat_trap::SAVE_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
}

void leon3_accat_trap::SAVE_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
}

void leon3_accat_trap::SAVE_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
}

void leon3_accat_trap::SAVE_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
}

void leon3_accat_trap::SAVE_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
}

void leon3_accat_trap::SAVE_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
}

Instruction * leon3_accat_trap::SAVE_reg::replicate() const throw(){
    return new SAVE_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::SAVE_reg::getInstructionName() const throw(){
    return "SAVE_reg";
}

unsigned int leon3_accat_trap::SAVE_reg::getId() const throw(){
    return 114;
}

void leon3_accat_trap::SAVE_reg::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
}

std::string leon3_accat_trap::SAVE_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "save";
    oss << " r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::SAVE_reg::SAVE_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::SAVE_reg::~SAVE_reg(){

}
unsigned int leon3_accat_trap::OR_reg::behavior_fetch( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::OR_reg::behavior_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::OR_reg::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    rs1_op = rs1;
    rs2_op = rs2;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::OR_reg::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    result = rs1_op | rs2_op;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::OR_reg::behavior_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::OR_reg::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::OR_reg::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::OR_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::OR_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::OR_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::OR_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::OR_reg::lockRegs_decode(){
    this->rd_decode.lock();
}

bool leon3_accat_trap::OR_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::OR_reg::lockRegs_regs(){

}

bool leon3_accat_trap::OR_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::OR_reg::lockRegs_execute(){

}

bool leon3_accat_trap::OR_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::OR_reg::lockRegs_memory(){

}

bool leon3_accat_trap::OR_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::OR_reg::lockRegs_exception(){

}

bool leon3_accat_trap::OR_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::OR_reg::lockRegs_wb(){

}

void leon3_accat_trap::OR_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::OR_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::OR_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::OR_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::OR_reg::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::OR_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::OR_reg::replicate() const throw(){
    return new OR_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::OR_reg::getInstructionName() const throw(){
    return "OR_reg";
}

unsigned int leon3_accat_trap::OR_reg::getId() const throw(){
    return 46;
}

void leon3_accat_trap::OR_reg::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
}

std::string leon3_accat_trap::OR_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "or r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::OR_reg::OR_reg( PipelineRegister & PSR_pipe, PipelineRegister & \
    WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::OR_reg::~OR_reg(){

}
unsigned int leon3_accat_trap::ORcc_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ORcc_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ORcc_imm::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs


    rs1_op = rs1;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ORcc_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute


    result = rs1_op | SignExtend(simm13, 13);


    PSR[key_ICC_n] = ((result & 0x80000000) >> 31);
    PSR[key_ICC_z] = (result == 0);
    PSR[key_ICC_v] = 0;
    PSR[key_ICC_c] = 0;
    unlockQueue[0].push_back(&PSR_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ORcc_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ORcc_imm::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ORcc_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::ORcc_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    return retVal;
}

bool leon3_accat_trap::ORcc_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ORcc_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::ORcc_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::ORcc_imm::lockRegs_decode(){
    this->rd_decode.lock();
    this->PSR_pipe.lock();
}

bool leon3_accat_trap::ORcc_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ORcc_imm::lockRegs_regs(){

}

bool leon3_accat_trap::ORcc_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ORcc_imm::lockRegs_execute(){

}

bool leon3_accat_trap::ORcc_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ORcc_imm::lockRegs_memory(){

}

bool leon3_accat_trap::ORcc_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ORcc_imm::lockRegs_exception(){

}

bool leon3_accat_trap::ORcc_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ORcc_imm::lockRegs_wb(){

}

void leon3_accat_trap::ORcc_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::ORcc_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::ORcc_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::ORcc_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::ORcc_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::ORcc_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::ORcc_imm::replicate() const throw(){
    return new ORcc_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::ORcc_imm::getInstructionName() const throw(){
    return "ORcc_imm";
}

unsigned int leon3_accat_trap::ORcc_imm::getId() const throw(){
    return 47;
}

void leon3_accat_trap::ORcc_imm::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::ORcc_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "orcc r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::ORcc_imm::ORcc_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::ORcc_imm::~ORcc_imm(){

}
unsigned int leon3_accat_trap::CALL::behavior_fetch( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    return this->stageCycles;
}

unsigned int leon3_accat_trap::CALL::behavior_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    unsigned int target = pcounter + (disp30 << 2);
    #ifdef ACC_MODEL
    PC = target;
    NPC = target + 4;
    #else
    PC = npcounter;
    NPC = target;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    return this->stageCycles;
}

unsigned int leon3_accat_trap::CALL::behavior_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::CALL::behavior_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::CALL::behavior_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::CALL::behavior_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::CALL::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb


    REGS[15] = pcounter;
    unlockQueue[0].push_back(REGS_fetch[15].getReg());
    unlockQueue[0].push_back(REGS_decode[15].getReg());
    unlockQueue[0].push_back(REGS_regs[15].getReg());
    unlockQueue[0].push_back(REGS_execute[15].getReg());
    unlockQueue[0].push_back(REGS_memory[15].getReg());
    unlockQueue[0].push_back(REGS_exception[15].getReg());
    unlockQueue[0].push_back(REGS_wb[15].getReg());
    unlockQueue[0].push_back(REGS_wb[15].getPipeReg()->getRegister());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    return this->stageCycles;
}

std::string leon3_accat_trap::CALL::printBusyRegs(){
    std::string retVal = "";
    return retVal;
}

bool leon3_accat_trap::CALL::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::CALL::lockRegs_fetch(){

}

bool leon3_accat_trap::CALL::checkHazard_decode(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::CALL::lockRegs_decode(){
    this->REGS_decode[15].lock();
}

bool leon3_accat_trap::CALL::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::CALL::lockRegs_regs(){

}

bool leon3_accat_trap::CALL::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::CALL::lockRegs_execute(){

}

bool leon3_accat_trap::CALL::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::CALL::lockRegs_memory(){

}

bool leon3_accat_trap::CALL::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::CALL::lockRegs_exception(){

}

bool leon3_accat_trap::CALL::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::CALL::lockRegs_wb(){

}

void leon3_accat_trap::CALL::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(REGS_fetch[15].getReg());
    unlockQueue[0].push_back(REGS_decode[15].getReg());
    unlockQueue[0].push_back(REGS_regs[15].getReg());
    unlockQueue[0].push_back(REGS_execute[15].getReg());
    unlockQueue[0].push_back(REGS_memory[15].getReg());
    unlockQueue[0].push_back(REGS_exception[15].getReg());
    unlockQueue[0].push_back(REGS_wb[15].getReg());
    unlockQueue[0].push_back(REGS_decode[15].getPipeReg()->getRegister());
}

void leon3_accat_trap::CALL::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(REGS_fetch[15].getReg());
    unlockQueue[0].push_back(REGS_decode[15].getReg());
    unlockQueue[0].push_back(REGS_regs[15].getReg());
    unlockQueue[0].push_back(REGS_execute[15].getReg());
    unlockQueue[0].push_back(REGS_memory[15].getReg());
    unlockQueue[0].push_back(REGS_exception[15].getReg());
    unlockQueue[0].push_back(REGS_wb[15].getReg());
    unlockQueue[0].push_back(REGS_regs[15].getPipeReg()->getRegister());
}

void leon3_accat_trap::CALL::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(REGS_fetch[15].getReg());
    unlockQueue[0].push_back(REGS_decode[15].getReg());
    unlockQueue[0].push_back(REGS_regs[15].getReg());
    unlockQueue[0].push_back(REGS_execute[15].getReg());
    unlockQueue[0].push_back(REGS_memory[15].getReg());
    unlockQueue[0].push_back(REGS_exception[15].getReg());
    unlockQueue[0].push_back(REGS_wb[15].getReg());
    unlockQueue[0].push_back(REGS_execute[15].getPipeReg()->getRegister());
}

void leon3_accat_trap::CALL::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(REGS_fetch[15].getReg());
    unlockQueue[0].push_back(REGS_decode[15].getReg());
    unlockQueue[0].push_back(REGS_regs[15].getReg());
    unlockQueue[0].push_back(REGS_execute[15].getReg());
    unlockQueue[0].push_back(REGS_memory[15].getReg());
    unlockQueue[0].push_back(REGS_exception[15].getReg());
    unlockQueue[0].push_back(REGS_wb[15].getReg());
    unlockQueue[0].push_back(REGS_memory[15].getPipeReg()->getRegister());
}

void leon3_accat_trap::CALL::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(REGS_fetch[15].getReg());
    unlockQueue[0].push_back(REGS_decode[15].getReg());
    unlockQueue[0].push_back(REGS_regs[15].getReg());
    unlockQueue[0].push_back(REGS_execute[15].getReg());
    unlockQueue[0].push_back(REGS_memory[15].getReg());
    unlockQueue[0].push_back(REGS_exception[15].getReg());
    unlockQueue[0].push_back(REGS_wb[15].getReg());
    unlockQueue[0].push_back(REGS_exception[15].getPipeReg()->getRegister());
}

void leon3_accat_trap::CALL::getUnlock_wb( std::map< unsigned int, std::vector< Register \
    * > > & unlockQueue ){
    unlockQueue[0].push_back(REGS_fetch[15].getReg());
    unlockQueue[0].push_back(REGS_decode[15].getReg());
    unlockQueue[0].push_back(REGS_regs[15].getReg());
    unlockQueue[0].push_back(REGS_execute[15].getReg());
    unlockQueue[0].push_back(REGS_memory[15].getReg());
    unlockQueue[0].push_back(REGS_exception[15].getReg());
    unlockQueue[0].push_back(REGS_wb[15].getReg());
    unlockQueue[0].push_back(REGS_wb[15].getPipeReg()->getRegister());
}

Instruction * leon3_accat_trap::CALL::replicate() const throw(){
    return new CALL(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::CALL::getInstructionName() const throw(){
    return "CALL";
}

unsigned int leon3_accat_trap::CALL::getId() const throw(){
    return 118;
}

void leon3_accat_trap::CALL::setParams( const unsigned int & bitString ) throw(){
    this->disp30 = (bitString & 0x3fffffff);
}

std::string leon3_accat_trap::CALL::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "call ";
    oss << this->disp30;
    return oss.str();
}

leon3_accat_trap::CALL::CALL( PipelineRegister & PSR_pipe, PipelineRegister & WIM_pipe, \
    PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister & PC_pipe, \
    PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister * WINREGS_pipe, \
    PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, Reg32_2 & \
    TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, RegisterBankClass \
    & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias & FP_fetch, Alias \
    & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, Reg32_0 & PSR_decode, \
    Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, Reg32_3 & PC_decode, \
    Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 * WINREGS_decode, \
    Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias & SP_decode, Alias \
    & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 & WIM_regs, Reg32_2 \
    & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, RegisterBankClass \
    & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias & FP_regs, Alias \
    & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, Reg32_0 & PSR_execute, \
    Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, Reg32_3 & PC_execute, \
    Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, Reg32_3 * WINREGS_execute, \
    Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, Alias & SP_execute, \
    Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, Reg32_1 & WIM_memory, \
    Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, Reg32_3 & NPC_memory, \
    RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, Reg32_3 * ASR_memory, \
    Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias & PCR_memory, Alias \
    * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, Reg32_2 & TBR_exception, \
    Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & NPC_exception, RegisterBankClass \
    & GLOBAL_exception, Reg32_3 * WINREGS_exception, Reg32_3 * ASR_exception, Alias & \
    FP_exception, Alias & LR_exception, Alias & SP_exception, Alias & PCR_exception, \
    Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, Reg32_2 & TBR_wb, Reg32_3 \
    & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass & GLOBAL_wb, Reg32_3 \
    * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, Alias & SP_wb, Alias \
    & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & dataMem, PinTLM_out_32 \
    & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, \
    GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, \
    NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, \
    PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
    GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
    REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
    WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
    WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
    ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
    WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
    ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
    WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
    WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
    REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
    ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){

}

leon3_accat_trap::CALL::~CALL(){

}
unsigned int leon3_accat_trap::WRITEpsr_reg::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rs1 rs1_fetch
    #define rs2 rs2_fetch

    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif

    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEpsr_reg::behavior_decode( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode
    #define rs1 rs1_decode
    #define rs2 rs2_decode

    #ifdef ACC_MODEL
    npcounter = PC;
    #endif

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEpsr_reg::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rs1 rs1_regs
    #define rs2 rs2_regs


    // Note how we filter writes to EF and EC fields since we do not
    // have neither a co-processor nor the FPU
    result = ((rs1 ^ rs2) & 0x00FFCFFF) | 0xF3000000;
    supervisorException = (PSR[key_S] == 0);
    illegalCWP = (result & 0x0000001f) >= NUM_REG_WIN;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEpsr_reg::behavior_execute( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rs1 rs1_execute
    #define rs2 rs2_execute


    if(!(supervisorException || illegalCWP)){
        PSR = result;
    }
    unlockQueue[0].push_back(&PSR_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEpsr_reg::behavior_memory( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEpsr_reg::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception
    #define rs1 rs1_exception
    #define rs2 rs2_exception


    if(supervisorException){
        RaiseException(pcounter, npcounter, PRIVILEDGE_INSTR);
    }
    if(illegalCWP){
        RaiseException(pcounter, npcounter, ILLEGAL_INSTR);
    }

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

unsigned int leon3_accat_trap::WRITEpsr_reg::behavior_wb( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rs1 rs1_wb
    #define rs2 rs2_wb

    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rs1
    #undef rs2
    return this->stageCycles;
}

std::string leon3_accat_trap::WRITEpsr_reg::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    if(this->rs2_decode.isLocked()){
        retVal += "rs2 - ";
    }
    return retVal;
}

bool leon3_accat_trap::WRITEpsr_reg::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEpsr_reg::lockRegs_fetch(){

}

bool leon3_accat_trap::WRITEpsr_reg::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    regLocked = this->rs2_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::WRITEpsr_reg::lockRegs_decode(){
    this->PSR_pipe.lock();
}

bool leon3_accat_trap::WRITEpsr_reg::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEpsr_reg::lockRegs_regs(){

}

bool leon3_accat_trap::WRITEpsr_reg::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEpsr_reg::lockRegs_execute(){

}

bool leon3_accat_trap::WRITEpsr_reg::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEpsr_reg::lockRegs_memory(){

}

bool leon3_accat_trap::WRITEpsr_reg::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEpsr_reg::lockRegs_exception(){

}

bool leon3_accat_trap::WRITEpsr_reg::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::WRITEpsr_reg::lockRegs_wb(){

}

void leon3_accat_trap::WRITEpsr_reg::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
}

void leon3_accat_trap::WRITEpsr_reg::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
}

void leon3_accat_trap::WRITEpsr_reg::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
}

void leon3_accat_trap::WRITEpsr_reg::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
}

void leon3_accat_trap::WRITEpsr_reg::getUnlock_exception( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
}

void leon3_accat_trap::WRITEpsr_reg::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
}

Instruction * leon3_accat_trap::WRITEpsr_reg::replicate() const throw(){
    return new WRITEpsr_reg(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, \
        GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, \
        NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, \
        PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::WRITEpsr_reg::getInstructionName() const throw(){
    return "WRITEpsr_reg";
}

unsigned int leon3_accat_trap::WRITEpsr_reg::getId() const throw(){
    return 134;
}

void leon3_accat_trap::WRITEpsr_reg::setParams( const unsigned int & bitString ) throw(){
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->rs2_bit = (bitString & 0x1f);
    this->rs2_fetch.directSetAlias(this->REGS_fetch[this->rs2_bit]);
    this->rs2_decode.directSetAlias(this->REGS_decode[this->rs2_bit]);
    this->rs2_regs.directSetAlias(this->REGS_regs[this->rs2_bit]);
    this->rs2_execute.directSetAlias(this->REGS_execute[this->rs2_bit]);
    this->rs2_memory.directSetAlias(this->REGS_memory[this->rs2_bit]);
    this->rs2_exception.directSetAlias(this->REGS_exception[this->rs2_bit]);
    this->rs2_wb.directSetAlias(this->REGS_wb[this->rs2_bit]);
    this->rd = (bitString & 0x3e000000) >> 25;
}

std::string leon3_accat_trap::WRITEpsr_reg::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "wr r";
    oss << this->rs1_bit;
    oss << " r";
    oss << this->rs2_bit;
    oss << " psr";
    return oss.str();
}

leon3_accat_trap::WRITEpsr_reg::WRITEpsr_reg( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
    this->rs2_fetch.setPipeId(0);
    this->rs2_decode.setPipeId(1);
    this->rs2_regs.setPipeId(2);
    this->rs2_execute.setPipeId(3);
    this->rs2_memory.setPipeId(4);
    this->rs2_exception.setPipeId(5);
    this->rs2_wb.setPipeId(6);
}

leon3_accat_trap::WRITEpsr_reg::~WRITEpsr_reg(){

}
unsigned int leon3_accat_trap::ANDcc_imm::behavior_fetch( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch
    #define rd rd_fetch
    #define rs1 rs1_fetch


    unsigned int npc = NPC;
    PC = npc;
    npc += 4;
    NPC = npc;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ANDcc_imm::behavior_decode( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ANDcc_imm::behavior_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_regs
    #define WIM WIM_regs
    #define TBR TBR_regs
    #define Y Y_regs
    #define PC PC_regs
    #define NPC NPC_regs
    #define GLOBAL GLOBAL_regs
    #define WINREGS WINREGS_regs
    #define ASR ASR_regs
    #define FP FP_regs
    #define LR LR_regs
    #define SP SP_regs
    #define PCR PCR_regs
    #define REGS REGS_regs
    #define rd rd_regs
    #define rs1 rs1_regs


    rs1_op = rs1;

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ANDcc_imm::behavior_execute( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_execute
    #define WIM WIM_execute
    #define TBR TBR_execute
    #define Y Y_execute
    #define PC PC_execute
    #define NPC NPC_execute
    #define GLOBAL GLOBAL_execute
    #define WINREGS WINREGS_execute
    #define ASR ASR_execute
    #define FP FP_execute
    #define LR LR_execute
    #define SP SP_execute
    #define PCR PCR_execute
    #define REGS REGS_execute
    #define rd rd_execute
    #define rs1 rs1_execute


    result = rs1_op & SignExtend(simm13, 13);


    PSR[key_ICC_n] = ((result & 0x80000000) >> 31);
    PSR[key_ICC_z] = (result == 0);
    PSR[key_ICC_v] = 0;
    PSR[key_ICC_c] = 0;
    unlockQueue[0].push_back(&PSR_execute);

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ANDcc_imm::behavior_memory( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ANDcc_imm::behavior_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::ANDcc_imm::behavior_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    this->stageCycles = 0;

    #define PSR PSR_wb
    #define WIM WIM_wb
    #define TBR TBR_wb
    #define Y Y_wb
    #define PC PC_wb
    #define NPC NPC_wb
    #define GLOBAL GLOBAL_wb
    #define WINREGS WINREGS_wb
    #define ASR ASR_wb
    #define FP FP_wb
    #define LR LR_wb
    #define SP SP_wb
    #define PCR PCR_wb
    #define REGS REGS_wb
    #define rd rd_wb
    #define rs1 rs1_wb

    {


        rd = result;
    }
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());

    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    #undef rd
    #undef rs1
    return this->stageCycles;
}

std::string leon3_accat_trap::ANDcc_imm::printBusyRegs(){
    std::string retVal = "";
    if(this->rs1_decode.isLocked()){
        retVal += "rs1 - ";
    }
    return retVal;
}

bool leon3_accat_trap::ANDcc_imm::checkHazard_fetch(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ANDcc_imm::lockRegs_fetch(){

}

bool leon3_accat_trap::ANDcc_imm::checkHazard_decode(){
    bool regLocked = false;
    regLocked = this->rs1_decode.isLocked() || regLocked;
    return !regLocked;
}

void leon3_accat_trap::ANDcc_imm::lockRegs_decode(){
    this->rd_decode.lock();
    this->PSR_pipe.lock();
}

bool leon3_accat_trap::ANDcc_imm::checkHazard_regs(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ANDcc_imm::lockRegs_regs(){

}

bool leon3_accat_trap::ANDcc_imm::checkHazard_execute(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ANDcc_imm::lockRegs_execute(){

}

bool leon3_accat_trap::ANDcc_imm::checkHazard_memory(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ANDcc_imm::lockRegs_memory(){

}

bool leon3_accat_trap::ANDcc_imm::checkHazard_exception(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ANDcc_imm::lockRegs_exception(){

}

bool leon3_accat_trap::ANDcc_imm::checkHazard_wb(){
    bool regLocked = false;
    return !regLocked;
}

void leon3_accat_trap::ANDcc_imm::lockRegs_wb(){

}

void leon3_accat_trap::ANDcc_imm::getUnlock_decode( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_decode.getPipeReg());
}

void leon3_accat_trap::ANDcc_imm::getUnlock_regs( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_regs.getPipeReg());
}

void leon3_accat_trap::ANDcc_imm::getUnlock_execute( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_execute);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_execute.getPipeReg());
}

void leon3_accat_trap::ANDcc_imm::getUnlock_memory( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_memory.getPipeReg());
}

void leon3_accat_trap::ANDcc_imm::getUnlock_exception( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_exception.getPipeReg());
}

void leon3_accat_trap::ANDcc_imm::getUnlock_wb( std::map< unsigned int, std::vector< \
    Register * > > & unlockQueue ){
    unlockQueue[0].push_back(&PSR_fetch);
    unlockQueue[0].push_back(&PSR_decode);
    unlockQueue[0].push_back(&PSR_regs);
    unlockQueue[0].push_back(&PSR_memory);
    unlockQueue[0].push_back(&PSR_exception);
    unlockQueue[0].push_back(&PSR_wb);
    unlockQueue[0].push_back(PSR_pipe.getRegister());
    unlockQueue[0].push_back(rd_wb.getPipeReg());
}

Instruction * leon3_accat_trap::ANDcc_imm::replicate() const throw(){
    return new ANDcc_imm(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, \
        WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, \
        GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, \
        REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck);
}

std::string leon3_accat_trap::ANDcc_imm::getInstructionName() const throw(){
    return "ANDcc_imm";
}

unsigned int leon3_accat_trap::ANDcc_imm::getId() const throw(){
    return 39;
}

void leon3_accat_trap::ANDcc_imm::setParams( const unsigned int & bitString ) throw(){
    this->rd_bit = (bitString & 0x3e000000) >> 25;
    this->rd_fetch.directSetAlias(this->REGS_fetch[this->rd_bit]);
    this->rd_decode.directSetAlias(this->REGS_decode[this->rd_bit]);
    this->rd_regs.directSetAlias(this->REGS_regs[this->rd_bit]);
    this->rd_execute.directSetAlias(this->REGS_execute[this->rd_bit]);
    this->rd_memory.directSetAlias(this->REGS_memory[this->rd_bit]);
    this->rd_exception.directSetAlias(this->REGS_exception[this->rd_bit]);
    this->rd_wb.directSetAlias(this->REGS_wb[this->rd_bit]);
    this->rs1_bit = (bitString & 0x7c000) >> 14;
    this->rs1_fetch.directSetAlias(this->REGS_fetch[this->rs1_bit]);
    this->rs1_decode.directSetAlias(this->REGS_decode[this->rs1_bit]);
    this->rs1_regs.directSetAlias(this->REGS_regs[this->rs1_bit]);
    this->rs1_execute.directSetAlias(this->REGS_execute[this->rs1_bit]);
    this->rs1_memory.directSetAlias(this->REGS_memory[this->rs1_bit]);
    this->rs1_exception.directSetAlias(this->REGS_exception[this->rs1_bit]);
    this->rs1_wb.directSetAlias(this->REGS_wb[this->rs1_bit]);
    this->simm13 = (bitString & 0x1fff);
}

std::string leon3_accat_trap::ANDcc_imm::getMnemonic() const throw(){
    std::ostringstream oss (std::ostringstream::out);
    oss << "andcc r";
    oss << this->rs1_bit;
    oss << " ";
    oss << this->simm13;
    oss << " r";
    oss << this->rd_bit;
    return oss.str();
}

leon3_accat_trap::ANDcc_imm::ANDcc_imm( PipelineRegister & PSR_pipe, PipelineRegister \
    & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, PipelineRegister \
    & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, PipelineRegister \
    * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, Reg32_1 & WIM_fetch, \
    Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, Reg32_3 & NPC_fetch, \
    RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 * ASR_fetch, Alias \
    & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, Alias * REGS_fetch, \
    Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, Reg32_3 & Y_decode, \
    Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass & GLOBAL_decode, Reg32_3 \
    * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, Alias & LR_decode, Alias \
    & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 & PSR_regs, Reg32_1 \
    & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, Reg32_3 & NPC_regs, \
    RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 * ASR_regs, Alias \
    & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, Alias * REGS_regs, \
    Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, Reg32_3 & Y_execute, \
    Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass & GLOBAL_execute, \
    Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, Alias & LR_execute, \
    Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, Reg32_0 & PSR_memory, \
    Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, Reg32_3 & PC_memory, \
    Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 * WINREGS_memory, \
    Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias & SP_memory, Alias \
    & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 & WIM_exception, \
    Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, Reg32_3 & \
    NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck ) : Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, \
    PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, \
    Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, \
    SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, \
    NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, \
    PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, \
    GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, \
    PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, \
    WINREGS_execute, ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, \
    PSR_memory, WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, \
    WINREGS_memory, ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, \
    PSR_exception, WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, \
    GLOBAL_exception, WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, \
    PCR_exception, REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, \
    WINREGS_wb, ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck){
    this->rd_fetch.setPipeId(0);
    this->rd_decode.setPipeId(1);
    this->rd_regs.setPipeId(2);
    this->rd_execute.setPipeId(3);
    this->rd_memory.setPipeId(4);
    this->rd_exception.setPipeId(5);
    this->rd_wb.setPipeId(6);
    this->rs1_fetch.setPipeId(0);
    this->rs1_decode.setPipeId(1);
    this->rs1_regs.setPipeId(2);
    this->rs1_execute.setPipeId(3);
    this->rs1_memory.setPipeId(4);
    this->rs1_exception.setPipeId(5);
    this->rs1_wb.setPipeId(6);
}

leon3_accat_trap::ANDcc_imm::~ANDcc_imm(){

}
unsigned int leon3_accat_trap::IRQ_IRQ_Instruction::behavior_fetch( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    #define PSR PSR_fetch
    #define WIM WIM_fetch
    #define TBR TBR_fetch
    #define Y Y_fetch
    #define PC PC_fetch
    #define NPC NPC_fetch
    #define GLOBAL GLOBAL_fetch
    #define WINREGS WINREGS_fetch
    #define ASR ASR_fetch
    #define FP FP_fetch
    #define LR LR_fetch
    #define SP SP_fetch
    #define PCR PCR_fetch
    #define REGS REGS_fetch


    pcounter = PC;
    #ifndef ACC_MODEL
    npcounter = NPC;
    #endif
    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    return this->stageCycles;
}

unsigned int leon3_accat_trap::IRQ_IRQ_Instruction::behavior_decode( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    #define PSR PSR_decode
    #define WIM WIM_decode
    #define TBR TBR_decode
    #define Y Y_decode
    #define PC PC_decode
    #define NPC NPC_decode
    #define GLOBAL GLOBAL_decode
    #define WINREGS WINREGS_decode
    #define ASR ASR_decode
    #define FP FP_decode
    #define LR LR_decode
    #define SP SP_decode
    #define PCR PCR_decode
    #define REGS REGS_decode


    #ifdef ACC_MODEL
    npcounter = PC;
    #endif
    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    return this->stageCycles;
}

unsigned int leon3_accat_trap::IRQ_IRQ_Instruction::behavior_regs( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::IRQ_IRQ_Instruction::behavior_execute( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::IRQ_IRQ_Instruction::behavior_memory( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

unsigned int leon3_accat_trap::IRQ_IRQ_Instruction::behavior_exception( std::map< \
    unsigned int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    #define PSR PSR_exception
    #define WIM WIM_exception
    #define TBR TBR_exception
    #define Y Y_exception
    #define PC PC_exception
    #define NPC NPC_exception
    #define GLOBAL GLOBAL_exception
    #define WINREGS WINREGS_exception
    #define ASR ASR_exception
    #define FP FP_exception
    #define LR LR_exception
    #define SP SP_exception
    #define PCR PCR_exception
    #define REGS REGS_exception

    //Basically, what I have to do when
    //an interrupt arrives is very simple: we check that interrupts
    //are enabled and that the the processor can take this interrupt
    //(valid interrupt level). The we simply raise an exception and
    //acknowledge the IRQ on the irqAck port.
    //All of this can be simply done by calling the
    //RaiseException method
    // Note that 38 corresponds to the highest defined exception
    // (IMPL_DEP_EXC): this because interrupt 1 has id 37, etc.
    RaiseException(pcounter, npcounter, 38 - IRQ);
    #undef PSR
    #undef WIM
    #undef TBR
    #undef Y
    #undef PC
    #undef NPC
    #undef GLOBAL
    #undef WINREGS
    #undef ASR
    #undef FP
    #undef LR
    #undef SP
    #undef PCR
    #undef REGS
    return this->stageCycles;
}

unsigned int leon3_accat_trap::IRQ_IRQ_Instruction::behavior_wb( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){
    this->stageCycles = 0;
    return this->stageCycles;
}

Instruction * leon3_accat_trap::IRQ_IRQ_Instruction::replicate() const throw(){
    return new IRQ_IRQ_Instruction(PSR_pipe, WIM_pipe, TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, \
        GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, \
        NPC_fetch, GLOBAL_fetch, WINREGS_fetch, ASR_fetch, FP_fetch, LR_fetch, SP_fetch, \
        PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, TBR_decode, Y_decode, PC_decode, NPC_decode, \
        GLOBAL_decode, WINREGS_decode, ASR_decode, FP_decode, LR_decode, SP_decode, PCR_decode, \
        REGS_decode, PSR_regs, WIM_regs, TBR_regs, Y_regs, PC_regs, NPC_regs, GLOBAL_regs, \
        WINREGS_regs, ASR_regs, FP_regs, LR_regs, SP_regs, PCR_regs, REGS_regs, PSR_execute, \
        WIM_execute, TBR_execute, Y_execute, PC_execute, NPC_execute, GLOBAL_execute, WINREGS_execute, \
        ASR_execute, FP_execute, LR_execute, SP_execute, PCR_execute, REGS_execute, PSR_memory, \
        WIM_memory, TBR_memory, Y_memory, PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, \
        ASR_memory, FP_memory, LR_memory, SP_memory, PCR_memory, REGS_memory, PSR_exception, \
        WIM_exception, TBR_exception, Y_exception, PC_exception, NPC_exception, GLOBAL_exception, \
        WINREGS_exception, ASR_exception, FP_exception, LR_exception, SP_exception, PCR_exception, \
        REGS_exception, PSR_wb, WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, \
        ASR_wb, FP_wb, LR_wb, SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck, this->IRQ);
}

void leon3_accat_trap::IRQ_IRQ_Instruction::setParams( const unsigned int & bitString \
    ) throw(){

}

std::string leon3_accat_trap::IRQ_IRQ_Instruction::getInstructionName() const throw(){
    return "IRQ_IRQ_Instruction";
}

std::string leon3_accat_trap::IRQ_IRQ_Instruction::getMnemonic() const throw(){
    return "irq_IRQ";
}

unsigned int leon3_accat_trap::IRQ_IRQ_Instruction::getId() const throw(){
    return (unsigned int)-1;
}

bool leon3_accat_trap::IRQ_IRQ_Instruction::checkHazard_fetch(){

}

void leon3_accat_trap::IRQ_IRQ_Instruction::lockRegs_fetch(){

}

bool leon3_accat_trap::IRQ_IRQ_Instruction::checkHazard_decode(){

}

void leon3_accat_trap::IRQ_IRQ_Instruction::lockRegs_decode(){

}

bool leon3_accat_trap::IRQ_IRQ_Instruction::checkHazard_regs(){

}

void leon3_accat_trap::IRQ_IRQ_Instruction::lockRegs_regs(){

}

bool leon3_accat_trap::IRQ_IRQ_Instruction::checkHazard_execute(){

}

void leon3_accat_trap::IRQ_IRQ_Instruction::lockRegs_execute(){

}

bool leon3_accat_trap::IRQ_IRQ_Instruction::checkHazard_memory(){

}

void leon3_accat_trap::IRQ_IRQ_Instruction::lockRegs_memory(){

}

bool leon3_accat_trap::IRQ_IRQ_Instruction::checkHazard_exception(){

}

void leon3_accat_trap::IRQ_IRQ_Instruction::lockRegs_exception(){

}

bool leon3_accat_trap::IRQ_IRQ_Instruction::checkHazard_wb(){

}

void leon3_accat_trap::IRQ_IRQ_Instruction::lockRegs_wb(){

}

void leon3_accat_trap::IRQ_IRQ_Instruction::getUnlock_decode( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){

}

void leon3_accat_trap::IRQ_IRQ_Instruction::getUnlock_regs( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){

}

void leon3_accat_trap::IRQ_IRQ_Instruction::getUnlock_execute( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){

}

void leon3_accat_trap::IRQ_IRQ_Instruction::getUnlock_memory( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){

}

void leon3_accat_trap::IRQ_IRQ_Instruction::getUnlock_exception( std::map< unsigned \
    int, std::vector< Register * > > & unlockQueue ){

}

void leon3_accat_trap::IRQ_IRQ_Instruction::getUnlock_wb( std::map< unsigned int, \
    std::vector< Register * > > & unlockQueue ){

}

std::string leon3_accat_trap::IRQ_IRQ_Instruction::printBusyRegs(){
    return "";
}

leon3_accat_trap::IRQ_IRQ_Instruction::IRQ_IRQ_Instruction( PipelineRegister & PSR_pipe, \
    PipelineRegister & WIM_pipe, PipelineRegister & TBR_pipe, PipelineRegister & Y_pipe, \
    PipelineRegister & PC_pipe, PipelineRegister & NPC_pipe, PipelineRegister * GLOBAL_pipe, \
    PipelineRegister * WINREGS_pipe, PipelineRegister * ASR_pipe, Reg32_0 & PSR_fetch, \
    Reg32_1 & WIM_fetch, Reg32_2 & TBR_fetch, Reg32_3 & Y_fetch, Reg32_3 & PC_fetch, \
    Reg32_3 & NPC_fetch, RegisterBankClass & GLOBAL_fetch, Reg32_3 * WINREGS_fetch, Reg32_3 \
    * ASR_fetch, Alias & FP_fetch, Alias & LR_fetch, Alias & SP_fetch, Alias & PCR_fetch, \
    Alias * REGS_fetch, Reg32_0 & PSR_decode, Reg32_1 & WIM_decode, Reg32_2 & TBR_decode, \
    Reg32_3 & Y_decode, Reg32_3 & PC_decode, Reg32_3 & NPC_decode, RegisterBankClass \
    & GLOBAL_decode, Reg32_3 * WINREGS_decode, Reg32_3 * ASR_decode, Alias & FP_decode, \
    Alias & LR_decode, Alias & SP_decode, Alias & PCR_decode, Alias * REGS_decode, Reg32_0 \
    & PSR_regs, Reg32_1 & WIM_regs, Reg32_2 & TBR_regs, Reg32_3 & Y_regs, Reg32_3 & PC_regs, \
    Reg32_3 & NPC_regs, RegisterBankClass & GLOBAL_regs, Reg32_3 * WINREGS_regs, Reg32_3 \
    * ASR_regs, Alias & FP_regs, Alias & LR_regs, Alias & SP_regs, Alias & PCR_regs, \
    Alias * REGS_regs, Reg32_0 & PSR_execute, Reg32_1 & WIM_execute, Reg32_2 & TBR_execute, \
    Reg32_3 & Y_execute, Reg32_3 & PC_execute, Reg32_3 & NPC_execute, RegisterBankClass \
    & GLOBAL_execute, Reg32_3 * WINREGS_execute, Reg32_3 * ASR_execute, Alias & FP_execute, \
    Alias & LR_execute, Alias & SP_execute, Alias & PCR_execute, Alias * REGS_execute, \
    Reg32_0 & PSR_memory, Reg32_1 & WIM_memory, Reg32_2 & TBR_memory, Reg32_3 & Y_memory, \
    Reg32_3 & PC_memory, Reg32_3 & NPC_memory, RegisterBankClass & GLOBAL_memory, Reg32_3 \
    * WINREGS_memory, Reg32_3 * ASR_memory, Alias & FP_memory, Alias & LR_memory, Alias \
    & SP_memory, Alias & PCR_memory, Alias * REGS_memory, Reg32_0 & PSR_exception, Reg32_1 \
    & WIM_exception, Reg32_2 & TBR_exception, Reg32_3 & Y_exception, Reg32_3 & PC_exception, \
    Reg32_3 & NPC_exception, RegisterBankClass & GLOBAL_exception, Reg32_3 * WINREGS_exception, \
    Reg32_3 * ASR_exception, Alias & FP_exception, Alias & LR_exception, Alias & SP_exception, \
    Alias & PCR_exception, Alias * REGS_exception, Reg32_0 & PSR_wb, Reg32_1 & WIM_wb, \
    Reg32_2 & TBR_wb, Reg32_3 & Y_wb, Reg32_3 & PC_wb, Reg32_3 & NPC_wb, RegisterBankClass \
    & GLOBAL_wb, Reg32_3 * WINREGS_wb, Reg32_3 * ASR_wb, Alias & FP_wb, Alias & LR_wb, \
    Alias & SP_wb, Alias & PCR_wb, Alias * REGS_wb, TLMMemory & instrMem, TLMMemory & \
    dataMem, PinTLM_out_32 & irqAck, unsigned int & IRQ ) : Instruction(PSR_pipe, WIM_pipe, \
    TBR_pipe, Y_pipe, PC_pipe, NPC_pipe, GLOBAL_pipe, WINREGS_pipe, ASR_pipe, PSR_fetch, \
    WIM_fetch, TBR_fetch, Y_fetch, PC_fetch, NPC_fetch, GLOBAL_fetch, WINREGS_fetch, \
    ASR_fetch, FP_fetch, LR_fetch, SP_fetch, PCR_fetch, REGS_fetch, PSR_decode, WIM_decode, \
    TBR_decode, Y_decode, PC_decode, NPC_decode, GLOBAL_decode, WINREGS_decode, ASR_decode, \
    FP_decode, LR_decode, SP_decode, PCR_decode, REGS_decode, PSR_regs, WIM_regs, TBR_regs, \
    Y_regs, PC_regs, NPC_regs, GLOBAL_regs, WINREGS_regs, ASR_regs, FP_regs, LR_regs, \
    SP_regs, PCR_regs, REGS_regs, PSR_execute, WIM_execute, TBR_execute, Y_execute, PC_execute, \
    NPC_execute, GLOBAL_execute, WINREGS_execute, ASR_execute, FP_execute, LR_execute, \
    SP_execute, PCR_execute, REGS_execute, PSR_memory, WIM_memory, TBR_memory, Y_memory, \
    PC_memory, NPC_memory, GLOBAL_memory, WINREGS_memory, ASR_memory, FP_memory, LR_memory, \
    SP_memory, PCR_memory, REGS_memory, PSR_exception, WIM_exception, TBR_exception, \
    Y_exception, PC_exception, NPC_exception, GLOBAL_exception, WINREGS_exception, ASR_exception, \
    FP_exception, LR_exception, SP_exception, PCR_exception, REGS_exception, PSR_wb, \
    WIM_wb, TBR_wb, Y_wb, PC_wb, NPC_wb, GLOBAL_wb, WINREGS_wb, ASR_wb, FP_wb, LR_wb, \
    SP_wb, PCR_wb, REGS_wb, instrMem, dataMem, irqAck), IRQ(IRQ){

}

leon3_accat_trap::IRQ_IRQ_Instruction::~IRQ_IRQ_Instruction(){

}

