#! /usr/bin/env python
# -*- coding: iso-8859-1 -*-

import Options

def build(bld):
    # Generation of the testMaster library
    obj = bld.new_task_gen('cxx', 'cshlib')
    obj.source ='''
        testMaster.cpp
    '''
    obj.target = 'testMaster'
    obj.uselib = 'SYSTEMC_H TLM'
    obj.uselib_local = 'systemc'

    # Generation of the testMaster wrapper extension
    obj = bld.new_task_gen('pypp')
    obj.source ='''
        testMaster.hpp
    '''
    obj.target = 'testMaster_wrapper'
    obj.uselib = 'SYSTEMC_H TLM BOOST PYEXT BOOST_PYTHON'
    obj.uselib_local = 'systemc testMaster'
    obj.include = 'scwrapper tlmwrapper'
    obj.start_decls = 'testMaster'
    obj.custom_code = """
# Include Transport Interfaces
#cls = mb.global_ns.classes(lambda decl: decl.name.find('transport_if') > 0, allow_empty=True)
#for i in cls:
    #i.include()
    #i.alias = 'TLM_'+i.alias

# Include simple sockets
cls = mb.global_ns.classes(lambda decl: decl.name.startswith('tlm_base_target_socket') or decl.name.startswith('tlm_target_socket') , allow_empty=True)
for i in cls:
    i.include()
    i.member_functions(allow_empty=True).exclude()
    i.alias = 'TLM_'+i.alias

cls = mb.global_ns.classes(lambda decl: decl.name.startswith('tlm_base_initiator_socket') or decl.name.startswith('tlm_initiator_socket'), allow_empty=True)
for i in cls:
    i.include()
    i.member_functions(allow_empty=True).exclude()
    for k in i.member_functions(allow_empty=True):
        if k.name == 'bind':  k.include()

    i.alias = 'TLM_'+i.alias

cls = mb.global_ns.classes(lambda decl: decl.name.startswith('simple_') > 0, allow_empty=True)
for i in cls:
    i.include()
    i.alias = 'TLM_'+i.alias

# Exclude protected members
cls = mb.global_ns.calldefs( declarations.access_type_matcher_t( 'protected' ) , allow_empty=True )
if cls: cls.exclude()
"""

    # Generation of the testSlave library
    obj = bld.new_task_gen('cxx', 'cshlib')
    obj.source ='''
        testSlave.cpp
    '''
    obj.target = 'testSlave'
    obj.uselib = 'SYSTEMC_H TLM'
    obj.uselib_local = 'systemc'

    # Generation of the testSlave wrapper extension
    obj = bld.new_task_gen('pypp')
    obj.source ='''
        testSlave.hpp
    '''
    obj.target = 'testSlave_wrapper'
    obj.uselib = 'SYSTEMC_H TLM BOOST PYEXT BOOST_PYTHON'
    obj.uselib_local = 'systemc testSlave'
    obj.include = 'scwrapper tlmwrapper'
    obj.start_decls = 'tlm tlm_utils testSlave'
    obj.custom_code = """
# Include Transport Interfaces
#cls = mb.global_ns.classes(lambda decl: decl.name.find('transport_if') > 0, allow_empty=True)
#for i in cls:
    #i.include()
    #i.alias = 'TLM_'+i.alias

# Include simple sockets
cls = mb.global_ns.classes(lambda decl: decl.name.startswith('tlm_base_target_socket') or decl.name.startswith('tlm_target_socket') , allow_empty=True)
for i in cls:
    i.include()
    i.member_functions(allow_empty=True).exclude()
    i.alias = 'TLM_'+i.alias

cls = mb.global_ns.classes(lambda decl: decl.name.startswith('tlm_base_initiator_socket') or decl.name.startswith('tlm_initiator_socket'), allow_empty=True)
for i in cls:
    i.include()
    i.member_functions(allow_empty=True).exclude()
    for k in i.member_functions(allow_empty=True):
        if k.name == 'bind':  k.include()

    i.alias = 'TLM_'+i.alias

cls = mb.global_ns.classes(lambda decl: decl.name.startswith('simple_') > 0, allow_empty=True)
for i in cls:
    i.include()
    i.alias = 'TLM_'+i.alias

# Exclude protected members
cls = mb.global_ns.calldefs( declarations.access_type_matcher_t( 'protected' ) , allow_empty=True )
if cls: cls.exclude()
"""
